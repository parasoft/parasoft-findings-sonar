<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<ResultsSession buildId="Default Project-2024-01-26" date="01/26/24 16:12:12" endTime="1970-01-01T08:00:00+08:00" machine="CD-LLI" project="Default Project" tag="test" time="2024-01-26T16:12:12+08:00" toolName="C++test" toolVer="2023.2.0.20231205B2318" user="liwbo">
   <TestConfig machine="CD-LLI" name="test" pseudoUrl="c++test.user://test" user="liwbo"/>
   <Authors>
      <Author id="dev1" name="liwbo"/>
   </Authors>
   <VersionInfos>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="IExecutionViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="InsureViolation" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.scope" resultId="IScopeProjectInfo" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationInfo" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationProjectInfo" ver="2"/>
   </VersionInfos>
   
      <Locations>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\DivisionByZero.cpp" loc="/FlowAnalysisCpp/DivisionByZero.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_NullPointer_cpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\DeadLock.cpp" loc="/FlowAnalysisCpp/DeadLock.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_MemoryLeak_cpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\Point.hpp" loc="/FlowAnalysisCpp/Point.hpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\NullPointer.cpp" loc="/FlowAnalysisCpp/NullPointer.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_DeadLock_cpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\MemoryLeak.cpp" loc="/FlowAnalysisCpp/MemoryLeak.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_Shapes_hpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\Shapes.hpp" loc="/FlowAnalysisCpp/Shapes.hpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_DivisionByZero_cpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DivisionByZero_cpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
         <Loc fsPath="D:\gitLab\builds\z7mMpynar\0\LeeParasoft\FlowAnalysisCpp\tests\autogenerated\TestSuite_Point_hpp.cpp" loc="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" projPath="/FlowAnalysisCpp" project="FlowAnalysisCpp"/>
      </Locations>
   
   
      <ExecutedTestsDetails type="UT">
         <Total authChange="0;" authFail="36;" change="0" changePass="0" changeTotal="0" fail="36" name="Passed / Total" pass="126" time="0:00:45.203" total="162">
            <Project authChange="0;" authFail="36;" change="0" changePass="0" changeTotal="0" fail="36" name="FlowAnalysisCpp" pass="126" time="0:00:45.203" total="162">
               <TestSuite authChange="0;" authFail="36;" change="0" changePass="0" changeTotal="0" fail="36" id="CPP:///FlowAnalysisCpp/tests" name="tests" pass="126" time="0:00:45.203" tool="C++test" total="162">
                  <TestSuite authChange="0;" authFail="36;" change="0" changePass="0" changeTotal="0" fail="36" id="CPP:///FlowAnalysisCpp/tests/autogenerated" name="autogenerated" pass="126" time="0:00:45.203" tool="C++test" total="162">
                     <TestSuite authChange="0;" authFail="21;" change="0" changePass="0" changeTotal="0" fail="21" id="CPP://-4561319657089747031" name="TestSuite_DeadLock_cpp_2788e23e" pass="32" time="0:00:45.114" tool="C++test" total="53">
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021268" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-6128051226663726216" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021237" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021206" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021175" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021144" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-169768059074021113" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_6" pass="0" time="0:00:00.004" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021082" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021051" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-169768059074021020" name="TestSuite_DeadLock_cpp_2788e23e::test_assertion_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-8787606607065969279" name="TestSuite_DeadLock_cpp_2788e23e::test_Controller_Thread_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-609226132687776066" name="TestSuite_DeadLock_cpp_2788e23e::test_draw_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://2590983518837012229" name="TestSuite_DeadLock_cpp_2788e23e::test_GameLogic_Thread_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847168" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_1" pass="0" time="0:00:05.020" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-1895652858647320860" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_10" pass="0" time="0:00:05.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847199" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_2" pass="0" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847230" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_3" pass="0" time="0:00:05.030" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847261" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_4" pass="0" time="0:00:05.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847292" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_5" pass="0" time="0:00:05.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847323" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_6" pass="0" time="0:00:05.009" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847354" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_7" pass="0" time="0:00:05.024" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847385" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_8" pass="0" time="0:00:05.010" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://5917323524961847416" name="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_9" pass="0" time="0:00:05.010" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139333" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_1" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://2769153150642923465" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_10" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139302" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_2" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139271" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_3" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139240" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_4" pass="0" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139209" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_5" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139178" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_6" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139147" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_7" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139116" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_8" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3453099028911139085" name="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_9" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973832" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4782954082015981348" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973863" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973894" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973925" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973956" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282973987" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282974018" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282974049" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692282974080" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758326" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1063734692284270190" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758357" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758388" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758419" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758450" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758481" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758512" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758543" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7797956420834758574" name="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                     </TestSuite>
                     <TestSuite authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-5501795322572082346" name="TestSuite_DivisionByZero_cpp_e7ecfacc" pass="0" time="0:00:00.000" tool="C++test" total="1">
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3900030495373673724" name="TestSuite_DivisionByZero_cpp_e7ecfacc::test_getShapeRatio_1" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                     </TestSuite>
                     <TestSuite authChange="0;" authFail="5;" change="0" changePass="0" changeTotal="0" fail="5" id="CPP://1238302290035616581" name="TestSuite_MemoryLeak_cpp_2b9e8ccf" pass="3" time="0:00:00.085" tool="C++test" total="8">
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-3483263584330555006" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3483263584330554975" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_2" pass="0" time="0:00:00.029" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-3483263584330554944" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3483263584330554913" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_4" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-3483263584330554882" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3483263584330554851" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_6" pass="0" time="0:00:00.028" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3483263584330554820" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_7" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-3483263584330554789" name="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_8" pass="0" time="0:00:00.028" tool="C++test" total="1"/>
                     </TestSuite>
                     <TestSuite authChange="0;" authFail="9;" change="0" changePass="0" changeTotal="0" fail="9" id="CPP://5295344643796357332" name="TestSuite_NullPointer_cpp_d41cc372" pass="1" time="0:00:00.001" tool="C++test" total="10">
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555267" name="TestSuite_NullPointer_cpp_d41cc372::test_main_1" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://8596611062750787591" name="TestSuite_NullPointer_cpp_d41cc372::test_main_10" pass="0" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555236" name="TestSuite_NullPointer_cpp_d41cc372::test_main_2" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555205" name="TestSuite_NullPointer_cpp_d41cc372::test_main_3" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555174" name="TestSuite_NullPointer_cpp_d41cc372::test_main_4" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555143" name="TestSuite_NullPointer_cpp_d41cc372::test_main_5" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-6240397817828555112" name="TestSuite_NullPointer_cpp_d41cc372::test_main_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555081" name="TestSuite_NullPointer_cpp_d41cc372::test_main_7" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555050" name="TestSuite_NullPointer_cpp_d41cc372::test_main_8" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="1;" change="0" changePass="0" changeTotal="0" fail="1" id="CPP://-6240397817828555019" name="TestSuite_NullPointer_cpp_d41cc372::test_main_9" pass="0" time="0:00:00.000" tool="C++test" total="1"/>
                     </TestSuite>
                     <TestSuite authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://2148407446120162727" name="TestSuite_Point_hpp_521bf514" pass="40" time="0:00:00.001" tool="C++test" total="40">
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948001910" name="TestSuite_Point_hpp_521bf514::test_Point_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-2133252297076523858" name="TestSuite_Point_hpp_521bf514::test_Point_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948001941" name="TestSuite_Point_hpp_521bf514::test_Point_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948001972" name="TestSuite_Point_hpp_521bf514::test_Point_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002003" name="TestSuite_Point_hpp_521bf514::test_Point_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002034" name="TestSuite_Point_hpp_521bf514::test_Point_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002065" name="TestSuite_Point_hpp_521bf514::test_Point_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002096" name="TestSuite_Point_hpp_521bf514::test_Point_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002127" name="TestSuite_Point_hpp_521bf514::test_Point_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5909659026948002158" name="TestSuite_Point_hpp_521bf514::test_Point_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128754" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-2081593499300887274" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128723" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128692" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128661" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128630" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128599" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128568" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128537" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-7774968550392128506" name="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142045" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-6118053482694628057" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142076" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_2" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142107" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142138" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142169" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142200" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142231" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142262" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5186060792776142293" name="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337240" name="TestSuite_Point_hpp_521bf514::test_translate_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://2011791189691871372" name="TestSuite_Point_hpp_521bf514::test_translate_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337271" name="TestSuite_Point_hpp_521bf514::test_translate_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337302" name="TestSuite_Point_hpp_521bf514::test_translate_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337333" name="TestSuite_Point_hpp_521bf514::test_translate_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337364" name="TestSuite_Point_hpp_521bf514::test_translate_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337395" name="TestSuite_Point_hpp_521bf514::test_translate_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337426" name="TestSuite_Point_hpp_521bf514::test_translate_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337457" name="TestSuite_Point_hpp_521bf514::test_translate_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://6043370107166337488" name="TestSuite_Point_hpp_521bf514::test_translate_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                     </TestSuite>
                     <TestSuite authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-2625953027498409830" name="TestSuite_Shapes_hpp_b09152df" pass="50" time="0:00:00.002" tool="C++test" total="50">
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975691" name="TestSuite_Shapes_hpp_b09152df::test_Circle_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5041724855373560121" name="TestSuite_Shapes_hpp_b09152df::test_Circle_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975722" name="TestSuite_Shapes_hpp_b09152df::test_Circle_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975753" name="TestSuite_Shapes_hpp_b09152df::test_Circle_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975784" name="TestSuite_Shapes_hpp_b09152df::test_Circle_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975815" name="TestSuite_Shapes_hpp_b09152df::test_Circle_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975846" name="TestSuite_Shapes_hpp_b09152df::test_Circle_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975877" name="TestSuite_Shapes_hpp_b09152df::test_Circle_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975908" name="TestSuite_Shapes_hpp_b09152df::test_Circle_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7331222423717975939" name="TestSuite_Shapes_hpp_b09152df::test_Circle_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364028" name="TestSuite_Shapes_hpp_b09152df::test_contains_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://3627555596457046952" name="TestSuite_Shapes_hpp_b09152df::test_contains_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364059" name="TestSuite_Shapes_hpp_b09152df::test_contains_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364090" name="TestSuite_Shapes_hpp_b09152df::test_contains_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364121" name="TestSuite_Shapes_hpp_b09152df::test_contains_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364152" name="TestSuite_Shapes_hpp_b09152df::test_contains_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364183" name="TestSuite_Shapes_hpp_b09152df::test_contains_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364214" name="TestSuite_Shapes_hpp_b09152df::test_contains_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364245" name="TestSuite_Shapes_hpp_b09152df::test_contains_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7880660320969364276" name="TestSuite_Shapes_hpp_b09152df::test_contains_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176306" name="TestSuite_Shapes_hpp_b09152df::test_getArea_1" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985650" name="TestSuite_Shapes_hpp_b09152df::test_getArea_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985681" name="TestSuite_Shapes_hpp_b09152df::test_getArea_11" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985712" name="TestSuite_Shapes_hpp_b09152df::test_getArea_12" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985743" name="TestSuite_Shapes_hpp_b09152df::test_getArea_13" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985774" name="TestSuite_Shapes_hpp_b09152df::test_getArea_14" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985805" name="TestSuite_Shapes_hpp_b09152df::test_getArea_15" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985836" name="TestSuite_Shapes_hpp_b09152df::test_getArea_16" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985867" name="TestSuite_Shapes_hpp_b09152df::test_getArea_17" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985898" name="TestSuite_Shapes_hpp_b09152df::test_getArea_18" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058985929" name="TestSuite_Shapes_hpp_b09152df::test_getArea_19" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176337" name="TestSuite_Shapes_hpp_b09152df::test_getArea_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://7883678167058986611" name="TestSuite_Shapes_hpp_b09152df::test_getArea_20" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176368" name="TestSuite_Shapes_hpp_b09152df::test_getArea_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176399" name="TestSuite_Shapes_hpp_b09152df::test_getArea_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176430" name="TestSuite_Shapes_hpp_b09152df::test_getArea_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176461" name="TestSuite_Shapes_hpp_b09152df::test_getArea_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176492" name="TestSuite_Shapes_hpp_b09152df::test_getArea_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176523" name="TestSuite_Shapes_hpp_b09152df::test_getArea_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://5042673295229176554" name="TestSuite_Shapes_hpp_b09152df::test_getArea_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153418" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_1" pass="1" time="0:00:00.001" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://1539368522866038446" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_10" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153387" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_2" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153356" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_3" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153325" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_4" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153294" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_5" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153263" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_6" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153232" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_7" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153201" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_8" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                        <Test authChange="0;" authFail="0;" change="0" changePass="0" changeTotal="0" fail="0" id="CPP://-4087825761217153170" name="TestSuite_Shapes_hpp_b09152df::test_LineSegment_9" pass="1" time="0:00:00.000" tool="C++test" total="1"/>
                     </TestSuite>
                  </TestSuite>
               </TestSuite>
            </Project>
         </Total>
      </ExecutedTestsDetails>
   
   <Scope>
      <ProjectInformations>
         <ScopeProjectInfo fltFiles="12" fltLns="5871" project="/FlowAnalysisCpp" totFiles="12" totLns="5871"/>
      </ProjectInformations>
   </Scope>
   <CodingStandards ownerId="com.parasoft.xtest.checkers.api.standards" time="0:00:38">
      <Projects>
         <Project bdCheckedFiles="4" bdTotalFiles="4" checkedFiles="6" checkedLns="245" name="FlowAnalysisCpp" qfixErrs="0" suppErrs="0" totErrs="1781" totFiles="6" totLns="245"/>
      </Projects>
      <TestingProcessProblems>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;OWASP Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="OWASP2017-A1-a, OWASP2017-A1-b, OWASP2017-A1-c, OWASP2017-A1-d, OWASP2017-A1-e, OWASP2017-A1-f, OWASP2017-A10-a, OWASP2017-A2-a, OWASP2017-A3-a, OWASP2017-A4-a, OWASP2017-A5-a, OWASP2017-A5-b, OWASP2017-A5-c, OWASP2017-A6-a, OWASP2017-A6-b, OWASP2017-A6-c, OWASP2019-API10-a, OWASP2019-API10-b, OWASP2019-API2-a, OWASP2019-API3-a, OWASP2019-API3-b, OWASP2019-API3-c, OWASP2019-API3-d, OWASP2019-API3-e, OWASP2019-API3-f, OWASP2019-API3-g, OWASP2019-API3-h, OWASP2019-API3-i, OWASP2019-API3-j, OWASP2019-API3-k, OWASP2019-API3-l, OWASP2019-API3-m, OWASP2019-API3-n, OWASP2019-API3-o, OWASP2019-API3-p, OWASP2019-API3-q, OWASP2019-API4-a, OWASP2019-API4-b, OWASP2019-API7-a, OWASP2019-API7-b, OWASP2019-API7-c, OWASP2019-API8-a, OWASP2019-API8-b, OWASP2019-API8-c, OWASP2019-API8-d, OWASP2019-API8-e, OWASP2019-API8-f, OWASP2019-API8-g, OWASP2019-API8-h, OWASP2019-API8-i, OWASP2019-API8-j, OWASP2019-API9-a, OWASP2019-API9-b, OWASP2019-API9-c, OWASP2019-API9-d, OWASP2019-API9-e, OWASP2019-API9-f, OWASP2019-API9-g, OWASP2021-A1-a, OWASP2021-A1-b, OWASP2021-A1-c, OWASP2021-A2-a, OWASP2021-A3-a, OWASP2021-A3-b, OWASP2021-A3-c, OWASP2021-A3-d, OWASP2021-A3-e, OWASP2021-A3-f, OWASP2021-A4-a, OWASP2021-A5-a, OWASP2021-A5-b, OWASP2021-A5-c, OWASP2021-A5-d, OWASP2021-A7-a, OWASP2021-A8-a, OWASP2021-A9-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;MISRA C++ 2023 Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="MISRACPP2023-0_0_1-a, MISRACPP2023-0_0_1-b, MISRACPP2023-0_0_1-c, MISRACPP2023-0_0_1-d, MISRACPP2023-0_0_1-e, MISRACPP2023-0_0_1-f, MISRACPP2023-0_0_1-g, MISRACPP2023-0_0_1-h, MISRACPP2023-0_0_1-i, MISRACPP2023-0_0_1-j, MISRACPP2023-0_0_2-a, MISRACPP2023-0_1_1-a, MISRACPP2023-0_1_2-a, MISRACPP2023-0_2_1-a, MISRACPP2023-0_2_1-b, MISRACPP2023-0_2_2-a, MISRACPP2023-0_2_2-b, MISRACPP2023-0_2_3-a, MISRACPP2023-0_2_3-b, MISRACPP2023-0_2_4-a, MISRACPP2023-0_3_1-a, MISRACPP2023-0_3_1-b, MISRACPP2023-0_3_1-c, MISRACPP2023-0_3_1-d, MISRACPP2023-0_3_2-a, MISRACPP2023-10_0_1-a, MISRACPP2023-10_1_1-a, MISRACPP2023-10_1_1-b, MISRACPP2023-10_1_1-c, MISRACPP2023-10_1_2-a, MISRACPP2023-10_2_1-a, MISRACPP2023-10_2_1-b, MISRACPP2023-10_2_2-a, MISRACPP2023-10_2_3-a, MISRACPP2023-10_3_1-a, MISRACPP2023-10_4_1-a, MISRACPP2023-11_3_1-a, MISRACPP2023-11_3_2-a, MISRACPP2023-11_6_1-a, MISRACPP2023-11_6_2-a, MISRACPP2023-11_6_3-a, MISRACPP2023-12_2_1-a, MISRACPP2023-12_2_2-a, MISRACPP2023-12_2_2-b, MISRACPP2023-12_2_3-a, MISRACPP2023-12_3_1-a, MISRACPP2023-13_1_1-a, MISRACPP2023-13_1_2-a, MISRACPP2023-13_3_1-a, MISRACPP2023-13_3_1-b, MISRACPP2023-13_3_2-a, MISRACPP2023-13_3_3-a, MISRACPP2023-13_3_3-b, MISRACPP2023-13_3_4-a, MISRACPP2023-14_1_1-a, MISRACPP2023-15_0_1-a, MISRACPP2023-15_0_1-b, MISRACPP2023-15_0_2-a, MISRACPP2023-15_1_1-a, MISRACPP2023-15_1_1-b, MISRACPP2023-15_1_2-a, MISRACPP2023-15_1_3-a, MISRACPP2023-15_1_3-b, MISRACPP2023-15_1_4-a, MISRACPP2023-15_1_4-b, MISRACPP2023-15_1_5-a, MISRACPP2023-15_8_1-a, MISRACPP2023-16_5_1-a, MISRACPP2023-16_5_2-a, MISRACPP2023-16_6_1-a, MISRACPP2023-17_8_1-a, MISRACPP2023-18_1_1-a, MISRACPP2023-18_1_2-a, MISRACPP2023-18_2_2-a, MISRACPP2023-18_3_1-a, MISRACPP2023-18_3_2-a, MISRACPP2023-18_3_3-a, MISRACPP2023-18_4_1-a, MISRACPP2023-18_4_1-b, MISRACPP2023-18_5_1-a, MISRACPP2023-18_5_2-a, MISRACPP2023-18_5_2-b, MISRACPP2023-18_5_2-c, MISRACPP2023-19_0_1-a, MISRACPP2023-19_0_2-a, MISRACPP2023-19_0_3-a, MISRACPP2023-19_0_4-a, MISRACPP2023-19_1_1-a, MISRACPP2023-19_1_2-a, MISRACPP2023-19_1_3-a, MISRACPP2023-19_2_1-a, MISRACPP2023-19_2_2-a, MISRACPP2023-19_2_3-a, MISRACPP2023-19_3_1-a, MISRACPP2023-19_3_2-a, MISRACPP2023-19_3_3-a, MISRACPP2023-19_3_4-a, MISRACPP2023-19_3_5-a, MISRACPP2023-19_6_1-a, MISRACPP2023-19_6_1-b, MISRACPP2023-21_10_1-a, MISRACPP2023-21_10_2-a, MISRACPP2023-21_10_2-b, MISRACPP2023-21_10_3-a, MISRACPP2023-21_2_1-a, MISRACPP2023-21_2_3-a, MISRACPP2023-21_2_4-a, MISRACPP2023-21_6_1-a, MISRACPP2023-21_6_2-a, MISRACPP2023-21_6_2-b, MISRACPP2023-21_6_2-c, MISRACPP2023-21_6_3-a, MISRACPP2023-21_6_3-b, MISRACPP2023-21_6_3-c, MISRACPP2023-21_6_3-d, MISRACPP2023-21_6_4-a, MISRACPP2023-21_6_5-a, MISRACPP2023-22_3_1-a, MISRACPP2023-22_4_1-a, MISRACPP2023-23_11_1-a, MISRACPP2023-24_5_1-a, MISRACPP2023-24_5_2-a, MISRACPP2023-25_5_1-a, MISRACPP2023-25_5_1-b, MISRACPP2023-25_5_2-a, MISRACPP2023-25_5_2-b, MISRACPP2023-25_5_2-c, MISRACPP2023-25_5_3-a, MISRACPP2023-26_3_1-a, MISRACPP2023-28_3_1-a, MISRACPP2023-28_6_1-a, MISRACPP2023-28_6_2-a, MISRACPP2023-28_6_2-b, MISRACPP2023-28_6_3-a, MISRACPP2023-28_6_3-b, MISRACPP2023-28_6_4-a, MISRACPP2023-30_0_1-a, MISRACPP2023-30_0_1-b, MISRACPP2023-30_0_2-a, MISRACPP2023-4_1_2-a, MISRACPP2023-4_1_2-b, MISRACPP2023-4_1_2-c, MISRACPP2023-4_1_2-d, MISRACPP2023-4_1_3-a, MISRACPP2023-4_1_3-b, MISRACPP2023-4_1_3-c, MISRACPP2023-4_1_3-d, MISRACPP2023-4_6_1-a, MISRACPP2023-4_6_1-b, MISRACPP2023-4_6_1-c, MISRACPP2023-4_6_1-d, MISRACPP2023-4_6_1-e, MISRACPP2023-4_6_1-f, MISRACPP2023-4_6_1-g, MISRACPP2023-5_0_1-a, MISRACPP2023-5_10_1-a, MISRACPP2023-5_10_1-b, MISRACPP2023-5_10_1-c, MISRACPP2023-5_10_1-d, MISRACPP2023-5_10_1-e, MISRACPP2023-5_10_1-f, MISRACPP2023-5_10_1-g, MISRACPP2023-5_13_1-a, MISRACPP2023-5_13_2-a, MISRACPP2023-5_13_3-a, MISRACPP2023-5_13_4-a, MISRACPP2023-5_13_5-a, MISRACPP2023-5_13_6-a, MISRACPP2023-5_13_7-a, MISRACPP2023-5_13_7-b, MISRACPP2023-5_7_1-a, MISRACPP2023-5_7_2-a, MISRACPP2023-5_7_3-a, MISRACPP2023-6_0_1-a, MISRACPP2023-6_0_1-b, MISRACPP2023-6_0_1-c, MISRACPP2023-6_0_2-a, MISRACPP2023-6_0_3-a, MISRACPP2023-6_0_4-a, MISRACPP2023-6_2_1-a, MISRACPP2023-6_2_2-a, MISRACPP2023-6_2_2-b, MISRACPP2023-6_2_3-a, MISRACPP2023-6_2_3-b, MISRACPP2023-6_2_3-c, MISRACPP2023-6_2_3-d, MISRACPP2023-6_2_4-a, MISRACPP2023-6_4_1-a, MISRACPP2023-6_4_1-b, MISRACPP2023-6_4_1-c, MISRACPP2023-6_4_1-d, MISRACPP2023-6_4_1-e, MISRACPP2023-6_4_1-f, MISRACPP2023-6_4_2-a, MISRACPP2023-6_4_2-b, MISRACPP2023-6_4_3-a, MISRACPP2023-6_5_1-a, MISRACPP2023-6_5_2-a, MISRACPP2023-6_5_2-b, MISRACPP2023-6_7_1-a, MISRACPP2023-6_7_2-a, MISRACPP2023-6_8_1-a, MISRACPP2023-6_8_1-b, MISRACPP2023-6_8_1-c, MISRACPP2023-6_8_2-a, MISRACPP2023-6_8_2-b, MISRACPP2023-6_8_3-a, MISRACPP2023-6_8_4-a, MISRACPP2023-6_9_1-a, MISRACPP2023-6_9_2-a, MISRACPP2023-7_0_1-a, MISRACPP2023-7_0_2-a, MISRACPP2023-7_0_3-a, MISRACPP2023-7_0_3-b, MISRACPP2023-7_0_4-a, MISRACPP2023-7_0_4-b, MISRACPP2023-7_0_5-a, MISRACPP2023-7_0_6-a, MISRACPP2023-7_11_1-a, MISRACPP2023-7_11_1-b, MISRACPP2023-7_11_2-a, MISRACPP2023-7_11_3-a, MISRACPP2023-8_0_1-a, MISRACPP2023-8_0_1-b, MISRACPP2023-8_14_1-a, MISRACPP2023-8_18_1-a, MISRACPP2023-8_18_1-b, MISRACPP2023-8_18_1-c, MISRACPP2023-8_18_2-a, MISRACPP2023-8_19_1-a, MISRACPP2023-8_1_1-a, MISRACPP2023-8_1_2-a, MISRACPP2023-8_20_1-a, MISRACPP2023-8_20_1-b, MISRACPP2023-8_2_1-a, MISRACPP2023-8_2_10-a, MISRACPP2023-8_2_11-a, MISRACPP2023-8_2_2-a, MISRACPP2023-8_2_3-a, MISRACPP2023-8_2_4-a, MISRACPP2023-8_2_5-a, MISRACPP2023-8_2_6-a, MISRACPP2023-8_2_6-b, MISRACPP2023-8_2_7-a, MISRACPP2023-8_2_7-b, MISRACPP2023-8_2_8-a, MISRACPP2023-8_2_9-a, MISRACPP2023-8_3_1-a, MISRACPP2023-8_3_2-a, MISRACPP2023-8_7_1-a, MISRACPP2023-8_7_1-b, MISRACPP2023-8_7_1-c, MISRACPP2023-8_7_1-d, MISRACPP2023-8_7_1-e, MISRACPP2023-8_7_2-a, MISRACPP2023-8_9_1-a, MISRACPP2023-9_2_1-a, MISRACPP2023-9_3_1-a, MISRACPP2023-9_3_1-b, MISRACPP2023-9_4_1-a, MISRACPP2023-9_4_2-a, MISRACPP2023-9_4_2-b, MISRACPP2023-9_4_2-c, MISRACPP2023-9_4_2-d, MISRACPP2023-9_4_2-e, MISRACPP2023-9_4_2-f, MISRACPP2023-9_4_2-g, MISRACPP2023-9_5_1-a, MISRACPP2023-9_5_2-a, MISRACPP2023-9_6_1-a, MISRACPP2023-9_6_2-a, MISRACPP2023-9_6_3-a, MISRACPP2023-9_6_4-a, MISRACPP2023-9_6_5-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;AUTOSAR Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="AUTOSAR-A0_1_1-a, AUTOSAR-A0_1_2-a, AUTOSAR-A0_1_3-a, AUTOSAR-A0_1_4-a, AUTOSAR-A0_1_5-a, AUTOSAR-A0_1_6-a, AUTOSAR-A0_4_2-a, AUTOSAR-A0_4_4-a, AUTOSAR-A10_1_1-a, AUTOSAR-A10_2_1-a, AUTOSAR-A10_2_1-b, AUTOSAR-A10_3_1-a, AUTOSAR-A10_3_2-a, AUTOSAR-A10_3_3-a, AUTOSAR-A10_3_5-a, AUTOSAR-A10_4_1-a, AUTOSAR-A11_0_1-a, AUTOSAR-A11_0_2-a, AUTOSAR-A11_3_1-a, AUTOSAR-A12_0_1-a, AUTOSAR-A12_0_2-a, AUTOSAR-A12_1_1-a, AUTOSAR-A12_1_1-b, AUTOSAR-A12_1_2-a, AUTOSAR-A12_1_3-a, AUTOSAR-A12_1_4-a, AUTOSAR-A12_1_5-a, AUTOSAR-A12_1_6-a, AUTOSAR-A12_4_1-a, AUTOSAR-A12_4_2-a, AUTOSAR-A12_6_1-a, AUTOSAR-A12_7_1-a, AUTOSAR-A12_8_1-a, AUTOSAR-A12_8_2-a, AUTOSAR-A12_8_3-a, AUTOSAR-A12_8_4-a, AUTOSAR-A12_8_5-a, AUTOSAR-A12_8_6-a, AUTOSAR-A12_8_7-a, AUTOSAR-A13_1_2-a, AUTOSAR-A13_1_3-a, AUTOSAR-A13_2_1-a, AUTOSAR-A13_2_2-a, AUTOSAR-A13_2_3-a, AUTOSAR-A13_3_1-a, AUTOSAR-A13_5_1-a, AUTOSAR-A13_5_2-a, AUTOSAR-A13_5_3-a, AUTOSAR-A13_5_4-b, AUTOSAR-A13_5_5-a, AUTOSAR-A13_5_5-b, AUTOSAR-A13_6_1-a, AUTOSAR-A14_5_1-a, AUTOSAR-A14_5_3-a, AUTOSAR-A14_7_2-a, AUTOSAR-A14_8_2-a, AUTOSAR-A15_0_2-a, AUTOSAR-A15_1_1-a, AUTOSAR-A15_1_2-a, AUTOSAR-A15_1_4-a, AUTOSAR-A15_1_5-a, AUTOSAR-A15_2_1-a, AUTOSAR-A15_2_1-b, AUTOSAR-A15_3_2-a, AUTOSAR-A15_3_3-a, AUTOSAR-A15_3_4-a, AUTOSAR-A15_3_5-a, AUTOSAR-A15_4_1-a, AUTOSAR-A15_4_2-a, AUTOSAR-A15_4_3-a, AUTOSAR-A15_4_4-a, AUTOSAR-A15_4_5-a, AUTOSAR-A15_5_1-a, AUTOSAR-A15_5_1-b, AUTOSAR-A15_5_2-a, AUTOSAR-A15_5_2-b, AUTOSAR-A15_5_2-c, AUTOSAR-A15_5_3-a, AUTOSAR-A15_5_3-b, AUTOSAR-A15_5_3-c, AUTOSAR-A15_5_3-d, AUTOSAR-A15_5_3-e, AUTOSAR-A15_5_3-f, AUTOSAR-A15_5_3-g, AUTOSAR-A15_5_3-h, AUTOSAR-A15_5_3-i, AUTOSAR-A15_5_3-j, AUTOSAR-A15_5_3-k, AUTOSAR-A16_0_1-a, AUTOSAR-A16_0_1-b, AUTOSAR-A16_0_1-c, AUTOSAR-A16_0_1-d, AUTOSAR-A16_0_1-e, AUTOSAR-A16_2_1-a, AUTOSAR-A16_2_2-a, AUTOSAR-A16_6_1-a, AUTOSAR-A16_7_1-a, AUTOSAR-A17_0_1-a, AUTOSAR-A17_0_1-b, AUTOSAR-A17_0_1-c, AUTOSAR-A17_0_1-d, AUTOSAR-A17_0_1-e, AUTOSAR-A17_1_1-a, AUTOSAR-A17_6_1-a, AUTOSAR-A18_0_1-a, AUTOSAR-A18_0_2-a, AUTOSAR-A18_0_2-b, AUTOSAR-A18_0_3-a, AUTOSAR-A18_0_3-b, AUTOSAR-A18_1_1-a, AUTOSAR-A18_1_2-a, AUTOSAR-A18_1_3-a, AUTOSAR-A18_1_4-a, AUTOSAR-A18_1_6-a, AUTOSAR-A18_5_1-a, AUTOSAR-A18_5_10-a, AUTOSAR-A18_5_10-b, AUTOSAR-A18_5_11-a, AUTOSAR-A18_5_11-b, AUTOSAR-A18_5_2-a, AUTOSAR-A18_5_3-a, AUTOSAR-A18_5_3-b, AUTOSAR-A18_5_3-c, AUTOSAR-A18_5_4-a, AUTOSAR-A18_5_5-a, AUTOSAR-A18_5_5-b, AUTOSAR-A18_5_5-c, AUTOSAR-A18_5_8-a, AUTOSAR-A18_5_9-a, AUTOSAR-A18_9_1-a, AUTOSAR-A18_9_2-a, AUTOSAR-A18_9_2-b, AUTOSAR-A18_9_3-a, AUTOSAR-A18_9_4-a, AUTOSAR-A1_1_1-a, AUTOSAR-A1_1_1-b, AUTOSAR-A1_1_1-c, AUTOSAR-A1_1_1-d, AUTOSAR-A1_1_1-e, AUTOSAR-A1_1_1-f, AUTOSAR-A1_1_1-g, AUTOSAR-A1_1_1-h, AUTOSAR-A1_1_1-i, AUTOSAR-A1_1_1-j, AUTOSAR-A1_1_1-k, AUTOSAR-A20_8_1-a, AUTOSAR-A20_8_2-a, AUTOSAR-A20_8_3-a, AUTOSAR-A20_8_4-a, AUTOSAR-A20_8_5-a, AUTOSAR-A20_8_6-a, AUTOSAR-A20_8_7-a, AUTOSAR-A21_8_1-a, AUTOSAR-A23_0_1-a, AUTOSAR-A23_0_2-a, AUTOSAR-A23_0_2-b, AUTOSAR-A25_1_1-a, AUTOSAR-A25_4_1-a, AUTOSAR-A26_5_1-a, AUTOSAR-A26_5_2-a, AUTOSAR-A27_0_1-a, AUTOSAR-A27_0_1-b, AUTOSAR-A27_0_1-c, AUTOSAR-A27_0_1-d, AUTOSAR-A27_0_1-e, AUTOSAR-A27_0_1-f, AUTOSAR-A27_0_1-g, AUTOSAR-A27_0_1-h, AUTOSAR-A27_0_2-a, AUTOSAR-A27_0_2-b, AUTOSAR-A27_0_2-c, AUTOSAR-A27_0_2-e, AUTOSAR-A27_0_2-f, AUTOSAR-A27_0_3-a, AUTOSAR-A27_0_4-a, AUTOSAR-A27_0_4-b, AUTOSAR-A27_0_4-c, AUTOSAR-A27_0_4-d, AUTOSAR-A27_0_4-e, AUTOSAR-A2_10_1-a, AUTOSAR-A2_10_1-b, AUTOSAR-A2_10_1-c, AUTOSAR-A2_10_1-d, AUTOSAR-A2_10_1-e, AUTOSAR-A2_10_4-a, AUTOSAR-A2_10_4-b, AUTOSAR-A2_10_5-a, AUTOSAR-A2_10_5-b, AUTOSAR-A2_10_5-c, AUTOSAR-A2_10_5-d, AUTOSAR-A2_10_6-a, AUTOSAR-A2_10_6-b, AUTOSAR-A2_10_6-c, AUTOSAR-A2_11_1-a, AUTOSAR-A2_13_1-a, AUTOSAR-A2_13_2-a, AUTOSAR-A2_13_3-a, AUTOSAR-A2_13_4-a, AUTOSAR-A2_13_5-a, AUTOSAR-A2_13_6-a, AUTOSAR-A2_3_1-a, AUTOSAR-A2_5_1-a, AUTOSAR-A2_5_1-b, AUTOSAR-A2_5_2-a, AUTOSAR-A2_7_1-a, AUTOSAR-A2_7_2-a, AUTOSAR-A2_7_3-a, AUTOSAR-A2_7_3-b, AUTOSAR-A2_8_1-a, AUTOSAR-A3_1_1-a, AUTOSAR-A3_1_2-a, AUTOSAR-A3_1_3-a, AUTOSAR-A3_1_4-a, AUTOSAR-A3_1_5-a, AUTOSAR-A3_1_6-a, AUTOSAR-A3_3_1-a, AUTOSAR-A3_3_1-b, AUTOSAR-A3_3_2-a, AUTOSAR-A3_8_1-a, AUTOSAR-A3_8_1-b, AUTOSAR-A3_8_1-c, AUTOSAR-A3_8_1-d, AUTOSAR-A3_9_1-b, AUTOSAR-A3_9_1-c, AUTOSAR-A4_10_1-a, AUTOSAR-A4_10_1-b, AUTOSAR-A4_5_1-a, AUTOSAR-A4_7_1-a, AUTOSAR-A4_7_1-b, AUTOSAR-A4_7_1-c, AUTOSAR-A4_7_1-d, AUTOSAR-A4_7_1-e, AUTOSAR-A4_7_1-f, AUTOSAR-A4_7_1-g, AUTOSAR-A4_7_1-h, AUTOSAR-A4_7_1-i, AUTOSAR-A4_7_1-j, AUTOSAR-A4_7_1-k, AUTOSAR-A5_0_1-a, AUTOSAR-A5_0_1-b, AUTOSAR-A5_0_1-c, AUTOSAR-A5_0_1-d, AUTOSAR-A5_0_1-e, AUTOSAR-A5_0_1-f, AUTOSAR-A5_0_1-g, AUTOSAR-A5_0_2-a, AUTOSAR-A5_0_3-a, AUTOSAR-A5_0_4-a, AUTOSAR-A5_0_4-b, AUTOSAR-A5_0_4-c, AUTOSAR-A5_10_1-a, AUTOSAR-A5_16_1-a, AUTOSAR-A5_1_1-a, AUTOSAR-A5_1_2-a, AUTOSAR-A5_1_3-a, AUTOSAR-A5_1_4-a, AUTOSAR-A5_1_4-b, AUTOSAR-A5_1_4-c, AUTOSAR-A5_1_6-a, AUTOSAR-A5_1_7-a, AUTOSAR-A5_1_8-a, AUTOSAR-A5_2_1-a, AUTOSAR-A5_2_2-a, AUTOSAR-A5_2_3-a, AUTOSAR-A5_2_4-a, AUTOSAR-A5_2_5-a, AUTOSAR-A5_2_5-b, AUTOSAR-A5_2_5-c, AUTOSAR-A5_2_5-d, AUTOSAR-A5_2_6-a, AUTOSAR-A5_3_1-a, AUTOSAR-A5_3_1-b, AUTOSAR-A5_3_2-a, AUTOSAR-A5_3_3-a, AUTOSAR-A5_5_1-a, AUTOSAR-A5_6_1-a, AUTOSAR-A6_2_1-a, AUTOSAR-A6_2_1-b, AUTOSAR-A6_2_2-a, AUTOSAR-A6_4_1-a, AUTOSAR-A6_5_1-a, AUTOSAR-A6_5_2-a, AUTOSAR-A6_5_3-a, AUTOSAR-A6_5_4-a, AUTOSAR-A6_5_4-b, AUTOSAR-A6_6_1-a, AUTOSAR-A7_1_1-a, AUTOSAR-A7_1_1-b, AUTOSAR-A7_1_2-a, AUTOSAR-A7_1_2-b, AUTOSAR-A7_1_3-a, AUTOSAR-A7_1_4-a, AUTOSAR-A7_1_5-a, AUTOSAR-A7_1_6-a, AUTOSAR-A7_1_7-a, AUTOSAR-A7_1_7-b, AUTOSAR-A7_1_7-c, AUTOSAR-A7_1_8-a, AUTOSAR-A7_1_9-a, AUTOSAR-A7_2_1-a, AUTOSAR-A7_2_2-a, AUTOSAR-A7_2_3-a, AUTOSAR-A7_2_4-a, AUTOSAR-A7_2_5-a, AUTOSAR-A7_3_1-a, AUTOSAR-A7_4_1-a, AUTOSAR-A7_5_1-a, AUTOSAR-A7_5_2-a, AUTOSAR-A7_6_1-a, AUTOSAR-A8_2_1-a, AUTOSAR-A8_4_1-a, AUTOSAR-A8_4_10-a, AUTOSAR-A8_4_11-a, AUTOSAR-A8_4_12-a, AUTOSAR-A8_4_12-b, AUTOSAR-A8_4_12-c, AUTOSAR-A8_4_12-d, AUTOSAR-A8_4_13-a, AUTOSAR-A8_4_13-b, AUTOSAR-A8_4_13-c, AUTOSAR-A8_4_2-a, AUTOSAR-A8_4_3-a, AUTOSAR-A8_4_3-b, AUTOSAR-A8_4_4-a, AUTOSAR-A8_4_5-a, AUTOSAR-A8_4_6-a, AUTOSAR-A8_4_7-a, AUTOSAR-A8_4_8-a, AUTOSAR-A8_4_9-a, AUTOSAR-A8_5_0-a, AUTOSAR-A8_5_1-a, AUTOSAR-A8_5_2-a, AUTOSAR-A8_5_3-a, AUTOSAR-A8_5_4-a, AUTOSAR-A9_3_1-a, AUTOSAR-A9_3_1-b, AUTOSAR-A9_5_1-a, AUTOSAR-A9_5_1-b, AUTOSAR-A9_6_1-a, AUTOSAR-A9_6_2-a, AUTOSAR-M0_1_1-a, AUTOSAR-M0_1_1-b, AUTOSAR-M0_1_1-c, AUTOSAR-M0_1_1-d, AUTOSAR-M0_1_1-e, AUTOSAR-M0_1_1-f, AUTOSAR-M0_1_1-g, AUTOSAR-M0_1_10-a, AUTOSAR-M0_1_10-b, AUTOSAR-M0_1_2-a, AUTOSAR-M0_1_2-aa, AUTOSAR-M0_1_2-ab, AUTOSAR-M0_1_2-ac, AUTOSAR-M0_1_2-b, AUTOSAR-M0_1_2-c, AUTOSAR-M0_1_2-d, AUTOSAR-M0_1_2-e, AUTOSAR-M0_1_2-f, AUTOSAR-M0_1_2-g, AUTOSAR-M0_1_2-h, AUTOSAR-M0_1_2-i, AUTOSAR-M0_1_2-j, AUTOSAR-M0_1_2-k, AUTOSAR-M0_1_2-l, AUTOSAR-M0_1_2-m, AUTOSAR-M0_1_2-n, AUTOSAR-M0_1_2-o, AUTOSAR-M0_1_2-p, AUTOSAR-M0_1_2-q, AUTOSAR-M0_1_2-r, AUTOSAR-M0_1_2-s, AUTOSAR-M0_1_2-t, AUTOSAR-M0_1_2-u, AUTOSAR-M0_1_2-v, AUTOSAR-M0_1_2-w, AUTOSAR-M0_1_2-x, AUTOSAR-M0_1_2-y, AUTOSAR-M0_1_2-z, AUTOSAR-M0_1_3-a, AUTOSAR-M0_1_3-c, AUTOSAR-M0_1_3-d, AUTOSAR-M0_1_3-e, AUTOSAR-M0_1_4-a, AUTOSAR-M0_1_8-a, AUTOSAR-M0_1_8-b, AUTOSAR-M0_1_9-a, AUTOSAR-M0_2_1-a, AUTOSAR-M0_2_1-b, AUTOSAR-M0_3_1-a, AUTOSAR-M0_3_1-b, AUTOSAR-M0_3_1-c, AUTOSAR-M0_3_1-d, AUTOSAR-M0_3_1-e, AUTOSAR-M0_3_1-f, AUTOSAR-M0_3_1-g, AUTOSAR-M0_3_1-h, AUTOSAR-M0_3_1-i, AUTOSAR-M0_3_1-j, AUTOSAR-M0_3_2-a, AUTOSAR-M0_4_2-a, AUTOSAR-M10_1_1-a, AUTOSAR-M10_1_2-a, AUTOSAR-M10_1_3-a, AUTOSAR-M10_2_1-a, AUTOSAR-M10_3_3-a, AUTOSAR-M11_0_1-a, AUTOSAR-M12_1_1-a, AUTOSAR-M12_1_1-b, AUTOSAR-M14_5_3-a, AUTOSAR-M14_6_1-a, AUTOSAR-M15_0_3-a, AUTOSAR-M15_1_1-a, AUTOSAR-M15_1_2-a, AUTOSAR-M15_1_3-a, AUTOSAR-M15_3_1-a, AUTOSAR-M15_3_3-a, AUTOSAR-M15_3_4-a, AUTOSAR-M15_3_4-b, AUTOSAR-M15_3_6-a, AUTOSAR-M15_3_7-a, AUTOSAR-M16_0_1-a, AUTOSAR-M16_0_2-a, AUTOSAR-M16_0_5-a, AUTOSAR-M16_0_6-a, AUTOSAR-M16_0_7-a, AUTOSAR-M16_0_8-a, AUTOSAR-M16_1_1-a, AUTOSAR-M16_1_2-a, AUTOSAR-M16_2_3-a, AUTOSAR-M16_3_1-a, AUTOSAR-M16_3_2-a, AUTOSAR-M17_0_2-a, AUTOSAR-M17_0_3-a, AUTOSAR-M17_0_5-a, AUTOSAR-M17_0_5-b, AUTOSAR-M18_0_3-a, AUTOSAR-M18_0_3-b, AUTOSAR-M18_0_3-c, AUTOSAR-M18_0_3-d, AUTOSAR-M18_0_4-a, AUTOSAR-M18_0_4-b, AUTOSAR-M18_0_4-c, AUTOSAR-M18_0_5-a, AUTOSAR-M18_2_1-a, AUTOSAR-M18_7_1-a, AUTOSAR-M18_7_1-b, AUTOSAR-M19_3_1-a, AUTOSAR-M27_0_1-a, AUTOSAR-M2_10_1-a, AUTOSAR-M2_13_2-a, AUTOSAR-M2_13_2-b, AUTOSAR-M2_13_3-a, AUTOSAR-M2_13_4-a, AUTOSAR-M2_7_1-a, AUTOSAR-M3_1_2-a, AUTOSAR-M3_2_1-a, AUTOSAR-M3_2_2-a, AUTOSAR-M3_2_3-a, AUTOSAR-M3_2_4-a, AUTOSAR-M3_2_4-b, AUTOSAR-M3_3_2-a, AUTOSAR-M3_4_1-a, AUTOSAR-M3_4_1-b, AUTOSAR-M3_9_1-a, AUTOSAR-M3_9_3-a, AUTOSAR-M4_10_1-a, AUTOSAR-M4_10_2-a, AUTOSAR-M4_5_1-a, AUTOSAR-M4_5_3-a, AUTOSAR-M5_0_10-a, AUTOSAR-M5_0_11-a, AUTOSAR-M5_0_12-a, AUTOSAR-M5_0_14-a, AUTOSAR-M5_0_15-a, AUTOSAR-M5_0_16-a, AUTOSAR-M5_0_16-b, AUTOSAR-M5_0_17-a, AUTOSAR-M5_0_18-a, AUTOSAR-M5_0_2-a, AUTOSAR-M5_0_2-b, AUTOSAR-M5_0_2-c, AUTOSAR-M5_0_2-d, AUTOSAR-M5_0_2-e, AUTOSAR-M5_0_2-f, AUTOSAR-M5_0_20-a, AUTOSAR-M5_0_21-a, AUTOSAR-M5_0_3-a, AUTOSAR-M5_0_3-b, AUTOSAR-M5_0_3-c, AUTOSAR-M5_0_4-a, AUTOSAR-M5_0_5-a, AUTOSAR-M5_0_5-b, AUTOSAR-M5_0_6-a, AUTOSAR-M5_0_6-b, AUTOSAR-M5_0_6-c, AUTOSAR-M5_0_7-a, AUTOSAR-M5_0_7-b, AUTOSAR-M5_0_8-a, AUTOSAR-M5_0_8-b, AUTOSAR-M5_0_9-a, AUTOSAR-M5_14_1-a, AUTOSAR-M5_17_1-a, AUTOSAR-M5_18_1-a, AUTOSAR-M5_19_1-a, AUTOSAR-M5_19_1-b, AUTOSAR-M5_2_10-a, AUTOSAR-M5_2_11-a, AUTOSAR-M5_2_11-b, AUTOSAR-M5_2_12-a, AUTOSAR-M5_2_2-a, AUTOSAR-M5_2_3-a, AUTOSAR-M5_2_6-a, AUTOSAR-M5_2_8-a, AUTOSAR-M5_2_9-a, AUTOSAR-M5_3_1-a, AUTOSAR-M5_3_2-a, AUTOSAR-M5_3_3-a, AUTOSAR-M5_3_4-a, AUTOSAR-M5_3_4-b, AUTOSAR-M5_3_4-c, AUTOSAR-M5_8_1-a, AUTOSAR-M6_2_1-a, AUTOSAR-M6_2_2-a, AUTOSAR-M6_2_3-a, AUTOSAR-M6_3_1-a, AUTOSAR-M6_4_1-a, AUTOSAR-M6_4_2-a, AUTOSAR-M6_4_3-a, AUTOSAR-M6_4_3-b, AUTOSAR-M6_4_3-c, AUTOSAR-M6_4_3-d, AUTOSAR-M6_4_3-e, AUTOSAR-M6_4_4-a, AUTOSAR-M6_4_5-a, AUTOSAR-M6_4_6-a, AUTOSAR-M6_4_7-a, AUTOSAR-M6_5_2-a, AUTOSAR-M6_5_3-a, AUTOSAR-M6_5_4-a, AUTOSAR-M6_5_5-a, AUTOSAR-M6_5_6-a, AUTOSAR-M6_6_1-a, AUTOSAR-M6_6_2-a, AUTOSAR-M6_6_3-a, AUTOSAR-M7_1_2-a, AUTOSAR-M7_1_2-b, AUTOSAR-M7_1_2-c, AUTOSAR-M7_3_1-a, AUTOSAR-M7_3_2-a, AUTOSAR-M7_3_3-a, AUTOSAR-M7_3_4-a, AUTOSAR-M7_3_6-a, AUTOSAR-M7_4_1-a, AUTOSAR-M7_4_2-a, AUTOSAR-M7_4_3-a, AUTOSAR-M7_5_1-a, AUTOSAR-M7_5_2-a, AUTOSAR-M8_0_1-a, AUTOSAR-M8_3_1-a, AUTOSAR-M8_4_2-a, AUTOSAR-M8_4_4-a, AUTOSAR-M8_5_2-a, AUTOSAR-M8_5_2-b, AUTOSAR-M8_5_2-c, AUTOSAR-M9_3_1-a, AUTOSAR-M9_3_3-a, AUTOSAR-M9_6_4-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;SEI CERT C Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="CERT_C-API00-a, CERT_C-API01-a, CERT_C-API01-b, CERT_C-API02-a, CERT_C-API02-b, CERT_C-ARR01-a, CERT_C-ARR02-a, CERT_C-ARR30-a, CERT_C-ARR32-a, CERT_C-ARR36-a, CERT_C-ARR36-b, CERT_C-ARR37-a, CERT_C-ARR38-a, CERT_C-ARR38-b, CERT_C-ARR38-c, CERT_C-ARR38-d, CERT_C-ARR39-a, CERT_C-ARR39-b, CERT_C-ARR39-c, CERT_C-CON01-a, CERT_C-CON02-a, CERT_C-CON05-a, CERT_C-CON30-a, CERT_C-CON31-a, CERT_C-CON31-b, CERT_C-CON31-c, CERT_C-CON32-a, CERT_C-CON33-a, CERT_C-CON34-a, CERT_C-CON35-a, CERT_C-CON36-a, CERT_C-CON37-a, CERT_C-CON38-a, CERT_C-CON39-a, CERT_C-CON40-a, CERT_C-CON41-a, CERT_C-CON43-a, CERT_C-DCL00-a, CERT_C-DCL00-b, CERT_C-DCL01-a, CERT_C-DCL01-b, CERT_C-DCL02-a, CERT_C-DCL04-a, CERT_C-DCL05-a, CERT_C-DCL06-a, CERT_C-DCL10-a, CERT_C-DCL11-a, CERT_C-DCL11-b, CERT_C-DCL11-c, CERT_C-DCL11-d, CERT_C-DCL11-e, CERT_C-DCL11-f, CERT_C-DCL12-a, CERT_C-DCL13-a, CERT_C-DCL15-a, CERT_C-DCL16-a, CERT_C-DCL18-a, CERT_C-DCL18-b, CERT_C-DCL19-a, CERT_C-DCL20-a, CERT_C-DCL22-a, CERT_C-DCL30-a, CERT_C-DCL30-b, CERT_C-DCL31-a, CERT_C-DCL36-a, CERT_C-DCL37-a, CERT_C-DCL38-a, CERT_C-DCL39-a, CERT_C-DCL40-a, CERT_C-DCL40-b, CERT_C-DCL41-a, CERT_C-ENV01-a, CERT_C-ENV01-b, CERT_C-ENV01-c, CERT_C-ENV02-a, CERT_C-ENV30-a, CERT_C-ENV31-a, CERT_C-ENV32-a, CERT_C-ENV33-a, CERT_C-ENV34-a, CERT_C-ERR01-a, CERT_C-ERR02-a, CERT_C-ERR04-a, CERT_C-ERR04-b, CERT_C-ERR04-c, CERT_C-ERR05-a, CERT_C-ERR05-b, CERT_C-ERR05-c, CERT_C-ERR06-a, CERT_C-ERR07-a, CERT_C-ERR07-b, CERT_C-ERR30-a, CERT_C-ERR30-b, CERT_C-ERR32-a, CERT_C-ERR33-a, CERT_C-ERR33-d, CERT_C-ERR34-a, CERT_C-EXP00-a, CERT_C-EXP02-a, CERT_C-EXP05-a, CERT_C-EXP08-a, CERT_C-EXP08-b, CERT_C-EXP10-a, CERT_C-EXP10-b, CERT_C-EXP10-c, CERT_C-EXP10-d, CERT_C-EXP12-a, CERT_C-EXP12-b, CERT_C-EXP14-a, CERT_C-EXP15-a, CERT_C-EXP16-a, CERT_C-EXP19-a, CERT_C-EXP20-a, CERT_C-EXP20-b, CERT_C-EXP30-a, CERT_C-EXP30-b, CERT_C-EXP30-c, CERT_C-EXP30-d, CERT_C-EXP32-a, CERT_C-EXP33-a, CERT_C-EXP34-a, CERT_C-EXP35-a, CERT_C-EXP36-a, CERT_C-EXP37-a, CERT_C-EXP37-b, CERT_C-EXP37-d, CERT_C-EXP39-a, CERT_C-EXP39-b, CERT_C-EXP39-c, CERT_C-EXP39-d, CERT_C-EXP39-e, CERT_C-EXP39-f, CERT_C-EXP40-a, CERT_C-EXP42-a, CERT_C-EXP43-a, CERT_C-EXP44-a, CERT_C-EXP44-b, CERT_C-EXP45-b, CERT_C-EXP45-d, CERT_C-EXP46-b, CERT_C-EXP47-a, CERT_C-FIO01-a, CERT_C-FIO01-b, CERT_C-FIO21-a, CERT_C-FIO22-a, CERT_C-FIO24-a, CERT_C-FIO30-a, CERT_C-FIO30-b, CERT_C-FIO30-c, CERT_C-FIO32-a, CERT_C-FIO34-a, CERT_C-FIO37-a, CERT_C-FIO38-a, CERT_C-FIO39-a, CERT_C-FIO40-a, CERT_C-FIO41-a, CERT_C-FIO41-b, CERT_C-FIO42-a, CERT_C-FIO44-a, CERT_C-FIO45-a, CERT_C-FIO46-a, CERT_C-FIO47-a, CERT_C-FIO47-b, CERT_C-FIO47-c, CERT_C-FIO47-d, CERT_C-FIO47-e, CERT_C-FIO47-f, CERT_C-FLP00-a, CERT_C-FLP02-a, CERT_C-FLP03-a, CERT_C-FLP03-b, CERT_C-FLP03-c, CERT_C-FLP03-d, CERT_C-FLP06-a, CERT_C-FLP06-b, CERT_C-FLP30-a, CERT_C-FLP32-a, CERT_C-FLP34-a, CERT_C-FLP34-b, CERT_C-FLP36-a, CERT_C-FLP36-b, CERT_C-FLP37-c, CERT_C-INT02-a, CERT_C-INT02-b, CERT_C-INT04-a, CERT_C-INT04-b, CERT_C-INT04-c, CERT_C-INT05-a, CERT_C-INT07-a, CERT_C-INT07-b, CERT_C-INT08-a, CERT_C-INT08-b, CERT_C-INT08-c, CERT_C-INT08-d, CERT_C-INT09-a, CERT_C-INT10-a, CERT_C-INT12-a, CERT_C-INT13-a, CERT_C-INT15-a, CERT_C-INT16-a, CERT_C-INT18-a, CERT_C-INT18-b, CERT_C-INT18-c, CERT_C-INT30-a, CERT_C-INT30-b, CERT_C-INT30-c, CERT_C-INT31-a, CERT_C-INT31-b, CERT_C-INT31-c, CERT_C-INT31-d, CERT_C-INT31-e, CERT_C-INT31-f, CERT_C-INT31-g, CERT_C-INT31-h, CERT_C-INT31-i, CERT_C-INT31-j, CERT_C-INT31-k, CERT_C-INT31-l, CERT_C-INT31-m, CERT_C-INT31-n, CERT_C-INT31-o, CERT_C-INT31-p, CERT_C-INT32-a, CERT_C-INT32-b, CERT_C-INT32-c, CERT_C-INT33-a, CERT_C-INT34-a, CERT_C-INT35-a, CERT_C-INT36-b, CERT_C-MEM00-a, CERT_C-MEM00-b, CERT_C-MEM00-c, CERT_C-MEM00-d, CERT_C-MEM00-e, CERT_C-MEM01-a, CERT_C-MEM01-b, CERT_C-MEM01-c, CERT_C-MEM01-d, CERT_C-MEM02-a, CERT_C-MEM02-b, CERT_C-MEM03-a, CERT_C-MEM04-a, CERT_C-MEM05-a, CERT_C-MEM05-b, CERT_C-MEM07-a, CERT_C-MEM12-a, CERT_C-MEM30-a, CERT_C-MEM31-a, CERT_C-MEM33-a, CERT_C-MEM33-b, CERT_C-MEM34-a, CERT_C-MEM35-a, CERT_C-MEM36-a, CERT_C-MSC01-a, CERT_C-MSC01-b, CERT_C-MSC04-a, CERT_C-MSC04-b, CERT_C-MSC04-c, CERT_C-MSC04-d, CERT_C-MSC06-a, CERT_C-MSC07-a, CERT_C-MSC07-b, CERT_C-MSC07-c, CERT_C-MSC07-d, CERT_C-MSC07-e, CERT_C-MSC07-f, CERT_C-MSC07-g, CERT_C-MSC07-h, CERT_C-MSC07-i, CERT_C-MSC09-a, CERT_C-MSC11-a, CERT_C-MSC12-a, CERT_C-MSC12-b, CERT_C-MSC12-c, CERT_C-MSC12-d, CERT_C-MSC12-e, CERT_C-MSC12-f, CERT_C-MSC12-g, CERT_C-MSC12-h, CERT_C-MSC12-i, CERT_C-MSC12-j, CERT_C-MSC12-k, CERT_C-MSC13-a, CERT_C-MSC14-a, CERT_C-MSC14-b, CERT_C-MSC15-a, CERT_C-MSC15-b, CERT_C-MSC17-a, CERT_C-MSC19-a, CERT_C-MSC19-b, CERT_C-MSC22-a, CERT_C-MSC24-a, CERT_C-MSC24-b, CERT_C-MSC24-c, CERT_C-MSC24-d, CERT_C-MSC30-a, CERT_C-MSC32-d, CERT_C-MSC33-a, CERT_C-MSC37-a, CERT_C-MSC38-a, CERT_C-MSC39-a, CERT_C-MSC40-a, CERT_C-MSC41-a, CERT_C-POS30-a, CERT_C-POS30-b, CERT_C-POS30-c, CERT_C-POS33-a, CERT_C-POS34-a, CERT_C-POS34-b, CERT_C-POS35-b, CERT_C-POS36-a, CERT_C-POS37-a, CERT_C-POS38-a, CERT_C-POS39-a, CERT_C-POS44-a, CERT_C-POS47-a, CERT_C-POS48-a, CERT_C-POS48-b, CERT_C-POS49-a, CERT_C-POS50-a, CERT_C-POS51-a, CERT_C-POS52-a, CERT_C-POS53-a, CERT_C-POS54-a, CERT_C-PRE00-a, CERT_C-PRE01-a, CERT_C-PRE02-a, CERT_C-PRE06-a, CERT_C-PRE07-a, CERT_C-PRE30-a, CERT_C-PRE31-b, CERT_C-PRE31-c, CERT_C-PRE31-d, CERT_C-PRE32-a, CERT_C-SIG00-a, CERT_C-SIG01-a, CERT_C-SIG02-a, CERT_C-SIG30-a, CERT_C-SIG31-a, CERT_C-SIG34-a, CERT_C-SIG35-a, CERT_C-STR00-a, CERT_C-STR02-a, CERT_C-STR02-b, CERT_C-STR02-c, CERT_C-STR03-a, CERT_C-STR04-a, CERT_C-STR05-a, CERT_C-STR07-a, CERT_C-STR09-a, CERT_C-STR10-a, CERT_C-STR11-a, CERT_C-STR30-a, CERT_C-STR30-b, CERT_C-STR31-a, CERT_C-STR31-b, CERT_C-STR31-c, CERT_C-STR31-d, CERT_C-STR31-e, CERT_C-STR32-a, CERT_C-STR34-b, CERT_C-STR34-c, CERT_C-STR34-d, CERT_C-STR37-a, CERT_C-STR38-a, CERT_C-WIN00-a, CERT_C-WIN30-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;HIC++ Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="HICPP-10_1_1-a, HICPP-10_2_1-a, HICPP-10_3_1-a, HICPP-11_1_1-a, HICPP-11_1_1-b, HICPP-11_2_1-a, HICPP-12_1_1-a, HICPP-12_1_1-b, HICPP-12_2_1-a, HICPP-12_3_1-a, HICPP-12_3_1-b, HICPP-12_4_1-b, HICPP-12_4_1-c, HICPP-12_4_2-a, HICPP-12_4_3-a, HICPP-12_4_4-a, HICPP-12_4_5-a, HICPP-12_5_1-a, HICPP-12_5_2-a, HICPP-12_5_3-a, HICPP-12_5_4-a, HICPP-12_5_6-a, HICPP-12_5_7-a, HICPP-12_5_8-a, HICPP-13_1_1-a, HICPP-13_1_2-a, HICPP-13_2_1-a, HICPP-13_2_1-b, HICPP-13_2_2-a, HICPP-13_2_2-b, HICPP-13_2_3-a, HICPP-13_2_4-a, HICPP-13_2_5-a, HICPP-14_1_1-a, HICPP-14_2_1-a, HICPP-14_2_2-a, HICPP-14_2_3-a, HICPP-15_1_1-a, HICPP-15_1_1-b, HICPP-15_2_1-a, HICPP-15_3_1-a, HICPP-15_3_2-a, HICPP-15_3_2-b, HICPP-15_3_2-c, HICPP-16_1_1-a, HICPP-16_1_1-b, HICPP-16_1_1-c, HICPP-16_1_1-d, HICPP-16_1_1-e, HICPP-16_1_1-f, HICPP-16_1_1-g, HICPP-16_1_1-h, HICPP-16_1_1-i, HICPP-16_1_2-a, HICPP-16_1_2-b, HICPP-16_1_3-a, HICPP-16_1_4-a, HICPP-16_1_5-a, HICPP-17_1_1-a, HICPP-17_2_1-a, HICPP-17_2_1-b, HICPP-17_3_1-a, HICPP-17_3_2-a, HICPP-17_3_2-b, HICPP-17_3_2-c, HICPP-17_3_3-a, HICPP-17_3_4-a, HICPP-17_3_5-a, HICPP-17_4_1-a, HICPP-17_4_2-a, HICPP-17_5_1-a, HICPP-18_1_1-a, HICPP-18_2_1-a, HICPP-18_2_2-a, HICPP-18_2_2-b, HICPP-18_2_3-a, HICPP-18_2_4-a, HICPP-18_3_1-a, HICPP-18_3_2-a, HICPP-18_3_3-a, HICPP-18_3_4-a, HICPP-18_3_5-a, HICPP-18_3_6-a, HICPP-18_4_1-a, HICPP-1_2_1-a, HICPP-1_2_1-b, HICPP-1_2_1-c, HICPP-1_2_1-d, HICPP-1_2_1-e, HICPP-1_2_1-f, HICPP-1_2_1-g, HICPP-1_2_1-h, HICPP-1_2_1-i, HICPP-1_2_1-j, HICPP-1_2_2-a, HICPP-1_3_1-a, HICPP-1_3_2-a, HICPP-1_3_3-a, HICPP-1_3_4-a, HICPP-1_3_5-a, HICPP-2_1_1-a, HICPP-2_2_1-a, HICPP-2_2_1-b, HICPP-2_3_1-a, HICPP-2_3_2-a, HICPP-2_4_1-a, HICPP-2_5_1-a, HICPP-2_5_2-a, HICPP-2_5_3-a, HICPP-3_1_1-a, HICPP-3_1_1-b, HICPP-3_1_1-c, HICPP-3_1_1-d, HICPP-3_1_1-e, HICPP-3_2_1-a, HICPP-3_3_1-a, HICPP-3_4_1-a, HICPP-3_4_2-a, HICPP-3_4_3-a, HICPP-3_4_3-b, HICPP-3_4_3-c, HICPP-3_5_1-a, HICPP-3_5_1-b, HICPP-3_5_1-c, HICPP-3_5_1-d, HICPP-4_1_1-a, HICPP-4_1_1-b, HICPP-4_2_1-a, HICPP-4_2_2-a, HICPP-4_2_2-b, HICPP-4_2_2-c, HICPP-4_2_2-d, HICPP-4_2_2-e, HICPP-4_2_2-f, HICPP-4_2_2-g, HICPP-4_2_2-h, HICPP-4_2_2-i, HICPP-4_3_1-a, HICPP-4_3_1-b, HICPP-4_4_1-a, HICPP-5_1_1-a, HICPP-5_1_2-a, HICPP-5_1_2-b, HICPP-5_1_2-c, HICPP-5_1_2-d, HICPP-5_1_2-e, HICPP-5_1_2-f, HICPP-5_1_2-g, HICPP-5_1_2-h, HICPP-5_1_2-i, HICPP-5_1_2-j, HICPP-5_1_3-a, HICPP-5_1_3-b, HICPP-5_1_4-a, HICPP-5_1_5-a, HICPP-5_1_6-a, HICPP-5_1_6-b, HICPP-5_1_6-c, HICPP-5_1_6-d, HICPP-5_1_6-e, HICPP-5_1_6-f, HICPP-5_2_1-a, HICPP-5_2_1-b, HICPP-5_2_1-c, HICPP-5_2_2-a, HICPP-5_2_2-b, HICPP-5_3_1-a, HICPP-5_3_2-a, HICPP-5_3_3-a, HICPP-5_3_3-b, HICPP-5_3_3-c, HICPP-5_4_1-a, HICPP-5_4_1-b, HICPP-5_4_1-c, HICPP-5_4_2-a, HICPP-5_4_3-a, HICPP-5_5_1-a, HICPP-5_6_1-a, HICPP-5_7_1-a, HICPP-5_7_2-a, HICPP-5_8_1-a, HICPP-6_1_1-a, HICPP-6_1_1-b, HICPP-6_1_2-a, HICPP-6_1_2-b, HICPP-6_1_3-a, HICPP-6_1_4-a, HICPP-6_1_4-b, HICPP-6_2_1-a, HICPP-6_2_2-a, HICPP-6_2_3-a, HICPP-6_2_4-a, HICPP-6_3_1-a, HICPP-6_3_1-b, HICPP-6_3_1-c, HICPP-6_3_2-a, HICPP-6_4_1-a, HICPP-6_4_1-b, HICPP-7_1_1-a, HICPP-7_1_1-b, HICPP-7_1_10-a, HICPP-7_1_2-a, HICPP-7_1_2-b, HICPP-7_1_3-a, HICPP-7_1_4-a, HICPP-7_1_5-a, HICPP-7_1_6-a, HICPP-7_1_6-b, HICPP-7_1_6-c, HICPP-7_1_7-a, HICPP-7_1_8-a, HICPP-7_1_9-a, HICPP-7_2_1-a, HICPP-7_2_2-a, HICPP-7_3_1-a, HICPP-7_4_1-a, HICPP-7_4_2-a, HICPP-7_4_2-b, HICPP-7_4_2-c, HICPP-7_4_3-a, HICPP-7_5_1-a, HICPP-8_1_1-a, HICPP-8_2_1-a, HICPP-8_2_2-a, HICPP-8_2_3-a, HICPP-8_2_4-a, HICPP-8_3_1-a, HICPP-8_3_3-a, HICPP-8_3_4-a, HICPP-8_4_1-a, HICPP-8_4_1-b, HICPP-8_4_1-c, HICPP-8_4_2-a, HICPP-9_1_1-a, HICPP-9_1_2-a, HICPP-9_1_3-a, HICPP-9_1_4-a, HICPP-9_1_5-a, HICPP-9_2_1-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;SEI CERT C++ Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="CERT_CPP-CON50-a, CERT_CPP-CON51-a, CERT_CPP-CON52-a, CERT_CPP-CON53-a, CERT_CPP-CON54-a, CERT_CPP-CON55-a, CERT_CPP-CON56-a, CERT_CPP-CTR50-a, CERT_CPP-CTR51-a, CERT_CPP-CTR52-a, CERT_CPP-CTR53-a, CERT_CPP-CTR53-b, CERT_CPP-CTR54-a, CERT_CPP-CTR54-b, CERT_CPP-CTR54-c, CERT_CPP-CTR55-a, CERT_CPP-CTR56-a, CERT_CPP-CTR56-b, CERT_CPP-CTR56-c, CERT_CPP-CTR57-a, CERT_CPP-CTR58-a, CERT_CPP-DCL50-a, CERT_CPP-DCL51-a, CERT_CPP-DCL51-b, CERT_CPP-DCL51-c, CERT_CPP-DCL51-d, CERT_CPP-DCL51-e, CERT_CPP-DCL51-f, CERT_CPP-DCL52-a, CERT_CPP-DCL53-a, CERT_CPP-DCL53-b, CERT_CPP-DCL53-c, CERT_CPP-DCL54-a, CERT_CPP-DCL55-a, CERT_CPP-DCL56-a, CERT_CPP-DCL57-a, CERT_CPP-DCL57-b, CERT_CPP-DCL58-a, CERT_CPP-DCL59-a, CERT_CPP-DCL60-a, CERT_CPP-ERR50-a, CERT_CPP-ERR50-b, CERT_CPP-ERR50-c, CERT_CPP-ERR50-d, CERT_CPP-ERR50-e, CERT_CPP-ERR50-f, CERT_CPP-ERR50-g, CERT_CPP-ERR50-h, CERT_CPP-ERR50-i, CERT_CPP-ERR50-j, CERT_CPP-ERR50-k, CERT_CPP-ERR50-l, CERT_CPP-ERR50-m, CERT_CPP-ERR50-n, CERT_CPP-ERR51-a, CERT_CPP-ERR51-b, CERT_CPP-ERR52-a, CERT_CPP-ERR52-b, CERT_CPP-ERR53-a, CERT_CPP-ERR54-a, CERT_CPP-ERR55-a, CERT_CPP-ERR56-a, CERT_CPP-ERR56-b, CERT_CPP-ERR57-a, CERT_CPP-ERR58-a, CERT_CPP-ERR59-a, CERT_CPP-ERR60-a, CERT_CPP-ERR60-b, CERT_CPP-ERR61-a, CERT_CPP-ERR61-b, CERT_CPP-ERR62-a, CERT_CPP-EXP50-a, CERT_CPP-EXP50-b, CERT_CPP-EXP50-c, CERT_CPP-EXP50-d, CERT_CPP-EXP50-e, CERT_CPP-EXP50-f, CERT_CPP-EXP51-a, CERT_CPP-EXP52-a, CERT_CPP-EXP52-b, CERT_CPP-EXP52-c, CERT_CPP-EXP52-d, CERT_CPP-EXP52-e, CERT_CPP-EXP53-a, CERT_CPP-EXP54-a, CERT_CPP-EXP54-b, CERT_CPP-EXP54-c, CERT_CPP-EXP55-a, CERT_CPP-EXP56-a, CERT_CPP-EXP57-a, CERT_CPP-EXP57-b, CERT_CPP-EXP58-a, CERT_CPP-EXP59-a, CERT_CPP-EXP60-a, CERT_CPP-EXP61-a, CERT_CPP-EXP61-b, CERT_CPP-EXP61-c, CERT_CPP-EXP62-a, CERT_CPP-EXP63-a, CERT_CPP-FIO50-a, CERT_CPP-FIO51-a, CERT_CPP-INT50-a, CERT_CPP-MEM50-a, CERT_CPP-MEM51-a, CERT_CPP-MEM51-b, CERT_CPP-MEM51-c, CERT_CPP-MEM51-d, CERT_CPP-MEM52-a, CERT_CPP-MEM52-b, CERT_CPP-MEM53-a, CERT_CPP-MEM54-a, CERT_CPP-MEM54-b, CERT_CPP-MEM55-a, CERT_CPP-MEM56-a, CERT_CPP-MEM57-a, CERT_CPP-MSC50-a, CERT_CPP-MSC51-a, CERT_CPP-MSC52-a, CERT_CPP-MSC53-a, CERT_CPP-MSC54-a, CERT_CPP-OOP50-a, CERT_CPP-OOP50-b, CERT_CPP-OOP50-c, CERT_CPP-OOP50-d, CERT_CPP-OOP51-a, CERT_CPP-OOP52-a, CERT_CPP-OOP53-a, CERT_CPP-OOP54-a, CERT_CPP-OOP55-a, CERT_CPP-OOP56-a, CERT_CPP-OOP56-b, CERT_CPP-OOP56-c, CERT_CPP-OOP57-a, CERT_CPP-OOP57-b, CERT_CPP-OOP58-a, CERT_CPP-STR50-b, CERT_CPP-STR50-c, CERT_CPP-STR50-e, CERT_CPP-STR50-f, CERT_CPP-STR50-g, CERT_CPP-STR51-a, CERT_CPP-STR52-a, CERT_CPP-STR53-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;DISA STIG Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="APSC_DV-000160-a, APSC_DV-000170-a, APSC_DV-000480-a, APSC_DV-000500-a, APSC_DV-000650-a, APSC_DV-001290-a, APSC_DV-001290-b, APSC_DV-001290-c, APSC_DV-001290-d, APSC_DV-001300-a, APSC_DV-001740-a, APSC_DV-001750-a, APSC_DV-001850-a, APSC_DV-001860-a, APSC_DV-001995-a, APSC_DV-001995-b, APSC_DV-001995-c, APSC_DV-001995-d, APSC_DV-001995-e, APSC_DV-001995-f, APSC_DV-001995-g, APSC_DV-001995-h, APSC_DV-001995-i, APSC_DV-002000-a, APSC_DV-002010-a, APSC_DV-002290-a, APSC_DV-002290-b, APSC_DV-002290-c, APSC_DV-002290-d, APSC_DV-002350-a, APSC_DV-002390-a, APSC_DV-002390-b, APSC_DV-002390-c, APSC_DV-002390-d, APSC_DV-002400-a, APSC_DV-002400-b, APSC_DV-002400-c, APSC_DV-002400-d, APSC_DV-002440-a, APSC_DV-002460-a, APSC_DV-002470-a, APSC_DV-002480-a, APSC_DV-002510-a, APSC_DV-002520-a, APSC_DV-002520-b, APSC_DV-002520-c, APSC_DV-002520-d, APSC_DV-002520-e, APSC_DV-002520-f, APSC_DV-002520-g, APSC_DV-002520-h, APSC_DV-002520-i, APSC_DV-002520-j, APSC_DV-002520-k, APSC_DV-002530-a, APSC_DV-002530-b, APSC_DV-002530-c, APSC_DV-002530-d, APSC_DV-002530-e, APSC_DV-002530-f, APSC_DV-002530-g, APSC_DV-002530-h, APSC_DV-002530-i, APSC_DV-002530-j, APSC_DV-002530-k, APSC_DV-002540-a, APSC_DV-002550-a, APSC_DV-002550-b, APSC_DV-002550-c, APSC_DV-002550-d, APSC_DV-002550-e, APSC_DV-002550-f, APSC_DV-002550-g, APSC_DV-002550-h, APSC_DV-002550-i, APSC_DV-002550-j, APSC_DV-002550-k, APSC_DV-002560-a, APSC_DV-002560-b, APSC_DV-002560-c, APSC_DV-002560-d, APSC_DV-002560-e, APSC_DV-002560-f, APSC_DV-002560-g, APSC_DV-002560-h, APSC_DV-002560-i, APSC_DV-002560-j, APSC_DV-002560-k, APSC_DV-002570-a, APSC_DV-002570-b, APSC_DV-002590-a, APSC_DV-002590-b, APSC_DV-002590-c, APSC_DV-002590-d, APSC_DV-002590-e, APSC_DV-002590-f, APSC_DV-002590-g, APSC_DV-002590-h, APSC_DV-002590-i, APSC_DV-002590-j, APSC_DV-002590-k, APSC_DV-002590-l, APSC_DV-003110-a, APSC_DV-003235-a, APSC_DV-003235-b"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;MISRA C 2012 Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="MISRAC2012-DIR_4_1-a, MISRAC2012-DIR_4_1-b, MISRAC2012-DIR_4_1-c, MISRAC2012-DIR_4_1-d, MISRAC2012-DIR_4_1-e, MISRAC2012-DIR_4_1-f, MISRAC2012-DIR_4_1-g, MISRAC2012-DIR_4_1-h, MISRAC2012-DIR_4_1-i, MISRAC2012-DIR_4_1-j, MISRAC2012-DIR_4_1-k, MISRAC2012-DIR_4_1-l, MISRAC2012-DIR_4_1-m, MISRAC2012-DIR_4_10-a, MISRAC2012-DIR_4_11-a, MISRAC2012-DIR_4_12-a, MISRAC2012-DIR_4_13-a, MISRAC2012-DIR_4_13-b, MISRAC2012-DIR_4_13-c, MISRAC2012-DIR_4_13-d, MISRAC2012-DIR_4_13-e, MISRAC2012-DIR_4_13-f, MISRAC2012-DIR_4_14-a, MISRAC2012-DIR_4_14-b, MISRAC2012-DIR_4_14-c, MISRAC2012-DIR_4_14-d, MISRAC2012-DIR_4_14-e, MISRAC2012-DIR_4_14-f, MISRAC2012-DIR_4_14-g, MISRAC2012-DIR_4_14-h, MISRAC2012-DIR_4_14-i, MISRAC2012-DIR_4_14-j, MISRAC2012-DIR_4_14-k, MISRAC2012-DIR_4_14-l, MISRAC2012-DIR_4_15-a, MISRAC2012-DIR_4_2-a, MISRAC2012-DIR_4_3-a, MISRAC2012-DIR_4_4-a, MISRAC2012-DIR_4_5-a, MISRAC2012-DIR_4_6-a, MISRAC2012-DIR_4_6-b, MISRAC2012-DIR_4_6-c, MISRAC2012-DIR_4_7-a, MISRAC2012-DIR_4_7-b, MISRAC2012-DIR_4_8-a, MISRAC2012-DIR_4_9-a, MISRAC2012-DIR_5_1-a, MISRAC2012-DIR_5_1-b, MISRAC2012-DIR_5_1-c, MISRAC2012-DIR_5_2-a, MISRAC2012-DIR_5_3-a, MISRAC2012-RULE_10_1-a, MISRAC2012-RULE_10_1-b, MISRAC2012-RULE_10_1-c, MISRAC2012-RULE_10_1-d, MISRAC2012-RULE_10_1-e, MISRAC2012-RULE_10_1-f, MISRAC2012-RULE_10_1-g, MISRAC2012-RULE_10_1-h, MISRAC2012-RULE_10_2-a, MISRAC2012-RULE_10_3-a, MISRAC2012-RULE_10_3-b, MISRAC2012-RULE_10_4-a, MISRAC2012-RULE_10_4-b, MISRAC2012-RULE_10_5-a, MISRAC2012-RULE_10_5-b, MISRAC2012-RULE_10_5-c, MISRAC2012-RULE_10_6-a, MISRAC2012-RULE_10_7-a, MISRAC2012-RULE_10_7-b, MISRAC2012-RULE_10_8-a, MISRAC2012-RULE_11_1-a, MISRAC2012-RULE_11_1-b, MISRAC2012-RULE_11_10-a, MISRAC2012-RULE_11_2-a, MISRAC2012-RULE_11_3-a, MISRAC2012-RULE_11_4-a, MISRAC2012-RULE_11_5-a, MISRAC2012-RULE_11_6-a, MISRAC2012-RULE_11_7-a, MISRAC2012-RULE_11_8-a, MISRAC2012-RULE_11_9-a, MISRAC2012-RULE_11_9-b, MISRAC2012-RULE_12_1-a, MISRAC2012-RULE_12_1-c, MISRAC2012-RULE_12_2-a, MISRAC2012-RULE_12_2-b, MISRAC2012-RULE_12_3-a, MISRAC2012-RULE_12_4-a, MISRAC2012-RULE_12_4-b, MISRAC2012-RULE_12_5-a, MISRAC2012-RULE_12_6-a, MISRAC2012-RULE_13_1-a, MISRAC2012-RULE_13_2-a, MISRAC2012-RULE_13_2-b, MISRAC2012-RULE_13_2-c, MISRAC2012-RULE_13_2-d, MISRAC2012-RULE_13_2-e, MISRAC2012-RULE_13_2-f, MISRAC2012-RULE_13_2-g, MISRAC2012-RULE_13_2-h, MISRAC2012-RULE_13_3-a, MISRAC2012-RULE_13_4-a, MISRAC2012-RULE_13_5-a, MISRAC2012-RULE_13_6-a, MISRAC2012-RULE_13_6-b, MISRAC2012-RULE_13_6-c, MISRAC2012-RULE_14_1-a, MISRAC2012-RULE_14_1-b, MISRAC2012-RULE_14_2-a, MISRAC2012-RULE_14_2-b, MISRAC2012-RULE_14_2-c, MISRAC2012-RULE_14_2-d, MISRAC2012-RULE_14_3-ac, MISRAC2012-RULE_14_4-a, MISRAC2012-RULE_15_1-a, MISRAC2012-RULE_15_2-a, MISRAC2012-RULE_15_3-a, MISRAC2012-RULE_15_4-a, MISRAC2012-RULE_15_5-a, MISRAC2012-RULE_15_6-a, MISRAC2012-RULE_15_6-b, MISRAC2012-RULE_15_7-a, MISRAC2012-RULE_16_1-a, MISRAC2012-RULE_16_1-b, MISRAC2012-RULE_16_1-c, MISRAC2012-RULE_16_1-d, MISRAC2012-RULE_16_1-e, MISRAC2012-RULE_16_1-f, MISRAC2012-RULE_16_1-g, MISRAC2012-RULE_16_1-h, MISRAC2012-RULE_16_2-a, MISRAC2012-RULE_16_3-a, MISRAC2012-RULE_16_3-b, MISRAC2012-RULE_16_4-a, MISRAC2012-RULE_16_4-b, MISRAC2012-RULE_16_5-a, MISRAC2012-RULE_16_6-a, MISRAC2012-RULE_16_7-a, MISRAC2012-RULE_16_7-b, MISRAC2012-RULE_17_1-a, MISRAC2012-RULE_17_1-b, MISRAC2012-RULE_17_1-c, MISRAC2012-RULE_17_10-a, MISRAC2012-RULE_17_11-a, MISRAC2012-RULE_17_12-a, MISRAC2012-RULE_17_13-a, MISRAC2012-RULE_17_2-a, MISRAC2012-RULE_17_3-a, MISRAC2012-RULE_17_4-a, MISRAC2012-RULE_17_4-b, MISRAC2012-RULE_17_5-a, MISRAC2012-RULE_17_6-a, MISRAC2012-RULE_17_7-a, MISRAC2012-RULE_17_7-b, MISRAC2012-RULE_17_8-a, MISRAC2012-RULE_17_9-a, MISRAC2012-RULE_18_1-a, MISRAC2012-RULE_18_1-b, MISRAC2012-RULE_18_1-c, MISRAC2012-RULE_18_10-a, MISRAC2012-RULE_18_2-a, MISRAC2012-RULE_18_3-a, MISRAC2012-RULE_18_4-a, MISRAC2012-RULE_18_5-a, MISRAC2012-RULE_18_6-a, MISRAC2012-RULE_18_6-b, MISRAC2012-RULE_18_6-c, MISRAC2012-RULE_18_7-a, MISRAC2012-RULE_18_8-a, MISRAC2012-RULE_18_9-a, MISRAC2012-RULE_19_1-a, MISRAC2012-RULE_19_1-b, MISRAC2012-RULE_19_1-c, MISRAC2012-RULE_19_2-a, MISRAC2012-RULE_1_1-a, MISRAC2012-RULE_1_1-b, MISRAC2012-RULE_1_1-c, MISRAC2012-RULE_1_1-d, MISRAC2012-RULE_1_3-a, MISRAC2012-RULE_1_3-b, MISRAC2012-RULE_1_3-c, MISRAC2012-RULE_1_3-d, MISRAC2012-RULE_1_3-e, MISRAC2012-RULE_1_3-f, MISRAC2012-RULE_1_3-g, MISRAC2012-RULE_1_3-h, MISRAC2012-RULE_1_3-i, MISRAC2012-RULE_1_3-j, MISRAC2012-RULE_1_3-k, MISRAC2012-RULE_1_3-l, MISRAC2012-RULE_1_3-m, MISRAC2012-RULE_1_3-n, MISRAC2012-RULE_1_3-o, MISRAC2012-RULE_1_4-j, MISRAC2012-RULE_1_4-k, MISRAC2012-RULE_1_4-l, MISRAC2012-RULE_1_4-m, MISRAC2012-RULE_1_4-n, MISRAC2012-RULE_1_5-a, MISRAC2012-RULE_1_5-b, MISRAC2012-RULE_1_5-c, MISRAC2012-RULE_1_5-d, MISRAC2012-RULE_1_5-e, MISRAC2012-RULE_1_5-f, MISRAC2012-RULE_1_5-g, MISRAC2012-RULE_20_1-a, MISRAC2012-RULE_20_10-a, MISRAC2012-RULE_20_11-a, MISRAC2012-RULE_20_12-a, MISRAC2012-RULE_20_13-a, MISRAC2012-RULE_20_14-a, MISRAC2012-RULE_20_2-a, MISRAC2012-RULE_20_2-b, MISRAC2012-RULE_20_3-a, MISRAC2012-RULE_20_4-a, MISRAC2012-RULE_20_4-b, MISRAC2012-RULE_20_5-a, MISRAC2012-RULE_20_6-a, MISRAC2012-RULE_20_7-a, MISRAC2012-RULE_20_8-a, MISRAC2012-RULE_20_9-b, MISRAC2012-RULE_21_1-a, MISRAC2012-RULE_21_1-b, MISRAC2012-RULE_21_1-c, MISRAC2012-RULE_21_1-d, MISRAC2012-RULE_21_10-a, MISRAC2012-RULE_21_10-b, MISRAC2012-RULE_21_10-c, MISRAC2012-RULE_21_11-a, MISRAC2012-RULE_21_12-a, MISRAC2012-RULE_21_12-b, MISRAC2012-RULE_21_13-a, MISRAC2012-RULE_21_14-a, MISRAC2012-RULE_21_15-a, MISRAC2012-RULE_21_16-a, MISRAC2012-RULE_21_17-a, MISRAC2012-RULE_21_17-b, MISRAC2012-RULE_21_18-a, MISRAC2012-RULE_21_19-a, MISRAC2012-RULE_21_19-b, MISRAC2012-RULE_21_2-a, MISRAC2012-RULE_21_2-b, MISRAC2012-RULE_21_2-c, MISRAC2012-RULE_21_20-a, MISRAC2012-RULE_21_21-a, MISRAC2012-RULE_21_22-a, MISRAC2012-RULE_21_23-a, MISRAC2012-RULE_21_24-a, MISRAC2012-RULE_21_25-a, MISRAC2012-RULE_21_26-a, MISRAC2012-RULE_21_3-a, MISRAC2012-RULE_21_4-a, MISRAC2012-RULE_21_4-b, MISRAC2012-RULE_21_5-a, MISRAC2012-RULE_21_5-b, MISRAC2012-RULE_21_6-a, MISRAC2012-RULE_21_7-a, MISRAC2012-RULE_21_8-a, MISRAC2012-RULE_21_8-b, MISRAC2012-RULE_21_8-c, MISRAC2012-RULE_21_9-a, MISRAC2012-RULE_22_1-a, MISRAC2012-RULE_22_10-a, MISRAC2012-RULE_22_11-a, MISRAC2012-RULE_22_12-a, MISRAC2012-RULE_22_13-a, MISRAC2012-RULE_22_14-a, MISRAC2012-RULE_22_14-b, MISRAC2012-RULE_22_15-a, MISRAC2012-RULE_22_16-a, MISRAC2012-RULE_22_17-a, MISRAC2012-RULE_22_18-a, MISRAC2012-RULE_22_19-a, MISRAC2012-RULE_22_2-a, MISRAC2012-RULE_22_2-b, MISRAC2012-RULE_22_20-a, MISRAC2012-RULE_22_3-a, MISRAC2012-RULE_22_4-a, MISRAC2012-RULE_22_5-a, MISRAC2012-RULE_22_5-b, MISRAC2012-RULE_22_6-a, MISRAC2012-RULE_22_7-a, MISRAC2012-RULE_22_8-a, MISRAC2012-RULE_22_9-a, MISRAC2012-RULE_23_1-a, MISRAC2012-RULE_23_1-b, MISRAC2012-RULE_23_2-a, MISRAC2012-RULE_23_3-a, MISRAC2012-RULE_23_4-a, MISRAC2012-RULE_23_5-a, MISRAC2012-RULE_23_6-a, MISRAC2012-RULE_23_6-b, MISRAC2012-RULE_23_7-a, MISRAC2012-RULE_23_8-a, MISRAC2012-RULE_2_1-a, MISRAC2012-RULE_2_1-b, MISRAC2012-RULE_2_1-c, MISRAC2012-RULE_2_1-d, MISRAC2012-RULE_2_1-e, MISRAC2012-RULE_2_1-f, MISRAC2012-RULE_2_1-g, MISRAC2012-RULE_2_1-h, MISRAC2012-RULE_2_2-a, MISRAC2012-RULE_2_2-b, MISRAC2012-RULE_2_3-a, MISRAC2012-RULE_2_3-b, MISRAC2012-RULE_2_4-a, MISRAC2012-RULE_2_4-b, MISRAC2012-RULE_2_5-a, MISRAC2012-RULE_2_6-a, MISRAC2012-RULE_2_7-a, MISRAC2012-RULE_2_8-a, MISRAC2012-RULE_2_8-b, MISRAC2012-RULE_2_8-c, MISRAC2012-RULE_3_1-a, MISRAC2012-RULE_3_1-b, MISRAC2012-RULE_3_1-c, MISRAC2012-RULE_3_2-a, MISRAC2012-RULE_4_1-a, MISRAC2012-RULE_4_2-a, MISRAC2012-RULE_5_1-a, MISRAC2012-RULE_5_2-a, MISRAC2012-RULE_5_2-b, MISRAC2012-RULE_5_2-c, MISRAC2012-RULE_5_2-d, MISRAC2012-RULE_5_3-a, MISRAC2012-RULE_5_3-b, MISRAC2012-RULE_5_4-a, MISRAC2012-RULE_5_4-b, MISRAC2012-RULE_5_4-c, MISRAC2012-RULE_5_4-d, MISRAC2012-RULE_5_5-a, MISRAC2012-RULE_5_5-b, MISRAC2012-RULE_5_6-a, MISRAC2012-RULE_5_7-a, MISRAC2012-RULE_5_8-a, MISRAC2012-RULE_5_8-b, MISRAC2012-RULE_5_9-a, MISRAC2012-RULE_5_9-b, MISRAC2012-RULE_6_1-a, MISRAC2012-RULE_6_2-a, MISRAC2012-RULE_6_3-a, MISRAC2012-RULE_7_1-a, MISRAC2012-RULE_7_2-a, MISRAC2012-RULE_7_3-a, MISRAC2012-RULE_7_4-a, MISRAC2012-RULE_7_5-a, MISRAC2012-RULE_7_6-a, MISRAC2012-RULE_8_1-a, MISRAC2012-RULE_8_1-b, MISRAC2012-RULE_8_10-a, MISRAC2012-RULE_8_11-a, MISRAC2012-RULE_8_12-a, MISRAC2012-RULE_8_13-a, MISRAC2012-RULE_8_13-b, MISRAC2012-RULE_8_14-a, MISRAC2012-RULE_8_15-a, MISRAC2012-RULE_8_15-b, MISRAC2012-RULE_8_16-a, MISRAC2012-RULE_8_17-a, MISRAC2012-RULE_8_2-a, MISRAC2012-RULE_8_2-b, MISRAC2012-RULE_8_2-c, MISRAC2012-RULE_8_3-a, MISRAC2012-RULE_8_3-b, MISRAC2012-RULE_8_3-c, MISRAC2012-RULE_8_4-a, MISRAC2012-RULE_8_4-b, MISRAC2012-RULE_8_5-a, MISRAC2012-RULE_8_6-a, MISRAC2012-RULE_8_6-b, MISRAC2012-RULE_8_7-a, MISRAC2012-RULE_8_8-a, MISRAC2012-RULE_8_9-a, MISRAC2012-RULE_9_1-a, MISRAC2012-RULE_9_2-a, MISRAC2012-RULE_9_3-a, MISRAC2012-RULE_9_4-a, MISRAC2012-RULE_9_5-a, MISRAC2012-RULE_9_6-a, MISRAC2012-RULE_9_7-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
         <StaticAnalyzerTestingProcessProblem tested="[WARNING] The &quot;CWE Rules&quot; feature is not licensed. The reported results may be incomplete. The following rules that are specified in your test configuration were not executed:">
            <ErrorList>
               <Error val="CWE-119-a, CWE-119-b, CWE-119-c, CWE-119-d, CWE-119-e, CWE-119-f, CWE-119-g, CWE-119-h, CWE-119-i, CWE-119-j, CWE-119-k, CWE-125-a, CWE-125-b, CWE-125-c, CWE-125-d, CWE-190-a, CWE-190-b, CWE-190-c, CWE-190-d, CWE-190-e, CWE-190-f, CWE-190-g, CWE-190-h, CWE-190-i, CWE-20-a, CWE-20-b, CWE-20-c, CWE-20-d, CWE-20-e, CWE-20-f, CWE-20-g, CWE-20-h, CWE-20-i, CWE-20-j, CWE-200-a, CWE-22-a, CWE-269-a, CWE-269-b, CWE-287-a, CWE-312-a, CWE-326-a, CWE-362-a, CWE-362-b, CWE-362-c, CWE-362-d, CWE-362-e, CWE-400-a, CWE-401-a, CWE-415-a, CWE-416-a, CWE-416-b, CWE-416-c, CWE-426-a, CWE-427-a, CWE-476-a, CWE-476-b, CWE-532-a, CWE-59-a, CWE-611-a, CWE-617-a, CWE-668-a, CWE-704-a, CWE-704-b, CWE-704-c, CWE-704-d, CWE-704-e, CWE-704-f, CWE-704-g, CWE-704-h, CWE-704-i, CWE-704-j, CWE-704-k, CWE-704-l, CWE-732-a, CWE-732-b, CWE-77-a, CWE-770-a, CWE-772-a, CWE-772-b, CWE-78-a, CWE-787-a, CWE-787-b, CWE-787-c, CWE-787-d, CWE-787-e, CWE-787-f, CWE-787-g, CWE-798-a, CWE-835-a, CWE-843-a, CWE-863-a, CWE-89-a"/>
            </ErrorList>
         </StaticAnalyzerTestingProcessProblem>
      </TestingProcessProblems>
      <Rules>
         <RulesList>
            <Rule cat="APSC_DV-000160" desc="Do not use weak encryption functions" id="APSC_DV-000160-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-000170" desc="Do not use weak encryption functions" id="APSC_DV-000170-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-000480" desc="Protect against SQL injection" id="APSC_DV-000480-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-000500" desc="Observe correct revocation order while relinquishing privileges" id="APSC_DV-000500-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-000650" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-000650-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001290" desc="Protect against SQL injection" id="APSC_DV-001290-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001290" desc="Untrusted data is used as a loop boundary" id="APSC_DV-001290-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001290" desc="Avoid passing user input into methods as parameters" id="APSC_DV-001290-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001290" desc="Avoid using unsecured shell functions that may be affected by shell metacharacters" id="APSC_DV-001290-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001300" desc="Protect against SQL injection" id="APSC_DV-001300-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001740" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001740-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001750" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001750-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001850" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001850-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001860" desc="Do not use weak encryption functions" id="APSC_DV-001860-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Avoid race conditions when using fork and file descriptors" id="APSC_DV-001995-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Avoid race conditions while checking for the existence of a symbolic link" id="APSC_DV-001995-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Avoid race conditions while accessing files" id="APSC_DV-001995-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Use locks to prevent race conditions when modifying bit fields" id="APSC_DV-001995-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Do not use global variable with different locks set" id="APSC_DV-001995-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Avoid using thread-unsafe functions" id="APSC_DV-001995-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Usage of functions prone to race is not allowed" id="APSC_DV-001995-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Avoid using the 'vfork()' function" id="APSC_DV-001995-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-001995" desc="Properly define signal handlers" id="APSC_DV-001995-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002000" desc="Ensure resources are freed" id="APSC_DV-002000-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002010" desc="Do not use weak encryption functions" id="APSC_DV-002010-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002290" desc="Do not use the rand() function for generating pseudorandom numbers" id="APSC_DV-002290-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002290" desc="Properly seed pseudorandom number generators" id="APSC_DV-002290-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002290" desc="The 'random_shuffle' identifier should not be used" id="APSC_DV-002290-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002290" desc="The random number generator functions 'rand()' and 'srand()' should not be used" id="APSC_DV-002290-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002350" desc="Do not use weak encryption functions" id="APSC_DV-002350-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002390" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="APSC_DV-002390-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002390" desc="Do not process structured text data natively" id="APSC_DV-002390-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002390" desc="Do not use scanf and fscanf functions without specifying variable size in format string" id="APSC_DV-002390-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002390" desc="Do not use mbstowcs() function" id="APSC_DV-002390-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002400" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002400-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002400" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="APSC_DV-002400-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002400" desc="Avoid using the 'vfork()' function" id="APSC_DV-002400-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002400" desc="Avoid using thread-unsafe functions" id="APSC_DV-002400-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002440" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002440-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002460" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002460-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002470" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002470-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002480" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-002480-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002510" desc="Protect against command injection" id="APSC_DV-002510-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Protect against environment injection" id="APSC_DV-002520-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Protect against file name injection" id="APSC_DV-002520-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Protect against SQL injection" id="APSC_DV-002520-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002520-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Avoid tainted data in array indexes" id="APSC_DV-002520-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002520-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002520-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Protect against command injection" id="APSC_DV-002520-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Avoid printing tainted data on the output console" id="APSC_DV-002520-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002520-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002520" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002520-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Protect against environment injection" id="APSC_DV-002530-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Protect against file name injection" id="APSC_DV-002530-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Protect against SQL injection" id="APSC_DV-002530-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002530-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Avoid tainted data in array indexes" id="APSC_DV-002530-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002530-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002530-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Protect against command injection" id="APSC_DV-002530-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Avoid printing tainted data on the output console" id="APSC_DV-002530-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002530-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002530" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002530-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002540" desc="Protect against SQL injection" id="APSC_DV-002540-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Protect against environment injection" id="APSC_DV-002550-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Protect against file name injection" id="APSC_DV-002550-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Protect against SQL injection" id="APSC_DV-002550-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002550-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Avoid tainted data in array indexes" id="APSC_DV-002550-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002550-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002550-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Protect against command injection" id="APSC_DV-002550-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Avoid printing tainted data on the output console" id="APSC_DV-002550-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002550-j" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002550" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002550-k" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Protect against environment injection" id="APSC_DV-002560-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Protect against file name injection" id="APSC_DV-002560-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Protect against SQL injection" id="APSC_DV-002560-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002560-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Avoid tainted data in array indexes" id="APSC_DV-002560-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002560-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002560-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Protect against command injection" id="APSC_DV-002560-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Avoid printing tainted data on the output console" id="APSC_DV-002560-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002560-j" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002560" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002560-k" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002570" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002570-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002570" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-002570-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid buffer overflow due to defining incorrect format limits" id="APSC_DV-002590-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid overflow due to reading a not zero terminated string" id="APSC_DV-002590-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid overflow when reading from a buffer" id="APSC_DV-002590-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid overflow when writing to a buffer" id="APSC_DV-002590-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid wraparounds when performing arithmetic integer operations" id="APSC_DV-002590-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Prevent buffer overflows from tainted data" id="APSC_DV-002590-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002590-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="APSC_DV-002590-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid buffer read overflow from tainted data" id="APSC_DV-002590-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid buffer write overflow from tainted data" id="APSC_DV-002590-j" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Ensure the output buffer is large enough when using path manipulation functions" id="APSC_DV-002590-k" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-002590" desc="Avoid signed integer overflows" id="APSC_DV-002590-l" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-003110" desc="Do not hard code string literals" id="APSC_DV-003110-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-003235" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-003235-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="APSC_DV-003235" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-003235-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_1" desc="Avoid unused values" id="AUTOSAR-A0_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_2" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="AUTOSAR-A0_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_3" desc="Every defined function with internal linkage shall be used at least once" id="AUTOSAR-A0_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_4" desc="Eliminate unused parameters" id="AUTOSAR-A0_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_5" desc="There shall be no unused named parameters in virtual functions" id="AUTOSAR-A0_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_1_6" desc="A project shall not contain unused type declarations" id="AUTOSAR-A0_1_6-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_4_2" desc="Type long double shall not be used" id="AUTOSAR-A0_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A0_4_4" desc="Validate values passed to library functions" id="AUTOSAR-A0_4_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_1_1" desc="Be wary about using multiple inheritance of classes that are not abstract interfaces" id="AUTOSAR-A10_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_2_1" desc="Never redefine an inherited nonvirtual function" id="AUTOSAR-A10_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_2_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="AUTOSAR-A10_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_3_1" desc="Only one of virtual, override or final should be specified in a member function declaration" id="AUTOSAR-A10_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_3_2" desc="Each overriding virtual function shall be declared with the override or final specifier" id="AUTOSAR-A10_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_3_3" desc="Do not introduce virtual functions in a final class" id="AUTOSAR-A10_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_3_5" desc="A user-defined assignment operator shall not be virtual" id="AUTOSAR-A10_3_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A10_4_1" desc="Hierarchies should be based on abstract classes" id="AUTOSAR-A10_4_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A11_0_1" desc="A non-POD type should be defined as class" id="AUTOSAR-A11_0_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A11_0_2" desc="Structs should only contain public data members and should not be a base or inherit" id="AUTOSAR-A11_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A11_3_1" desc="Friend declarations shall not be used except declarations of comparison operators" id="AUTOSAR-A11_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_0_1" desc="If a class declares a copy or move operation, or a destructor, either via '=default', '=delete', or via a user-provided declaration, then all others of these five special member functions shall be declared as well" id="AUTOSAR-A12_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_0_2" desc="Do not compare objects of a class that may contain padding bits with C standard library functions" id="AUTOSAR-A12_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_1" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="AUTOSAR-A12_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_1" desc="All member variables should be initialized in constructor" id="AUTOSAR-A12_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_2" desc="Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type" id="AUTOSAR-A12_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_3" desc="User-defined constructors that initialize data members with the same constant values across all constructors should initialize using NSDMI instead" id="AUTOSAR-A12_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_4" desc="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="AUTOSAR-A12_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_5" desc="Use delegating constructors to reduce code duplication" id="AUTOSAR-A12_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_1_6" desc="Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors" id="AUTOSAR-A12_1_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_4_1" desc="Make base class destructors public and virtual, or protected and nonvirtual" id="AUTOSAR-A12_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_4_2" desc="If a public destructor of a class is non-virtual, then the class should be declared final" id="AUTOSAR-A12_4_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_6_1" desc="Prefer initialization to assignment in constructors" id="AUTOSAR-A12_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_7_1" desc="Define special members as =default when the behavior is equivalent to the compiler's behavior" id="AUTOSAR-A12_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_1" desc="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="AUTOSAR-A12_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_2" desc="User-defined copy and move assignment operators should use user-defined no-throw swap function" id="AUTOSAR-A12_8_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_3" desc="Do not rely on the value of a moved-from object" id="AUTOSAR-A12_8_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_4" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A12_8_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_5" desc="Check for assignment to self in operator=" id="AUTOSAR-A12_8_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_6" desc="Avoid public copy constructors and assignment operators in base classes" id="AUTOSAR-A12_8_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A12_8_7" desc="Declare assignment operators with the ref-qualifier &amp;" id="AUTOSAR-A12_8_7-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_1_2" desc="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="AUTOSAR-A13_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_1_3" desc="User defined literals operators shall only perform conversion of passed parameters" id="AUTOSAR-A13_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_2_1" desc="Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type" id="AUTOSAR-A13_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_2_2" desc="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="AUTOSAR-A13_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_2_3" desc="A relational operator shall return a boolean value" id="AUTOSAR-A13_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_3_1" desc="Avoid Overloading on Forwarding References" id="AUTOSAR-A13_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_1" desc="When overloading the subscript operator (operator[]), implement both const and non-const versions" id="AUTOSAR-A13_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_2" desc="User-conversion cast operators should be made explicit" id="AUTOSAR-A13_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_3" desc="Do not use user-defined conversion functions" id="AUTOSAR-A13_5_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_4" desc="If two opposite equality operators ('==', '!=') are defined in a class, one shall be defined in terms of the other" id="AUTOSAR-A13_5_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_5" desc="Comparison operators shall be non-member functions" id="AUTOSAR-A13_5_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_5_5" desc="Comparison operators shall be non-member functions with identical parameter types and noexcept" id="AUTOSAR-A13_5_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A13_6_1" desc="Digit sequences separators ' shall only be used consistently" id="AUTOSAR-A13_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A14_5_1" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="AUTOSAR-A14_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A14_5_3" desc="A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations" id="AUTOSAR-A14_5_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A14_7_2" desc="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="AUTOSAR-A14_7_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A14_8_2" desc="Overloaded function templates shall not be explicitly specialized" id="AUTOSAR-A14_8_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_0_2" desc="Ensure resources are freed" id="AUTOSAR-A15_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_1_1" desc="Only use instances of std::exception for exceptions" id="AUTOSAR-A15_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_1_2" desc="An exception object should not have pointer type" id="AUTOSAR-A15_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_1_4" desc="Ensure resources are freed" id="AUTOSAR-A15_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_1_5" desc="Do not throw an exception across execution boundaries" id="AUTOSAR-A15_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_2_1" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-A15_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_2_1" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_3_2" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_3_3" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="AUTOSAR-A15_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_3_4" desc="Avoid using catch-all exception handlers" id="AUTOSAR-A15_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_3_5" desc="A class type exception shall always be caught by reference" id="AUTOSAR-A15_3_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_4_1" desc="Do not use throw exception specifications" id="AUTOSAR-A15_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_4_2" desc="Avoid throwing exceptions from functions that are declared not to throw" id="AUTOSAR-A15_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_4_3" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="AUTOSAR-A15_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_4_4" desc="Declare functions 'noexcept' if they will not emit exceptions" id="AUTOSAR-A15_4_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_4_5" desc="Checked exceptions that could be thrown from a function shall be specified in the comment directly before the function declaration" id="AUTOSAR-A15_4_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_1" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="AUTOSAR-A15_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_1" desc="All user-provided move constructors and move assignment operators shall not exit with an exception" id="AUTOSAR-A15_5_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_2" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="AUTOSAR-A15_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_2" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-A15_5_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_2" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-A15_5_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="AUTOSAR-A15_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="AUTOSAR-A15_5_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Do not throw from within destructor" id="AUTOSAR-A15_5_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="AUTOSAR-A15_5_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="AUTOSAR-A15_5_3-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Exceptions shall be raised only after start-up and before termination of the program" id="AUTOSAR-A15_5_3-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_5_3-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="AUTOSAR-A15_5_3-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-A15_5_3-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Always catch exceptions" id="AUTOSAR-A15_5_3-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A15_5_3" desc="Properly define exit handlers" id="AUTOSAR-A15_5_3-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_0_1" desc="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" id="AUTOSAR-A16_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_0_1" desc="#error directive shall not be used" id="AUTOSAR-A16_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_0_1" desc="The #pragma directive shall not be used" id="AUTOSAR-A16_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_0_1" desc="Avoid using macro definitions" id="AUTOSAR-A16_0_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_0_1" desc="#undef shall not be used" id="AUTOSAR-A16_0_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_2_1" desc="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot;" id="AUTOSAR-A16_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_2_2" desc="A file should directly include only the headers that contain declarations and definitions required to compile that file" id="AUTOSAR-A16_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_6_1" desc="#error directive shall not be used" id="AUTOSAR-A16_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A16_7_1" desc="The #pragma directive shall not be used" id="AUTOSAR-A16_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_0_1" desc="Do not #define nor #undef identifier 'defined'" id="AUTOSAR-A17_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_0_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="AUTOSAR-A17_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_0_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="AUTOSAR-A17_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_0_1" desc="Do not redefine reserved words" id="AUTOSAR-A17_0_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_0_1" desc="Do not #define or #undef identifiers with names which start with underscore" id="AUTOSAR-A17_0_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_1_1" desc="The error indicator 'errno' shall not be used" id="AUTOSAR-A17_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A17_6_1" desc="Do not modify the standard namespaces 'std' and 'posix'" id="AUTOSAR-A17_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_0_1" desc="The C library shall not be used" id="AUTOSAR-A18_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_0_2" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="AUTOSAR-A18_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_0_2" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="AUTOSAR-A18_0_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_0_3" desc="Do not include &lt;locale.h> header" id="AUTOSAR-A18_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_0_3" desc="The 'setlocale' function should not be used" id="AUTOSAR-A18_0_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_1_1" desc="C-style arrays shall not be used" id="AUTOSAR-A18_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_1_2" desc="Avoid using vector&lt;bool>" id="AUTOSAR-A18_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_1_3" desc="Prefer to use std::unique_ptr instead of std::auto_ptr" id="AUTOSAR-A18_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_1_4" desc="A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" id="AUTOSAR-A18_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_1_6" desc="All std::hash specializations for user-defined types shall have a noexcept function call operator" id="AUTOSAR-A18_1_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_1" desc="Do not use calloc, malloc, realloc and free functions" id="AUTOSAR-A18_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_10" desc="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="AUTOSAR-A18_5_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_10" desc="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="AUTOSAR-A18_5_10-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_11" desc="Write operator delete if you write operator new" id="AUTOSAR-A18_5_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_11" desc="Write operator delete[] if you write operator new[]" id="AUTOSAR-A18_5_11-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_2" desc="Dynamic heap memory allocation shall not be used" id="AUTOSAR-A18_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_3" desc="Never provide brackets ([]) for delete when deallocating non-arrays" id="AUTOSAR-A18_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_3" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="AUTOSAR-A18_5_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_3" desc="Properly deallocate dynamically allocated resources" id="AUTOSAR-A18_5_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_4" desc="Define both sized and unsized versions of operator delete" id="AUTOSAR-A18_5_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_5" desc="Use the same form in corresponding calls to new/malloc and delete/free" id="AUTOSAR-A18_5_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_5" desc="Freed memory shouldn't be accessed under any circumstances" id="AUTOSAR-A18_5_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_5" desc="Properly define new handlers" id="AUTOSAR-A18_5_5-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_8" desc="Use allocation by declaration rather than by new or malloc" id="AUTOSAR-A18_5_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_5_9" desc="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="AUTOSAR-A18_5_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_9_1" desc="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="AUTOSAR-A18_9_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_9_2" desc="The 'std::forward' function should be used to forward forwarding references" id="AUTOSAR-A18_9_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_9_2" desc="The 'std::move' function should be used to forward rvalue references" id="AUTOSAR-A18_9_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_9_3" desc="Do not use std::move on objects declared with the const or const &amp; type" id="AUTOSAR-A18_9_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A18_9_4" desc="Do not subsequently use the argument to std::forward" id="AUTOSAR-A18_9_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="The 'register' storage class specifier shall not be used" id="AUTOSAR-A1_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="A copy assignment operator should be declared when a copy constructor is declared (and vice versa)" id="AUTOSAR-A1_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="AUTOSAR-A1_1_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="The C library shall not be used" id="AUTOSAR-A1_1_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="AUTOSAR-A1_1_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="The 'binder1st' and 'binder2nd' identifiers should not be used" id="AUTOSAR-A1_1_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="Prefer to use std::unique_ptr instead of std::auto_ptr" id="AUTOSAR-A1_1_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="The 'random_shuffle' identifier should not be used" id="AUTOSAR-A1_1_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="Do not use the increment operator (++) on an operand of type 'bool'" id="AUTOSAR-A1_1_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="The 'set_unexpected' identifier should not be used" id="AUTOSAR-A1_1_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A1_1_1" desc="Do not use throw exception specifications" id="AUTOSAR-A1_1_1-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_1" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="AUTOSAR-A20_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_2" desc="Use smart pointers when passing a pointer to an object in a thread" id="AUTOSAR-A20_8_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_3" desc="Use smart pointers when passing a pointer to an object in a thread" id="AUTOSAR-A20_8_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_4" desc="Consider using 'std::unique_ptr' instead of 'std::shared_ptr' for local objects" id="AUTOSAR-A20_8_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_5" desc="'std::make_unique' shall be used to construct objects owned by 'std::unique_ptr'" id="AUTOSAR-A20_8_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_6" desc="Prefer 'std::make_shared' to the direct use of new" id="AUTOSAR-A20_8_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A20_8_7" desc="Avoid cyclic shared_ptr references" id="AUTOSAR-A20_8_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A21_8_1" desc="Do not pass incorrect values to ctype.h library functions" id="AUTOSAR-A21_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A23_0_1" desc="Use const container calls when the result is immediately converted to a const iterator" id="AUTOSAR-A23_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A23_0_2" desc="Do not modify container while iterating over it" id="AUTOSAR-A23_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A23_0_2" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="AUTOSAR-A23_0_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A25_1_1" desc="Make predicates const pure functions" id="AUTOSAR-A25_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A25_4_1" desc="For associative containers never use comparison function returning true for equal values" id="AUTOSAR-A25_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A26_5_1" desc="Do not use the rand() function for generating pseudorandom numbers" id="AUTOSAR-A26_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A26_5_2" desc="Properly seed pseudorandom number generators" id="AUTOSAR-A26_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="AUTOSAR-A27_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Avoid tainted data in array indexes" id="AUTOSAR-A27_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Prevent buffer overflows from tainted data" id="AUTOSAR-A27_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="AUTOSAR-A27_0_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Avoid buffer read overflow from tainted data" id="AUTOSAR-A27_0_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Avoid buffer write overflow from tainted data" id="AUTOSAR-A27_0_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Protect against command injection" id="AUTOSAR-A27_0_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_1" desc="Exclude unsanitized user input from format strings" id="AUTOSAR-A27_0_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_2" desc="Avoid overflow due to reading a not zero terminated string" id="AUTOSAR-A27_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_2" desc="Avoid overflow when writing to a buffer" id="AUTOSAR-A27_0_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_2" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="AUTOSAR-A27_0_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_2" desc="Prevent buffer overflows from tainted data" id="AUTOSAR-A27_0_2-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_2" desc="Avoid buffer write overflow from tainted data" id="AUTOSAR-A27_0_2-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_3" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="AUTOSAR-A27_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_4" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="AUTOSAR-A27_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_4" desc="Avoid using unsafe string functions that do not check bounds" id="AUTOSAR-A27_0_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_4" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="AUTOSAR-A27_0_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_4" desc="C-style strings shall not be used" id="AUTOSAR-A27_0_4-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A27_0_4" desc="Do not use the 'c_str()' and 'data()' functions for string objects" id="AUTOSAR-A27_0_4-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_1" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="AUTOSAR-A2_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_1" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="AUTOSAR-A2_10_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_1" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="AUTOSAR-A2_10_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_1" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="AUTOSAR-A2_10_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_1" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="AUTOSAR-A2_10_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_4" desc="The identifier name of a non-member object with static storage duration shall not be reused within a namespace" id="AUTOSAR-A2_10_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_4" desc="The identifier name of a non-member static function shall not be reused within a namespace" id="AUTOSAR-A2_10_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_5" desc="Identifiers that define objects with external linkage shall be unique" id="AUTOSAR-A2_10_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_5" desc="Identifiers that define functions with external linkage shall be unique" id="AUTOSAR-A2_10_5-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_5" desc="Identifiers that define objects with internal linkage shall be unique" id="AUTOSAR-A2_10_5-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_5" desc="Identifiers that define functions with internal linkage shall be unique" id="AUTOSAR-A2_10_5-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_11_1" desc="Do not use the volatile keyword" id="AUTOSAR-A2_11_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_1" desc="Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" id="AUTOSAR-A2_13_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_2" desc="String literals with different encoding prefixes shall not be concatenated" id="AUTOSAR-A2_13_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_3" desc="Type wchar_t shall not be used" id="AUTOSAR-A2_13_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_4" desc="A string literal shall not be modified" id="AUTOSAR-A2_13_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_5" desc="Hexadecimal constants will be represented using all uppercase letters" id="AUTOSAR-A2_13_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_13_6" desc="Universal character names shall be used only inside character or string literals" id="AUTOSAR-A2_13_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_3_1" desc="Only use characters defined in the ISO C standard" id="AUTOSAR-A2_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_5_1" desc="Trigraphs shall not be used" id="AUTOSAR-A2_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_5_1" desc="Trigraphs shall not be used" id="AUTOSAR-A2_5_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_5_2" desc="Do not use the following digraphs: &lt;%, %>, &lt;:, :>, %:, %:%:" id="AUTOSAR-A2_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_7_1" desc="Line-splicing shall not be used in // comments" id="AUTOSAR-A2_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_7_2" desc="Sections of code should not be &quot;commented out&quot;" id="AUTOSAR-A2_7_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_7_3" desc="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" id="AUTOSAR-A2_7_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_7_3" desc="Function parameters and return type should be documented in a comment that precedes the function declaration" id="AUTOSAR-A2_7_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A2_8_1" desc="An include file for a class should have a file name of the form &lt;class name> + extension" id="AUTOSAR-A2_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_1" desc="Don't define entities with linkage in a header file" id="AUTOSAR-A3_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_2" desc="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" id="AUTOSAR-A3_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_3" desc="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" id="AUTOSAR-A3_1_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_4" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="AUTOSAR-A3_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_5" desc="A function definition should not be placed in a class specification unless the function is intended to be inlined" id="AUTOSAR-A3_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_1_6" desc="Trivial accessor and mutator functions should be inlined" id="AUTOSAR-A3_1_6-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_3_1" desc="Objects or functions with external linkage shall be declared in a header file" id="AUTOSAR-A3_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_3_1" desc="Don't define entities with linkage in a header file" id="AUTOSAR-A3_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_3_2" desc="Static and thread-local objects shall be constant-initialized" id="AUTOSAR-A3_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_8_1" desc="Do not use resources that have been freed" id="AUTOSAR-A3_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_8_1" desc="The address of an object with automatic storage shall not be returned from a function" id="AUTOSAR-A3_8_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_8_1" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="AUTOSAR-A3_8_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_8_1" desc="Do not point to a wrapped object that has been freed" id="AUTOSAR-A3_8_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_9_1" desc="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" id="AUTOSAR-A3_9_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A3_9_1" desc="A typedef should be used in place of the plain char type" id="AUTOSAR-A3_9_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_10_1" desc="NULL shall not be used as an integer value" id="AUTOSAR-A4_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_10_1" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="AUTOSAR-A4_10_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_5_1" desc="Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  =, ==, !=, &lt;, &lt;=, >, >=, and the unary &amp; operator" id="AUTOSAR-A4_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from signed to unsigned type" id="AUTOSAR-A4_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid conversions of constant values to a narrower type" id="AUTOSAR-A4_7_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from wider to narrower floating type" id="AUTOSAR-A4_7_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from floating to integral type" id="AUTOSAR-A4_7_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid wraparounds when performing arithmetic integer operations" id="AUTOSAR-A4_7_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid data loss when converting between integer types" id="AUTOSAR-A4_7_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid signed integer overflows" id="AUTOSAR-A4_7_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A4_7_1" desc="Avoid value change when converting between integer types" id="AUTOSAR-A4_7_1-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function calls" id="AUTOSAR-A5_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Do not use more than one volatile between two adjacent sequence points" id="AUTOSAR-A5_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="AUTOSAR-A5_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="AUTOSAR-A5_0_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="AUTOSAR-A5_0_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function arguments" id="AUTOSAR-A5_0_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_1" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="AUTOSAR-A5_0_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_2" desc="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="AUTOSAR-A5_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_3" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="AUTOSAR-A5_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_4" desc="Don't treat arrays polymorphically" id="AUTOSAR-A5_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_4" desc="A pointer to an array of derived class objects should not be converted to a base class pointer" id="AUTOSAR-A5_0_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_0_4" desc="Do not treat arrays polymorphically" id="AUTOSAR-A5_0_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_10_1" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="AUTOSAR-A5_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_16_1" desc="The conditional operator should not be used as a sub-expression" id="AUTOSAR-A5_16_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_1" desc="Avoid magic numbers" id="AUTOSAR-A5_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_2" desc="Avoid default capture modes" id="AUTOSAR-A5_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_3" desc="Include a parameter list in every lambda expression" id="AUTOSAR-A5_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_4" desc="Never return lambdas that capture local objects by reference" id="AUTOSAR-A5_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_4" desc="Never capture local objects from an outer lambda by reference" id="AUTOSAR-A5_1_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_4" desc="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="AUTOSAR-A5_1_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_6" desc="Return type of a non-void return type lambda expression should be explicitly specified" id="AUTOSAR-A5_1_6-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_7" desc="A lambda shall not be an operand to typeid" id="AUTOSAR-A5_1_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_1_8" desc="Lambda expressions should not be defined inside another lambda expression" id="AUTOSAR-A5_1_8-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_1" desc="Avoid dynamic_casts" id="AUTOSAR-A5_2_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_2" desc="C-style casts should not be used" id="AUTOSAR-A5_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_3" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="AUTOSAR-A5_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_4" desc="Avoid using reinterpret_cast" id="AUTOSAR-A5_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_5" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-A5_2_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_5" desc="Avoid accessing arrays and pointers out of bounds" id="AUTOSAR-A5_2_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_5" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="AUTOSAR-A5_2_5-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_5" desc="Avoid tainted data in array indexes" id="AUTOSAR-A5_2_5-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_2_6" desc="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="AUTOSAR-A5_2_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_3_1" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="AUTOSAR-A5_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_3_1" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="AUTOSAR-A5_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_3_2" desc="Avoid null pointer dereferencing" id="AUTOSAR-A5_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_3_3" desc="Do not delete objects with incomplete class at the point of deletion" id="AUTOSAR-A5_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_5_1" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="AUTOSAR-A5_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A5_6_1" desc="Avoid division by zero" id="AUTOSAR-A5_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_2_1" desc="Copy assignment operators should not have side effects that could affect copying the object" id="AUTOSAR-A6_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_2_1" desc="Move assignment operators should not have side effects that could affect moving the object" id="AUTOSAR-A6_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_2_2" desc="Expression statements shall not be explicit calls to constructors of temporary objects only" id="AUTOSAR-A6_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_4_1" desc="Every switch statement will have at least two cases and a potential default" id="AUTOSAR-A6_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_5_1" desc="A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" id="AUTOSAR-A6_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_5_2" desc="A for loop shall contain a single loop-counter which shall not have floating type" id="AUTOSAR-A6_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_5_3" desc="'Do' statements should not be used except in a function-like macro" id="AUTOSAR-A6_5_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_5_4" desc="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="AUTOSAR-A6_5_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_5_4" desc="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="AUTOSAR-A6_5_4-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A6_6_1" desc="The goto statement shall not be used" id="AUTOSAR-A6_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_1" desc="Declare local variable as const whenever possible" id="AUTOSAR-A7_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_1" desc="Declare parameters as const whenever possible" id="AUTOSAR-A7_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_2" desc="Use constexpr to declare const variables whenever possible" id="AUTOSAR-A7_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_2" desc="Use constexpr to declare functions whenever possible" id="AUTOSAR-A7_1_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_3" desc="CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" id="AUTOSAR-A7_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_4" desc="The 'register' storage class specifier shall not be used" id="AUTOSAR-A7_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_5" desc="Do not overuse 'auto' specifier" id="AUTOSAR-A7_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_6" desc="Prefer alias declarations to typedefs" id="AUTOSAR-A7_1_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_7" desc="Only one statement shall be allowed per line" id="AUTOSAR-A7_1_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_7" desc="Multiple variable declarations shall not be allowed on the same line" id="AUTOSAR-A7_1_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_7" desc="Each variable should be declared in a separate declaration statement" id="AUTOSAR-A7_1_7-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_8" desc="Do not place type specifiers before non-type specifiers in a declaration" id="AUTOSAR-A7_1_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_1_9" desc="A class, structure, or enumeration will not be declared in the definition of its type" id="AUTOSAR-A7_1_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_2_1" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="AUTOSAR-A7_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_2_2" desc="Use an explicit enumeration base and ensure that it is large enough to store all enumerators" id="AUTOSAR-A7_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_2_3" desc="Prefer Scoped Enums to Unscoped Enums" id="AUTOSAR-A7_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_2_4" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="AUTOSAR-A7_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_2_5" desc="Enumeration types shall be used instead of integer types (and constants) as case labels" id="AUTOSAR-A7_2_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_3_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="AUTOSAR-A7_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_4_1" desc="The 'asm' declaration should not be used" id="AUTOSAR-A7_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_5_1" desc="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="AUTOSAR-A7_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_5_2" desc="Functions shall not call themselves, either directly or indirectly" id="AUTOSAR-A7_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A7_6_1" desc="Never return from functions that should not return" id="AUTOSAR-A7_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_2_1" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="AUTOSAR-A8_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_1" desc="Do not use functions with variable numbers of arguments" id="AUTOSAR-A8_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_10" desc="A parameter shall be passed by reference if it can't be NULL" id="AUTOSAR-A8_4_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_11" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_12" desc="Do not pass std::unique_ptr by const reference" id="AUTOSAR-A8_4_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_12" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_12-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_12" desc="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="AUTOSAR-A8_4_12-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_12" desc="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="AUTOSAR-A8_4_12-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_13" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_13" desc="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="AUTOSAR-A8_4_13-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_13" desc="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="AUTOSAR-A8_4_13-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_2" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="AUTOSAR-A8_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_3" desc="A parameter of a type that is not 'cheap to copy' should be passed by reference" id="AUTOSAR-A8_4_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_3" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-A8_4_3-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_4" desc="Multiple output values from a function should be returned as a struct or tuple" id="AUTOSAR-A8_4_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_5" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A8_4_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_6" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A8_4_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_7" desc="A parameter of const reference to a 'cheap to copy' type should be passed by value" id="AUTOSAR-A8_4_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_8" desc="Output parameters shall not be used" id="AUTOSAR-A8_4_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_4_9" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-A8_4_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_5_0" desc="Avoid use before initialization" id="AUTOSAR-A8_5_0-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_5_1" desc="List members in an initialization list in the order in which they are declared" id="AUTOSAR-A8_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_5_2" desc="Braced-initialization {}, without equals sign, shall be used for variable initialization" id="AUTOSAR-A8_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_5_3" desc="A variable of type auto shall not be initialized using '{}' or '={}' braced-initialization" id="AUTOSAR-A8_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A8_5_4" desc="Avoid overloading constructors with std::initializer_list" id="AUTOSAR-A8_5_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_3_1" desc="Public member functions shall not return non-const handles to private/protected class-data" id="AUTOSAR-A9_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_3_1" desc="Protected member function shall not return non-const handles to private class-data" id="AUTOSAR-A9_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_5_1" desc="Unions shall not be used" id="AUTOSAR-A9_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_5_1" desc="Unions shall not be used" id="AUTOSAR-A9_5_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_6_1" desc="Types of bit-fields should have defined sizes" id="AUTOSAR-A9_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-A9_6_2" desc="Do not declare member variables as bit-fields" id="AUTOSAR-A9_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="AUTOSAR-M0_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="AUTOSAR-M0_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="AUTOSAR-M0_1_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="AUTOSAR-M0_1_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="AUTOSAR-M0_1_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in 'for' loop" id="AUTOSAR-M0_1_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in switch statement" id="AUTOSAR-M0_1_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_10" desc="Every defined function with external linkage shall be used at least once" id="AUTOSAR-M0_1_10-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_10" desc="Every defined function with internal linkage shall be used at least once" id="AUTOSAR-M0_1_10-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-aa" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-ab" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Avoid conditions that always evaluate to the same value" id="AUTOSAR-M0_1_2-ac" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-p" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-q" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-r" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-s" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-t" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-u" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-v" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-w" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-x" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-y" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-z" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_3" desc="Avoid unused local variables" id="AUTOSAR-M0_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_3" desc="Avoid unused private member variables" id="AUTOSAR-M0_1_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_3" desc="A project should not contain unused variables with external linkage" id="AUTOSAR-M0_1_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_3" desc="A project should not contain unused variables with internal linkage" id="AUTOSAR-M0_1_3-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_4" desc="A project shall not contain non-volatile POD variables having only one use" id="AUTOSAR-M0_1_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_8" desc="All non-empty functions with void return type shall have external side effect(s)" id="AUTOSAR-M0_1_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_8" desc="Functions with void return type shall not be empty" id="AUTOSAR-M0_1_8-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_1_9" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="AUTOSAR-M0_1_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_2_1" desc="An object shall not be assigned to an overlapping object" id="AUTOSAR-M0_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_2_1" desc="An object shall not be assigned to an overlapping object" id="AUTOSAR-M0_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Do not subtract two pointers that do not address elements of the same array" id="AUTOSAR-M0_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid overflow when writing to a buffer" id="AUTOSAR-M0_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Do not compare two unrelated pointers" id="AUTOSAR-M0_3_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-M0_3_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid division by zero" id="AUTOSAR-M0_3_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid null pointer dereferencing" id="AUTOSAR-M0_3_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid overflow due to reading a not zero terminated string" id="AUTOSAR-M0_3_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid buffer overflow due to defining incorrect format limits" id="AUTOSAR-M0_3_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Avoid overflow when reading from a buffer" id="AUTOSAR-M0_3_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_1" desc="Do not check for null after dereferencing" id="AUTOSAR-M0_3_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_3_2" desc="If a function returns error information, then that error information shall be tested" id="AUTOSAR-M0_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M0_4_2" desc="Use of floating-point arithmetic shall be documented" id="AUTOSAR-M0_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M10_1_1" desc="Classes should not be derived from virtual bases" id="AUTOSAR-M10_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M10_1_2" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="AUTOSAR-M10_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M10_1_3" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="AUTOSAR-M10_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M10_2_1" desc="All accessible entity names within a multiple inheritance hierarchy should be unique" id="AUTOSAR-M10_2_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M10_3_3" desc="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="AUTOSAR-M10_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M11_0_1" desc="Member data in non-POD types shall be private" id="AUTOSAR-M11_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M12_1_1" desc="Do not use dynamic type of an object under construction" id="AUTOSAR-M12_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M12_1_1" desc="Do not use dynamic type of an object under destruction" id="AUTOSAR-M12_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M14_5_3" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="AUTOSAR-M14_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M14_6_1" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="AUTOSAR-M14_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_0_3" desc="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="AUTOSAR-M15_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_1_1" desc="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="AUTOSAR-M15_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_1_2" desc="NULL shall not be thrown explicitly" id="AUTOSAR-M15_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_1_3" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="AUTOSAR-M15_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_1" desc="Exceptions shall be raised only after start-up and before termination of the program" id="AUTOSAR-M15_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_3" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="AUTOSAR-M15_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_4" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-M15_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_4" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-M15_3_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_6" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="AUTOSAR-M15_3_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M15_3_7" desc="Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last" id="AUTOSAR-M15_3_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_1" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="AUTOSAR-M16_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_2" desc="Macros shall not be #define'd or #undef'd within a block" id="AUTOSAR-M16_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_5" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="AUTOSAR-M16_0_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_6" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="AUTOSAR-M16_0_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_7" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="AUTOSAR-M16_0_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_0_8" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="AUTOSAR-M16_0_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_1_1" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="AUTOSAR-M16_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_1_2" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="AUTOSAR-M16_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_2_3" desc="Use multiple include guards" id="AUTOSAR-M16_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_3_1" desc="There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition" id="AUTOSAR-M16_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M16_3_2" desc="The # and ## preprocessor operators should not be used" id="AUTOSAR-M16_3_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M17_0_2" desc="The names of standard library macros and objects shall not be reused" id="AUTOSAR-M17_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M17_0_3" desc="The names of standard library functions shall not be overridden" id="AUTOSAR-M17_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M17_0_5" desc="The facilities provided by &lt;setjmp.h> should not be used" id="AUTOSAR-M17_0_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M17_0_5" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="AUTOSAR-M17_0_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_3" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_3" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_3" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_3" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_4" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="AUTOSAR-M18_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_4" desc="The time handling functions and macros of the library &lt;time.h> shall not be used" id="AUTOSAR-M18_0_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_4" desc="The types defined in the library &lt;time.h> shall not be used" id="AUTOSAR-M18_0_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_0_5" desc="The unbounded functions of library &lt;cstring> shall not be used" id="AUTOSAR-M18_0_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_2_1" desc="The macro offsetof, in library stddef.h, shall not be used" id="AUTOSAR-M18_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_7_1" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="AUTOSAR-M18_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M18_7_1" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="AUTOSAR-M18_7_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M19_3_1" desc="The error indicator 'errno' shall not be used" id="AUTOSAR-M19_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M27_0_1" desc="The input/output library stdio.h shall not be used" id="AUTOSAR-M27_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_10_1" desc="Different identifiers shall be typographically unambiguous" id="AUTOSAR-M2_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_13_2" desc="Octal constants (other than zero) shall not be used" id="AUTOSAR-M2_13_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_13_2" desc="Octal escape sequences shall not be used" id="AUTOSAR-M2_13_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_13_3" desc="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="AUTOSAR-M2_13_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_13_4" desc="Literal suffixes shall use uppercase rather than lowercase letters" id="AUTOSAR-M2_13_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M2_7_1" desc="The character sequence /* shall not be used within a C-style comment" id="AUTOSAR-M2_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_1_2" desc="Always declare functions at file scope" id="AUTOSAR-M3_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_2_1" desc="All declarations of an object or function shall have compatible types" id="AUTOSAR-M3_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_2_2" desc="The One Definition Rule shall not be violated" id="AUTOSAR-M3_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_2_3" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="AUTOSAR-M3_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_2_4" desc="An identifier with external linkage shall have no more then one external definition" id="AUTOSAR-M3_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_2_4" desc="An identifier with external linkage shall have external definition" id="AUTOSAR-M3_2_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_3_2" desc="If a function has internal linkage then all re-declarations shall include the 'static' storage class specifier" id="AUTOSAR-M3_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_4_1" desc="Declare variables as locally as possible" id="AUTOSAR-M3_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_4_1" desc="Non-const objects with internal linkage should be defined at function scope if they are only accessed from within a single function" id="AUTOSAR-M3_4_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_9_1" desc="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="AUTOSAR-M3_9_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M3_9_3" desc="The underlying bit representations of floating-point values shall not be used" id="AUTOSAR-M3_9_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M4_10_1" desc="NULL shall not be used as an integer value" id="AUTOSAR-M4_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M4_10_2" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="AUTOSAR-M4_10_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M4_5_1" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="AUTOSAR-M4_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M4_5_3" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="AUTOSAR-M4_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_10" desc="If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="AUTOSAR-M5_0_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_11" desc="The plain char type shall be used only for the storage and use of character values" id="AUTOSAR-M5_0_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_12" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="AUTOSAR-M5_0_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_14" desc="The first operand of a conditional-operator shall have type bool" id="AUTOSAR-M5_0_14-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_15" desc="Array indexing shall be the only allowed form of pointer arithmetic" id="AUTOSAR-M5_0_15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_16" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-M5_0_16-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_16" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="AUTOSAR-M5_0_16-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_17" desc="Do not subtract two pointers that do not address elements of the same array" id="AUTOSAR-M5_0_17-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_18" desc="Do not compare two unrelated pointers" id="AUTOSAR-M5_0_18-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="Use parenthesis for the right-hand operand of an assignment operator when it contains an assignment expression" id="AUTOSAR-M5_0_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="No parentheses are required for the operand of a unary operator" id="AUTOSAR-M5_0_2-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="Use parentheses unless all operators in the expression are the same" id="AUTOSAR-M5_0_2-e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_20" desc="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="AUTOSAR-M5_0_20-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_21" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="AUTOSAR-M5_0_21-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_4" desc="Avoid implicit conversions between signed and unsigned integer types" id="AUTOSAR-M5_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_5" desc="There shall be no implicit conversions from integral to floating type" id="AUTOSAR-M5_0_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_5" desc="Avoid implicit conversions from floating to integral type" id="AUTOSAR-M5_0_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_6" desc="Avoid implicit integral conversions from a wider to a narrower type" id="AUTOSAR-M5_0_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_6" desc="Avoid implicit conversions from wider to narrower floating type" id="AUTOSAR-M5_0_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_6" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="AUTOSAR-M5_0_6-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_7" desc="The value of a complex expression of floating type should not be cast to an integer type" id="AUTOSAR-M5_0_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_7" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_8" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_8" desc="The value of a complex expression of floating type should not be cast to a wider floating type" id="AUTOSAR-M5_0_8-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_0_9" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_14_1" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="AUTOSAR-M5_14_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_17_1" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="AUTOSAR-M5_17_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_18_1" desc="The comma operator shall not be used" id="AUTOSAR-M5_18_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_19_1" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="AUTOSAR-M5_19_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_19_1" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="AUTOSAR-M5_19_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_10" desc="The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression" id="AUTOSAR-M5_2_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_11" desc="Avoid overloading comma operator &quot;,&quot;" id="AUTOSAR-M5_2_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_11" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="AUTOSAR-M5_2_11-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_12" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="AUTOSAR-M5_2_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_2" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="AUTOSAR-M5_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_3" desc="Casts from a base class to a derived class should not be performed on polymorphic types" id="AUTOSAR-M5_2_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_6" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="AUTOSAR-M5_2_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_8" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="AUTOSAR-M5_2_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_2_9" desc="A cast should not convert a pointer type to an integral type" id="AUTOSAR-M5_2_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_1" desc="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="AUTOSAR-M5_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_2" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="AUTOSAR-M5_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_3" desc="The unary &amp; operator shall not be overloaded" id="AUTOSAR-M5_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_4" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="AUTOSAR-M5_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_4" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="AUTOSAR-M5_3_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_3_4" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="AUTOSAR-M5_3_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M5_8_1" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="AUTOSAR-M5_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_2_1" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="AUTOSAR-M6_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_2_2" desc="Floating-point expressions shall not be tested for equality or inequality" id="AUTOSAR-M6_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_2_3" desc="A null statement shall occur on a line by itself or be followed by a comment" id="AUTOSAR-M6_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_3_1" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="AUTOSAR-M6_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_1" desc="'if' and 'else' should be followed by a compound statement" id="AUTOSAR-M6_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_2" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="AUTOSAR-M6_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_3" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="AUTOSAR-M6_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_3" desc="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="AUTOSAR-M6_4_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_3" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="AUTOSAR-M6_4_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_3" desc="Every switch statement shall have at least one case clause" id="AUTOSAR-M6_4_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_3" desc="A switch expression shall not represent a value that is effectively Boolean" id="AUTOSAR-M6_4_3-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_4" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="AUTOSAR-M6_4_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_5" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="AUTOSAR-M6_4_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_6" desc="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="AUTOSAR-M6_4_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_4_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="AUTOSAR-M6_4_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_5_2" desc="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" id="AUTOSAR-M6_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_5_3" desc="Do not modify for loop counter within a body of the loop" id="AUTOSAR-M6_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_5_4" desc="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="AUTOSAR-M6_5_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_5_5" desc="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="AUTOSAR-M6_5_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_5_6" desc="A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" id="AUTOSAR-M6_5_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_6_1" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="AUTOSAR-M6_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_6_2" desc="The goto statement shall jump to a label declared later in the same function body" id="AUTOSAR-M6_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M6_6_3" desc="The continue statement shall only be used within a well formed for loop" id="AUTOSAR-M6_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_1_2" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="AUTOSAR-M7_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_1_2" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="AUTOSAR-M7_1_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_1_2" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-M7_1_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_3_1" desc="The global namespace shall only contain main() and namespace declarations" id="AUTOSAR-M7_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_3_2" desc="The identifier main shall not be used for a function other than the global function main" id="AUTOSAR-M7_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_3_3" desc="There shall be no unnamed namespaces in header files" id="AUTOSAR-M7_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_3_4" desc="using-directives shall not be used" id="AUTOSAR-M7_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_3_6" desc="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="AUTOSAR-M7_3_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_4_1" desc="All usage of assembler shall be documented" id="AUTOSAR-M7_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_4_2" desc="Assembler instructions shall only be introduced using the asm declaration" id="AUTOSAR-M7_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_4_3" desc="Assembly language shall be encapsulated and isolated in C/C++ functions" id="AUTOSAR-M7_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_5_1" desc="The address of an object with automatic storage shall not be returned from a function" id="AUTOSAR-M7_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M7_5_2" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="AUTOSAR-M7_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_0_1" desc="Each variable should be declared in a separate declaration statement" id="AUTOSAR-M8_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_3_1" desc="Do not redefine an inherited virtual function with a different default parameter value" id="AUTOSAR-M8_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_4_2" desc="The identifiers used in the declaration and definition of a function shall be identical" id="AUTOSAR-M8_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_4_4" desc="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="AUTOSAR-M8_4_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_5_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="AUTOSAR-M8_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_5_2" desc="Arrays shall not be partially initialized" id="AUTOSAR-M8_5_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M8_5_2" desc="The non-zero initialization of structures requires an explicit initializer for each element" id="AUTOSAR-M8_5_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M9_3_1" desc="Const member functions shall not return non-const pointers or references to class-data" id="AUTOSAR-M9_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M9_3_3" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="AUTOSAR-M9_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="AUTOSAR-M9_6_4" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="AUTOSAR-M9_6_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass incorrect values to library functions" id="BD-API-BADPARAM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass negative values to functions expecting non-negative arguments" id="BD-API-NEGPARAM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass incorrect values to ctype.h library functions" id="BD-API-CTYPE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not pass 0 value as a size argument to the realloc function" id="BD-API-REALLOC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Do not check for a non-negative value after passing as a non-negative argument" id="BD-API-REVNEGPARAM" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="BD-API-STRSIZE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-API" desc="Validate values passed to library functions" id="BD-API-VALPARAM" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not access iterator out of range" id="BD-CO-ITOUT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="BD-CO-STRMOD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not pass empty container iterators to std algorithms as destinations" id="BD-CO-EMPCON" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not compare iterators from different containers" id="BD-CO-ITINVCOMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-CO" desc="Do not modify container while iterating over it" id="BD-CO-ITMOD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-MISC" desc="Always close transactions" id="BD-MISC-TRANS" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-MISC" desc="Prevent calling unsafe functions (custom rule)" id="BD-MISC-DC" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always catch exceptions" id="BD-PB-EXCEPT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid signed integer overflows" id="BD-PB-INTUB" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not modify string literals" id="BD-PB-MODSTR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not read the value of a non-active union field" id="BD-PB-NAUNF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid use before initialization" id="BD-PB-NOTINIT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Atomic objects shall be properly initialized before being accessed" id="BD-PB-NOTINITAT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid null pointer dereferencing" id="BD-PB-NP" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid buffer overflow due to defining incorrect format limits" id="BD-PB-OVERFFMT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow due to reading a not zero terminated string" id="BD-PB-OVERFNZT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow when reading from a buffer" id="BD-PB-OVERFRD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overflow when writing to a buffer" id="BD-PB-OVERFWR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid overwriting method parameters" id="BD-PB-POVR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not point to a wrapped object that has been freed" id="BD-PB-WRAPESC" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid division by zero" id="BD-PB-ZERO" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid accessing arrays out of bounds" id="BD-PB-ARRAY" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" id="BD-PB-ARRPTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid incorrect shift operations" id="BD-PB-BADSHIFT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Use the correct byte ordering when transferring data between systems" id="BD-PB-BYTEORD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid conditions that always evaluate to the same value" id="BD-PB-CC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Consistently check the returned value of non-void functions" id="BD-PB-CHECKRET" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always check the returned value of non-void function" id="BD-PB-CHECKRETGEN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not check for null after dereferencing" id="BD-PB-DEREF" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not modify the alignment of objects by calling realloc()" id="BD-PB-DNMPTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="BD-PB-EOFCOMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly use errno value" id="BD-PB-ERRNO" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define exit handlers" id="BD-PB-EXITHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Reset strings on fgets() or fgetws() failure" id="BD-PB-FGETS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Only use values for fsetpos() that are returned from fgetpos()" id="BD-PB-FSETPOS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid infinite recursion" id="BD-PB-INFREC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid data loss when converting between integer types" id="BD-PB-INTDL" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="BD-PB-INVENV" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="BD-PB-INVRET" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use an object after its lifetime has ended" id="BD-PB-LIFETIME" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="BD-PB-MCCSTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid calls to memory-setting functions that can be optimized out by the compiler" id="BD-PB-MEMOPT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define new handlers" id="BD-PB-NEWHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid throwing exceptions from functions that are declared not to throw" id="BD-PB-NOEXCEPT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Declare non-returning functions with the attribute that specifies that they do not return" id="BD-PB-NORETDECL" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Never return from functions that should not return" id="BD-PB-NORETURN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid accessing arrays and pointers out of bounds" id="BD-PB-OVERFARRAY" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="An object shall not be assigned or copied to an overlapping object" id="BD-PB-OVERLAP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not treat arrays polymorphically" id="BD-PB-POLARR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="BD-PB-PTRARR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not compare two unrelated pointers" id="BD-PB-PTRCMP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not subtract two pointers that do not address elements of the same array" id="BD-PB-PTRSUB" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="BD-PB-PTRVALUE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="BD-PB-PUTENV" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define signal handlers" id="BD-PB-SIGHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not return from a computational exception signal handler" id="BD-PB-SIGRETURN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="BD-PB-STREAMINOUT" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not subsequently use the argument to std::forward" id="BD-PB-SUBSEQFRWD" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not rely on the value of a moved-from object" id="BD-PB-SUBSEQMOVE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid switch with unreachable branches" id="BD-PB-SWITCH" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define terminate handlers" id="BD-PB-TERMHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Properly define unexpected handlers" id="BD-PB-UNEXPHAN" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use the ungetc function on a stream with the file position indicator zero" id="BD-PB-UNGETC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use dynamic type of an object under construction" id="BD-PB-VCTOR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use dynamic type of an object under destruction" id="BD-PB-VDTOR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure the size of the variable length array is in valid range" id="BD-PB-VLASIZE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="The same file shall not be opened for read and write access at the same time on different streams" id="BD-PB-WRRDSTR" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid writing to a stream which has been opened as read only" id="BD-PB-WRROS" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid integer overflows" id="BD-PB-INTOVERF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid value change when converting between integer types" id="BD-PB-INTVC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid wraparounds when performing arithmetic integer operations" id="BD-PB-INTWRAP" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure strings are zero terminated" id="BD-PB-NZTS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Ensure the output buffer is large enough when using path manipulation functions" id="BD-PB-PATHBUF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="A parameter shall be passed by reference if it can't be NULL" id="BD-PB-REFPARAM" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="BD-PB" desc="Always throw the created std::exception object" id="BD-PB-STDEXC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Suspicious setting of stream flags" id="BD-PB-STREAMFLAGS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Restore stream format" id="BD-PB-STREAMFMT" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Use macros for variable arguments correctly" id="BD-PB-VARARGS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid unused values" id="BD-PB-VOVR" sev="3">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="BD-PB" desc="Avoid unreachable methods" id="BD-PB-UCMETH" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Guarantee that container indices are within the valid range" id="BD-PB-VALRANGE" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="BD-PB-NANINF" sev="5">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-PB" desc="Do not use recursion" id="BD-PB-RECFUN" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Properly deallocate dynamically allocated resources" id="BD-RES-BADDEALLOC" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Ensure deallocation functions guarantee resource freeing" id="BD-RES-BADFREEF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not use resources that have been freed" id="BD-RES-FREE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Allocate sufficient memory to hold an object of a given type" id="BD-RES-INSUFMEM" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not free resources using invalid pointers" id="BD-RES-INVFREE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Ensure resources are freed" id="BD-RES-LEAKS" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-RES" desc="Avoid cyclic shared_ptr references" id="BD-RES-CSP" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-RES" desc="Do not create variables on the stack above the defined limits" id="BD-RES-STACKLIM" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid tainted data in array indexes" id="BD-SECURITY-ARRAY" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Prevent buffer overflows from tainted data" id="BD-SECURITY-BUFWRITE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against integer overflow/underflow from tainted data" id="BD-SECURITY-INTOVERF" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="BD-SECURITY-OVERFFMT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer read overflow from tainted data" id="BD-SECURITY-OVERFRD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid buffer write overflow from tainted data" id="BD-SECURITY-OVERFWR" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against command injection" id="BD-SECURITY-TDCMD" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid printing tainted data on the output console" id="BD-SECURITY-TDCONSOLE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against environment injection" id="BD-SECURITY-TDENV" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against file name injection" id="BD-SECURITY-TDFNAMES" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Exclude unsanitized user input from format strings" id="BD-SECURITY-TDINPUT" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Validate potentially tainted data before it is used in the controlling expression of a loop" id="BD-SECURITY-TDLOOP" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Protect against SQL injection" id="BD-SECURITY-TDSQL" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid passing unvalidated binary data to log methods" id="BD-SECURITY-LOG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Properly seed pseudorandom number generators" id="BD-SECURITY-RAND" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Sensitive data should be cleared before being deallocated" id="BD-SECURITY-SENSFREE" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Avoid passing sensitive data to functions that write to log files" id="BD-SECURITY-SENSLOG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="BD-SECURITY-TDALLOC" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-SECURITY" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="BD-SECURITY-XXEXRC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid double locking" id="BD-TRS-DLOCK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions when using fork and file descriptors" id="BD-TRS-FORKFILE" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not abandon unreleased locks" id="BD-TRS-LOCK" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not use global variable with different locks set" id="BD-TRS-MLOCK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not acquire locks in different order" id="BD-TRS-ORDER" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions while checking for the existence of a symbolic link" id="BD-TRS-SYMLINK" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not use blocking functions while holding a lock" id="BD-TRS-TSHL" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="BD-TRS-ARG" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Make const member functions thread-safe" id="BD-TRS-CMF" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Variable should be used in context of single critical section" id="BD-TRS-DIFCS" sev="2">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Avoid race conditions while accessing files" id="BD-TRS-FRC" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not join or detach a thread that was previously joined or detached" id="BD-TRS-JOINDETACH" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="The Standard Library function mtx_timedlock() shall not be invoked on a mutex that does not support timeout" id="BD-TRS-TIMEDLOCK" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Use locks to prevent race conditions when modifying bit fields" id="BD-TRS-BITLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not destroy another thread's mutex" id="BD-TRS-DSTRLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="Do not release a lock that has not been acquired" id="BD-TRS-REVLOCK" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="There shall be no data races between threads" id="BD-TRS-THRDR" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread synchronization object should not be destroyed by a thread" id="BD-TRS-THRDSTR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread synchronization object should not be initialized by a thread" id="BD-TRS-THRINIT" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread should not be created by another thread" id="BD-TRS-THRTHR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="BD-TRS" desc="A thread-specific storage should not be created by a thread" id="BD-TRS-THRTSS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CDD" desc="Avoid function duplication" id="CDD-DUPM" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CDD" desc="Avoid code duplication" id="CDD-DUPC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CDD" desc="Avoid duplication of #include directives" id="CDD-DUPI" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CDD" desc="Avoid string literal duplication" id="CDD-DUPS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API00" desc="The validity of parameters must be checked inside each function" id="CERT_C-API00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API01" desc="Avoid overflow when writing to a buffer" id="CERT_C-API01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API01-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API02" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API02" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-API02-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR01" desc="Do not call 'sizeof' on a pointer type" id="CERT_C-ARR01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR02" desc="Explicitly specify array bounds in array declarations with initializers" id="CERT_C-ARR02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR30" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR32" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-ARR32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR36" desc="Do not subtract two pointers that do not address elements of the same array" id="CERT_C-ARR36-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR36" desc="Do not compare two unrelated pointers" id="CERT_C-ARR36-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR37" desc="Pointer arithmetic shall not be applied to pointers that address variables of non-array type" id="CERT_C-ARR37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow when reading from a buffer" id="CERT_C-ARR38-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow when writing to a buffer" id="CERT_C-ARR38-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid buffer overflow due to defining incorrect format limits" id="CERT_C-ARR38-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-ARR38-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Pointer arithmetic should not be used" id="CERT_C-ARR39-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Do not add or subtract a scaled integer to a pointer" id="CERT_C-ARR39-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON01" desc="Do not abandon unreleased locks" id="CERT_C-CON01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON02" desc="Do not use the volatile keyword" id="CERT_C-CON02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON05" desc="Do not use blocking functions while holding a lock" id="CERT_C-CON05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON30" desc="Ensure resources are freed" id="CERT_C-CON30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not destroy another thread's mutex" id="CERT_C-CON31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not use resources that have been freed" id="CERT_C-CON31-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not free resources using invalid pointers" id="CERT_C-CON31-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON32" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-CON32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON33" desc="Avoid using thread-unsafe functions" id="CERT_C-CON33-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON34" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-CON34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON35" desc="Do not acquire locks in different order" id="CERT_C-CON35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON36" desc="Wrap functions that can spuriously wake up in a loop" id="CERT_C-CON36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON37" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-CON37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON38" desc="Use the 'cnd_signal()' function with a unique condition variable" id="CERT_C-CON38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON39" desc="Do not join or detach a thread that was previously joined or detached" id="CERT_C-CON39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON40" desc="Do not refer to an atomic variable twice in an expression" id="CERT_C-CON40-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON41" desc="Wrap functions that can fail spuriously in a loop" id="CERT_C-CON41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON43" desc="Do not use global variable with different locks set" id="CERT_C-CON43-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL00" desc="Declare local variable as const whenever possible" id="CERT_C-DCL00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL00" desc="Declare parameters as const whenever possible" id="CERT_C-DCL00-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL01" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="CERT_C-DCL01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL01" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="CERT_C-DCL01-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL02" desc="Use visually distinct identifiers" id="CERT_C-DCL02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL04" desc="Each variable should be declared in a separate declaration statement" id="CERT_C-DCL04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL05" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL06" desc="Use meaningful symbolic constants to represent literal values" id="CERT_C-DCL06-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL10" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL11-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL12" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="CERT_C-DCL12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL13-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL15" desc="Objects or functions with external linkage shall be declared in a header file" id="CERT_C-DCL15-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL16" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="CERT_C-DCL16-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL18" desc="Octal and hexadecimal escape sequences shall be terminated" id="CERT_C-DCL18-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL18" desc="Octal constants (other than zero) shall not be used" id="CERT_C-DCL18-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL19" desc="Declare variables as locally as possible" id="CERT_C-DCL19-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL20" desc="The number of arguments passed to a function shall match the number of parameters" id="CERT_C-DCL20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL22" desc="Avoid unused values" id="CERT_C-DCL22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be returned from a function" id="CERT_C-DCL30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="CERT_C-DCL30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL31" desc="All functions shall be declared before use" id="CERT_C-DCL31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL36" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="CERT_C-DCL36-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="Do not #define or #undef identifiers with names which start with underscore" id="CERT_C-DCL37-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL38" desc="The final member of a structure should not be an array of size '0' or '1'" id="CERT_C-DCL38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL39" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="CERT_C-DCL39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL40" desc="All declarations of an object or function shall have compatible types" id="CERT_C-DCL40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL40" desc="If objects or functions are declared more than once their types shall be compatible" id="CERT_C-DCL40-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL41" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="CERT_C-DCL41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-ENV01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-ENV01-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Avoid overflow when writing to a buffer" id="CERT_C-ENV01-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV02" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-ENV02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV30" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="CERT_C-ENV30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV31" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="CERT_C-ENV31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV32" desc="Properly define exit handlers" id="CERT_C-ENV32-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV33" desc="Do not call the 'system()' function from the 'stdlib.h' or 'cstdlib' library with an argument other than '0' (null pointer)" id="CERT_C-ENV33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV34" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="CERT_C-ENV34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR01" desc="The error indicator 'errno' shall not be used" id="CERT_C-ERR01-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR02" desc="The Standard Library input/output functions shall not be used" id="CERT_C-ERR02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR06" desc="Do not use assertions" id="CERT_C-ERR06-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR07" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-ERR07-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR07" desc="The library functions 'rewind', 'setbuf' and 'ctime' should not be used" id="CERT_C-ERR07-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR30" desc="Properly use errno value" id="CERT_C-ERR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR30" desc="Provide error handling for file opening errors right next to the call to fopen" id="CERT_C-ERR30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR32" desc="Properly use errno value" id="CERT_C-ERR32-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR33" desc="The value returned by a standard library function that may return an error should be used" id="CERT_C-ERR33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR33" desc="Always check the returned value of non-void function" id="CERT_C-ERR33-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR34" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-ERR34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP00" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="CERT_C-EXP00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP02" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="CERT_C-EXP02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP05" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP05-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP08" desc="Pointer arithmetic should not be used" id="CERT_C-EXP08-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP08" desc="Avoid accessing arrays out of bounds" id="CERT_C-EXP08-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_C-EXP10-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_C-EXP10-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_C-EXP10-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP14" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-EXP14-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP15" desc="Suspicious use of semicolon" id="CERT_C-EXP15-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP16" desc="Function address should not be compared to zero" id="CERT_C-EXP16-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP19" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="CERT_C-EXP19-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP20" desc="Avoid comparing values with TRUE macro/enum constant using equality operators (&quot;==&quot;, &quot;!=&quot;)" id="CERT_C-EXP20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP20" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="CERT_C-EXP20-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_C-EXP30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_C-EXP30-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_C-EXP30-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP32" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP33" desc="Avoid use before initialization" id="CERT_C-EXP33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP34" desc="Avoid null pointer dereferencing" id="CERT_C-EXP34-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP35" desc="Do not modify objects with temporary lifetime" id="CERT_C-EXP35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP36" desc="Do not cast pointers into more strictly aligned pointer types" id="CERT_C-EXP36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CERT_C-EXP37-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="CERT_C-EXP37-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Functions shall always have visible prototype at the function call" id="CERT_C-EXP37-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="There shall be no implicit conversions from integral to floating type" id="CERT_C-EXP39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="A cast should not be performed between a pointer to object type and a different pointer to object type" id="CERT_C-EXP39-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid accessing arrays and pointers out of bounds" id="CERT_C-EXP39-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="CERT_C-EXP39-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer read overflow from tainted data" id="CERT_C-EXP39-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer write overflow from tainted data" id="CERT_C-EXP39-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP40" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP42" desc="Don't memcpy or memcmp non-PODs" id="CERT_C-EXP42-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP43" desc="The restrict type qualifier shall not be used" id="CERT_C-EXP43-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP44" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="CERT_C-EXP44-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP44" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="CERT_C-EXP44-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP45" desc="Assignment operators shall not be used in conditions without brackets" id="CERT_C-EXP45-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP45" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="CERT_C-EXP45-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP46" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="CERT_C-EXP46-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP47" desc="Do not call va_arg with an argument of the incorrect type" id="CERT_C-EXP47-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO01" desc="Don't use chmod(), chown(), chgrp()" id="CERT_C-FIO01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO01" desc="Usage of functions prone to race is not allowed" id="CERT_C-FIO01-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO21" desc="Usage of functions prone to race is not allowed" id="CERT_C-FIO21-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO22" desc="Ensure resources are freed" id="CERT_C-FIO22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO24" desc="Avoid race conditions while accessing files" id="CERT_C-FIO24-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="CERT_C-FIO30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable" id="CERT_C-FIO30-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Never use unfiltered data from an untrusted user as the format parameter" id="CERT_C-FIO30-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO32" desc="Protect against file name injection" id="CERT_C-FIO32-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO34" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="CERT_C-FIO34-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO37" desc="Avoid accessing arrays out of bounds" id="CERT_C-FIO37-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO38" desc="A pointer to a FILE object shall not be dereferenced" id="CERT_C-FIO38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO39" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="CERT_C-FIO39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO40" desc="Reset strings on fgets() or fgetws() failure" id="CERT_C-FIO40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators" id="CERT_C-FIO41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls" id="CERT_C-FIO41-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO42" desc="Ensure resources are freed" id="CERT_C-FIO42-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO44" desc="Only use values for fsetpos() that are returned from fgetpos()" id="CERT_C-FIO44-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO45" desc="Avoid race conditions while accessing files" id="CERT_C-FIO45-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO46" desc="Do not use resources that have been freed" id="CERT_C-FIO46-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-FIO47-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP00" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP02" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid division by zero" id="CERT_C-FLP03-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP03-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions from narrower to wider floating type" id="CERT_C-FLP03-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP03-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP06" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP06" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP30" desc="Do not use floating point variables as loop counters" id="CERT_C-FLP30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP32" desc="Validate values passed to library functions" id="CERT_C-FLP32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP34" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP34" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP34-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP36" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP36" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP37" desc="Do not use object representations to compare floating-point values" id="CERT_C-FLP37-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT02" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="CERT_C-INT02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT02" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-INT02-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Protect against integer overflow/underflow from tainted data" id="CERT_C-INT04-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Avoid buffer read overflow from tainted data" id="CERT_C-INT04-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Avoid buffer write overflow from tainted data" id="CERT_C-INT04-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT05" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-INT05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT07" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-INT07-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT07" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="CERT_C-INT07-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid data loss when converting between integer types" id="CERT_C-INT08-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid signed integer overflows" id="CERT_C-INT08-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid value change when converting between integer types" id="CERT_C-INT08-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid wraparounds when performing arithmetic integer operations" id="CERT_C-INT08-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT09" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="CERT_C-INT09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT10" desc="The operands of the remainder operator '%' should be of unsigned integer types" id="CERT_C-INT10-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT12" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="CERT_C-INT12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT13" desc="Use bitwise operators only on unsigned operands" id="CERT_C-INT13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT15" desc="Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" id="CERT_C-INT15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT16" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="CERT_C-INT16-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="CERT_C-INT18-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="CERT_C-INT18-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="CERT_C-INT18-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Avoid wraparounds when performing arithmetic integer operations" id="CERT_C-INT30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT30-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="CERT_C-INT31-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="CERT_C-INT31-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="CERT_C-INT31-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="CERT_C-INT31-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="CERT_C-INT31-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="CERT_C-INT31-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="CERT_C-INT31-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="CERT_C-INT31-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The second and third operands of the ternary operator shall have the same essential type category" id="CERT_C-INT31-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="CERT_C-INT31-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="CERT_C-INT31-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="CERT_C-INT31-n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Avoid data loss when converting between integer types" id="CERT_C-INT31-o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Avoid value change when converting between integer types" id="CERT_C-INT31-p" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Avoid signed integer overflows" id="CERT_C-INT32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT32-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT32-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT33" desc="Avoid division by zero" id="CERT_C-INT33-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT34" desc="Avoid incorrect shift operations" id="CERT_C-INT34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT35" desc="Use correct integer precisions when checking the right hand operand of the shift operator" id="CERT_C-INT35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT36" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CERT_C-INT36-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not use resources that have been freed" id="CERT_C-MEM00-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Ensure resources are freed" id="CERT_C-MEM00-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Do not use resources that have been freed" id="CERT_C-MEM01-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to an expression that points to deallocated memory" id="CERT_C-MEM01-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to global or member variable that points to deallocated memory" id="CERT_C-MEM01-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to parameter or local variable that points to deallocated memory" id="CERT_C-MEM01-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately" id="CERT_C-MEM02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately into a pointer to the allocated type" id="CERT_C-MEM02-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM03" desc="Sensitive data should be cleared before being deallocated" id="CERT_C-MEM03-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM04" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM04-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM05" desc="Do not use recursion" id="CERT_C-MEM05-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM05" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-MEM05-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM07" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM07-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM12" desc="Ensure resources are freed" id="CERT_C-MEM12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM30" desc="Do not use resources that have been freed" id="CERT_C-MEM30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM31" desc="Ensure resources are freed" id="CERT_C-MEM31-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM33" desc="Allocate structures containing a flexible array member dynamically" id="CERT_C-MEM33-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM33" desc="Do not copy instances of structures containing a flexible array member" id="CERT_C-MEM33-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM34" desc="Do not free resources using invalid pointers" id="CERT_C-MEM34-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM35" desc="Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function" id="CERT_C-MEM35-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM36" desc="Do not modify the alignment of objects by calling realloc()" id="CERT_C-MEM36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC01" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="CERT_C-MSC01-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC01" desc="The final clause of a switch statement shall be the default clause" id="CERT_C-MSC01-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C-style comment" id="CERT_C-MSC04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence // shall not be used within a C-style comment" id="CERT_C-MSC04-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C++-style comment" id="CERT_C-MSC04-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="Line-splicing shall not be used in // comments" id="CERT_C-MSC04-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC06" desc="Avoid calls to memory-setting functions that can be optimized out by the compiler" id="CERT_C-MSC06-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC07-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC07-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC07-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC07-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC07-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC07-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC07-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="Avoid switch with unreachable branches" id="CERT_C-MSC07-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="Avoid unreachable methods" id="CERT_C-MSC07-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC09" desc="Only use characters defined in the ISO C standard" id="CERT_C-MSC09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC11" desc="Assert liberally to document internal assumptions and invariants" id="CERT_C-MSC11-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC12-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC12-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC12-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC12-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC12-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC12-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid switch with unreachable branches" id="CERT_C-MSC12-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid unreachable methods" id="CERT_C-MSC12-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid conditions that always evaluate to the same value" id="CERT_C-MSC12-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="CERT_C-MSC12-k" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC13" desc="Avoid unnecessary local variables" id="CERT_C-MSC13-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC14" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC14-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC14" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="CERT_C-MSC14-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC15" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC15-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC15" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="CERT_C-MSC15-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC17" desc="Missing break statement between cases in a switch statement" id="CERT_C-MSC17-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC19" desc="Avoid accessing arrays out of bounds" id="CERT_C-MSC19-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC19" desc="Avoid null pointer dereferencing" id="CERT_C-MSC19-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC22" desc="The facilities provided by &lt;setjmp.h> should not be used" id="CERT_C-MSC22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-MSC24-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-MSC24-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-MSC24-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-MSC24-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC30" desc="Do not use the rand() function for generating pseudorandom numbers" id="CERT_C-MSC30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC32" desc="Properly seed pseudorandom number generators" id="CERT_C-MSC32-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC33" desc="The 'asctime()' and 'asctime_r()' functions should not be used" id="CERT_C-MSC33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC37" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="CERT_C-MSC37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC38" desc="A function-like macro shall not be invoked without all of its arguments" id="CERT_C-MSC38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC39" desc="Use macros for variable arguments correctly" id="CERT_C-MSC39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC40" desc="An inline definition of a function with external linkage shall not contain definitions and uses of static objects" id="CERT_C-MSC40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC41" desc="Do not hard code string literals" id="CERT_C-MSC41-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-POS30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="The values returned by functions 'read' and 'readlink' shall be used" id="CERT_C-POS30-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="Use of possibly not null-terminated string with functions expecting null-terminated string" id="CERT_C-POS30-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS33" desc="Avoid using the 'vfork()' function" id="CERT_C-POS33-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS34" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-POS34-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS34" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="CERT_C-POS34-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS35" desc="Avoid race conditions while checking for the existence of a symbolic link" id="CERT_C-POS35-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS36" desc="Observe correct revocation order while relinquishing privileges" id="CERT_C-POS36-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS37" desc="Ensure that privilege relinquishment is successful" id="CERT_C-POS37-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS38" desc="Avoid race conditions when using fork and file descriptors" id="CERT_C-POS38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS39" desc="Use the correct byte ordering when transferring data between systems" id="CERT_C-POS39-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS44" desc="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="CERT_C-POS44-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS47" desc="The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument" id="CERT_C-POS47-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS48" desc="Do not destroy another thread's mutex" id="CERT_C-POS48-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS48" desc="Do not release a lock that has not been acquired" id="CERT_C-POS48-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS49" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-POS49-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS50" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-POS50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS51" desc="Do not acquire locks in different order" id="CERT_C-POS51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS52" desc="Do not use blocking functions while holding a lock" id="CERT_C-POS52-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS53" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="CERT_C-POS53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS54" desc="The value returned by a POSIX library function that may return an error should be used" id="CERT_C-POS54-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE00" desc="A function should be used in preference to a function-like macro" id="CERT_C-PRE00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE01" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="CERT_C-PRE01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE02" desc="Enclose in parentheses whole definition of a function-like macro" id="CERT_C-PRE02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE06" desc="Use multiple include guards" id="CERT_C-PRE06-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE07" desc="Trigraphs shall not be used" id="CERT_C-PRE07-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE30" desc="Avoid token concatenation that may produce universal character names" id="CERT_C-PRE30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Assertions should not contain assignments, increment, or decrement operators" id="CERT_C-PRE31-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Assertions should not contain function calls nor function-like macro calls" id="CERT_C-PRE31-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Avoid side effects in arguments to unsafe macros" id="CERT_C-PRE31-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE32" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="CERT_C-PRE32-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG00" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG00-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG01" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG02" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG30" desc="Properly define signal handlers" id="CERT_C-SIG30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG31" desc="Properly define signal handlers" id="CERT_C-SIG31-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG34" desc="Properly define signal handlers" id="CERT_C-SIG34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG35" desc="Do not return from a computational exception signal handler" id="CERT_C-SIG35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR00" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR00-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against command injection" id="CERT_C-STR02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against file name injection" id="CERT_C-STR02-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against SQL injection" id="CERT_C-STR02-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR03" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR03-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR04" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR05" desc="A string literal shall not be modified" id="CERT_C-STR05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR07" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-STR07-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR09" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="CERT_C-STR09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR10" desc="Narrow and wide string literals shall not be concatenated" id="CERT_C-STR10-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR11" desc="Do not specify the bound of a character array initialized with a string literal" id="CERT_C-STR11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR30" desc="A string literal shall not be modified" id="CERT_C-STR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR30" desc="Do not modify string literals" id="CERT_C-STR30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid accessing arrays out of bounds" id="CERT_C-STR31-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid overflow when writing to a buffer" id="CERT_C-STR31-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Prevent buffer overflows from tainted data" id="CERT_C-STR31-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid buffer write overflow from tainted data" id="CERT_C-STR31-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-STR31-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR32" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR32-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="Cast characters to unsigned char before assignment to larger integer sizes" id="CERT_C-STR34-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="An expressions of the 'signed char' type should not be used as an array index" id="CERT_C-STR34-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="Cast characters to unsigned char before converting to larger integer sizes" id="CERT_C-STR34-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR37" desc="Do not pass incorrect values to ctype.h library functions" id="CERT_C-STR37-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR38" desc="Do not confuse narrow and wide character strings and functions" id="CERT_C-STR38-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-WIN00" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CERT_C-WIN00-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-WIN30" desc="Ensure resources are freed" id="CERT_C-WIN30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON50" desc="Do not destroy another thread's mutex" id="CERT_CPP-CON50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON51" desc="Do not call lock() directly on a mutex" id="CERT_CPP-CON51-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON52" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_CPP-CON52-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON53" desc="Do not acquire locks in different order" id="CERT_CPP-CON53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON54" desc="Wrap functions that can spuriously wake up in a loop" id="CERT_CPP-CON54-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON55" desc="Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable" id="CERT_CPP-CON55-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CON56" desc="Avoid double locking" id="CERT_CPP-CON56-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR50" desc="Guarantee that container indices are within the valid range" id="CERT_CPP-CTR50-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR51" desc="Do not modify container while iterating over it" id="CERT_CPP-CTR51-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR52" desc="Do not pass empty container iterators to std algorithms as destinations" id="CERT_CPP-CTR52-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR53" desc="Do not use an iterator range that isn't really a range" id="CERT_CPP-CTR53-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR53" desc="Do not compare iterators from different containers" id="CERT_CPP-CTR53-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR54" desc="Do not compare iterators from different containers" id="CERT_CPP-CTR54-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR54" desc="Do not compare two unrelated pointers" id="CERT_CPP-CTR54-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR54" desc="Do not subtract two pointers that do not address elements of the same array" id="CERT_CPP-CTR54-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR55" desc="Do not add or subtract a constant with a value greater than one from an iterator" id="CERT_CPP-CTR55-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR56" desc="Don't treat arrays polymorphically" id="CERT_CPP-CTR56-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR56" desc="A pointer to an array of derived class objects should not be converted to a base class pointer" id="CERT_CPP-CTR56-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR56" desc="Do not treat arrays polymorphically" id="CERT_CPP-CTR56-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR57" desc="For associative containers never use comparison function returning true for equal values" id="CERT_CPP-CTR57-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-CTR58" desc="Make predicates const pure functions" id="CERT_CPP-CTR58-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL50" desc="Functions shall not be defined with a variable number of arguments" id="CERT_CPP-DCL50-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="Do not #define or #undef identifiers with names which start with underscore" id="CERT_CPP-DCL51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="Do not redefine reserved words" id="CERT_CPP-DCL51-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="Do not #define nor #undef identifier 'defined'" id="CERT_CPP-DCL51-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused" id="CERT_CPP-DCL51-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="CERT_CPP-DCL51-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="CERT_CPP-DCL51-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL52" desc="Never qualify a reference type with 'const' or 'volatile'" id="CERT_CPP-DCL52-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL53" desc="Parameter names in function declarations should not be enclosed in parentheses" id="CERT_CPP-DCL53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL53" desc="Local variable names in variable declarations should not be enclosed in parentheses" id="CERT_CPP-DCL53-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL53" desc="Avoid function declarations that are syntactically ambiguous" id="CERT_CPP-DCL53-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL54" desc="Always provide new and delete together" id="CERT_CPP-DCL54-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL55" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="CERT_CPP-DCL55-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL56" desc="Avoid initialization order problems across translation units by replacing non-local static objects with local static objects" id="CERT_CPP-DCL56-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL57" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="CERT_CPP-DCL57-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL57" desc="Always catch exceptions" id="CERT_CPP-DCL57-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL58" desc="Do not modify the standard namespaces 'std' and 'posix'" id="CERT_CPP-DCL58-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL59" desc="There shall be no unnamed namespaces in header files" id="CERT_CPP-DCL59-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-DCL60" desc="The One Definition Rule shall not be violated" id="CERT_CPP-DCL60-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="CERT_CPP-ERR50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="CERT_CPP-ERR50-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Do not throw from within destructor" id="CERT_CPP-ERR50-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="CERT_CPP-ERR50-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="CERT_CPP-ERR50-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Exceptions shall be raised only after start-up and before termination of the program" id="CERT_CPP-ERR50-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="CERT_CPP-ERR50-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="CERT_CPP-ERR50-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="CERT_CPP-ERR50-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Always catch exceptions" id="CERT_CPP-ERR50-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Properly define exit handlers" id="CERT_CPP-ERR50-k" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_CPP-ERR50-l" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="Avoid throwing exceptions from functions that are declared not to throw" id="CERT_CPP-ERR50-m" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR50" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_CPP-ERR50-n" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR51" desc="Always catch exceptions" id="CERT_CPP-ERR51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR51" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="CERT_CPP-ERR51-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR52" desc="The facilities provided by &lt;setjmp.h> should not be used" id="CERT_CPP-ERR52-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR52" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="CERT_CPP-ERR52-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR53" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="CERT_CPP-ERR53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR54" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="CERT_CPP-ERR54-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR55" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="CERT_CPP-ERR55-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR56" desc="Always catch exceptions" id="CERT_CPP-ERR56-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR56" desc="Do not leave 'catch' blocks empty" id="CERT_CPP-ERR56-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR57" desc="Ensure resources are freed" id="CERT_CPP-ERR57-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR58" desc="Exceptions shall be raised only after start-up and before termination of the program" id="CERT_CPP-ERR58-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR59" desc="Do not throw an exception across execution boundaries" id="CERT_CPP-ERR59-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR60" desc="Exception objects must be nothrow copy constructible" id="CERT_CPP-ERR60-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR60" desc="An explicitly declared copy constructor for a class that inherits from 'std::exception' should have a non-throwing exception specification" id="CERT_CPP-ERR60-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR61" desc="A class type exception shall always be caught by reference" id="CERT_CPP-ERR61-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR61" desc="Throw by value, catch by reference" id="CERT_CPP-ERR61-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-ERR62" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_CPP-ERR62-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_CPP-EXP50-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_CPP-EXP50-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_CPP-EXP50-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_CPP-EXP50-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="CERT_CPP-EXP50-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function calls" id="CERT_CPP-EXP50-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP51" desc="Do not treat arrays polymorphically" id="CERT_CPP-EXP51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP52" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="CERT_CPP-EXP52-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP52" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="CERT_CPP-EXP52-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP52" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="CERT_CPP-EXP52-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP52" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="CERT_CPP-EXP52-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP52" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="CERT_CPP-EXP52-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP53" desc="Avoid use before initialization" id="CERT_CPP-EXP53-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP54" desc="Do not use resources that have been freed" id="CERT_CPP-EXP54-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP54" desc="The address of an object with automatic storage shall not be returned from a function" id="CERT_CPP-EXP54-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP54" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="CERT_CPP-EXP54-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP55" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_CPP-EXP55-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP56" desc="Do not call a function with a mismatched language linkage" id="CERT_CPP-EXP56-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP57" desc="Do not delete objects with incomplete class at the point of deletion" id="CERT_CPP-EXP57-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP57" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="CERT_CPP-EXP57-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP58" desc="Use macros for variable arguments correctly" id="CERT_CPP-EXP58-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP59" desc="Use offsetof() on valid types and members" id="CERT_CPP-EXP59-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP60" desc="Do not pass a nonstandard-layout type object across execution boundaries" id="CERT_CPP-EXP60-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP61" desc="Never return lambdas that capture local objects by reference" id="CERT_CPP-EXP61-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP61" desc="Never capture local objects from an outer lambda by reference" id="CERT_CPP-EXP61-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP61" desc="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="CERT_CPP-EXP61-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP62" desc="Do not compare objects of a class that may contain padding bits with C standard library functions" id="CERT_CPP-EXP62-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-EXP63" desc="Do not rely on the value of a moved-from object" id="CERT_CPP-EXP63-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-FIO50" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="CERT_CPP-FIO50-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-FIO51" desc="Ensure resources are freed" id="CERT_CPP-FIO51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-INT50" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="CERT_CPP-INT50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM50" desc="Do not use resources that have been freed" id="CERT_CPP-MEM50-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM51" desc="Use the same form in corresponding calls to new/malloc and delete/free" id="CERT_CPP-MEM51-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM51" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="CERT_CPP-MEM51-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM51" desc="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="CERT_CPP-MEM51-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM51" desc="Properly deallocate dynamically allocated resources" id="CERT_CPP-MEM51-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM52" desc="Check the return value of new" id="CERT_CPP-MEM52-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM52" desc="Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined" id="CERT_CPP-MEM52-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM53" desc="Do not invoke malloc/realloc for objects having constructors" id="CERT_CPP-MEM53-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM54" desc="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="CERT_CPP-MEM54-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM54" desc="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="CERT_CPP-MEM54-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM55" desc="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="CERT_CPP-MEM55-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM56" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="CERT_CPP-MEM56-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MEM57" desc="Avoid using the default operator 'new' for over-aligned types" id="CERT_CPP-MEM57-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MSC50" desc="Do not use the rand() function for generating pseudorandom numbers" id="CERT_CPP-MSC50-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MSC51" desc="Properly seed pseudorandom number generators" id="CERT_CPP-MSC51-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MSC52" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="CERT_CPP-MSC52-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MSC53" desc="Never return from functions that should not return" id="CERT_CPP-MSC53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-MSC54" desc="Properly define signal handlers" id="CERT_CPP-MSC54-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP50" desc="Avoid calling virtual functions from constructors" id="CERT_CPP-OOP50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP50" desc="Avoid calling virtual functions from destructors" id="CERT_CPP-OOP50-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP50" desc="Do not use dynamic type of an object under construction" id="CERT_CPP-OOP50-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP50" desc="Do not use dynamic type of an object under destruction" id="CERT_CPP-OOP50-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP51" desc="Do not slice derived objects" id="CERT_CPP-OOP51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP52" desc="Define a virtual destructor in classes used as base classes which have virtual functions" id="CERT_CPP-OOP52-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP53" desc="List members in an initialization list in the order in which they are declared" id="CERT_CPP-OOP53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP54" desc="Check for assignment to self in operator=" id="CERT_CPP-OOP54-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP55" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="CERT_CPP-OOP55-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP56" desc="Properly define terminate handlers" id="CERT_CPP-OOP56-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP56" desc="Properly define unexpected handlers" id="CERT_CPP-OOP56-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP56" desc="Properly define new handlers" id="CERT_CPP-OOP56-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP57" desc="Do not initialize objects with a non-trivial class type using C standard library functions" id="CERT_CPP-OOP57-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP57" desc="Do not compare objects of nonstandard-layout class type with C standard library functions" id="CERT_CPP-OOP57-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-OOP58" desc="Copy operations must not mutate the source object" id="CERT_CPP-OOP58-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR50" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_CPP-STR50-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR50" desc="Avoid overflow when writing to a buffer" id="CERT_CPP-STR50-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR50" desc="Prevent buffer overflows from tainted data" id="CERT_CPP-STR50-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR50" desc="Avoid buffer write overflow from tainted data" id="CERT_CPP-STR50-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR50" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="CERT_CPP-STR50-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR51" desc="Avoid null pointer dereferencing" id="CERT_CPP-STR51-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR52" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="CERT_CPP-STR52-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_CPP-STR53" desc="Guarantee that container indices are within the valid range" id="CERT_CPP-STR53-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CODSTA" desc="Local variables should not use the same names as member variables" id="CODSTA-44" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CODSTA" desc="Never convert consts to non-consts" id="CODSTA-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CODSTA-CPP" desc="Constructors allowing for conversion should be made explicit" id="CODSTA-CPP-04" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CODSTA-CPP" desc="Do not use user-defined conversion functions" id="CODSTA-CPP-05" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CODSTA-CPP" desc="Declare at least one constructor to prevent the compiler from doing so" id="CODSTA-CPP-19" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CODSTA-CPP" desc="Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type" id="CODSTA-CPP-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CODSTA-CPP" desc="Avoid returning handles to class data from member functions" id="CODSTA-CPP-06" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="COMMENT" desc="Line-splicing shall not be used in // comments" id="COMMENT-13" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="Prefer C++ style comment" id="COMMENT-01" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="COMMENT" desc="Provide copyright information" id="COMMENT-02" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="COMMENT" desc="Every source file will be documented with an introductory comment that provides information on the file" id="COMMENT-03" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="COMMENT" desc="Document functions in comments that precede function definitions" id="COMMENT-04" sev="3">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="COMMENT" desc="Document functions in comments that precede function declarations" id="COMMENT-04_b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="COMMENT" desc="Each variable declaration should be commented" id="COMMENT-05" sev="3">
               <Stats authTot="21;" total="21"/>
            </Rule>
            <Rule cat="COMMENT" desc="Each typedef should be commented" id="COMMENT-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="Each enumeration value should be commented" id="COMMENT-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="Each structure member variable should be commented" id="COMMENT-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="All usage of assembler shall be documented" id="COMMENT-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="Use of floating-point arithmetic shall be documented" id="COMMENT-10" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="COMMENT" desc="The character sequence // shall not be used within a C-style comment" id="COMMENT-11" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="The character sequence /* shall not be used within a C++-style comment" id="COMMENT-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="COMMENT" desc="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" id="COMMENT-14" sev="3">
               <Stats authTot="33;" total="33"/>
            </Rule>
            <Rule cat="COMMENT" desc="Function parameters and return type should be documented in a comment that precedes the function declaration" id="COMMENT-14_b" sev="3">
               <Stats authTot="32;" total="32"/>
            </Rule>
            <Rule cat="COMMENT" desc="Every function declaration should have a proper documentation" id="COMMENT-14_c" sev="3">
               <Stats authTot="55;" total="55"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid buffer overflow due to defining incorrect format limits" id="CWE-119-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid overflow when reading from a buffer" id="CWE-119-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid overflow when writing to a buffer" id="CWE-119-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid tainted data in array indexes" id="CWE-119-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Prevent buffer overflows from tainted data" id="CWE-119-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid buffer read overflow from tainted data" id="CWE-119-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid buffer write overflow from tainted data" id="CWE-119-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid accessing arrays out of bounds" id="CWE-119-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-119-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Suspicious use of 'strcpy' without checking size of source buffer" id="CWE-119-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-119" desc="Ensure the output buffer is large enough when using path manipulation functions" id="CWE-119-k" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-125" desc="Avoid overflow when reading from a buffer" id="CWE-125-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-125" desc="Avoid buffer read overflow from tainted data" id="CWE-125-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-125" desc="Avoid accessing arrays out of bounds" id="CWE-125-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-125" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-125-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Avoid signed integer overflows" id="CWE-190-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Avoid wraparounds when performing arithmetic integer operations" id="CWE-190-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="CWE-190-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="CWE-190-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="CWE-190-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CWE-190-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CWE-190-f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CWE-190-g" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-190" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="CWE-190-i" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Avoid tainted data in array indexes" id="CWE-20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Protect against integer overflow/underflow from tainted data" id="CWE-20-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Protect against command injection" id="CWE-20-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Avoid printing tainted data on the output console" id="CWE-20-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Protect against environment injection" id="CWE-20-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Exclude unsanitized user input from format strings" id="CWE-20-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Protect against SQL injection" id="CWE-20-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Protect against file name injection" id="CWE-20-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Avoid passing unvalidated binary data to log methods" id="CWE-20-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-20" desc="Untrusted data is used as a loop boundary" id="CWE-20-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-200" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="CWE-200-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-22" desc="Protect against file name injection" id="CWE-22-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-269" desc="Observe correct revocation order while relinquishing privileges" id="CWE-269-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-269" desc="Ensure that privilege relinquishment is successful" id="CWE-269-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-287" desc="Do not use weak encryption functions" id="CWE-287-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-312" desc="Avoid passing sensitive data to functions that write to log files" id="CWE-312-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-326" desc="Do not use weak encryption functions" id="CWE-326-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-362" desc="Avoid race conditions when using fork and file descriptors" id="CWE-362-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-362" desc="Do not use global variable with different locks set" id="CWE-362-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-362" desc="Usage of functions prone to race is not allowed" id="CWE-362-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-362" desc="Avoid race conditions while accessing files" id="CWE-362-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-362" desc="Use locks to prevent race conditions when modifying bit fields" id="CWE-362-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-400" desc="Do not create variables on the stack above the defined limits" id="CWE-400-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-401" desc="Ensure resources are freed" id="CWE-401-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-415" desc="Do not use resources that have been freed" id="CWE-415-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-416" desc="Do not use resources that have been freed" id="CWE-416-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-416" desc="Do not point to a wrapped object that has been freed" id="CWE-416-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-416" desc="Freed memory shouldn't be accessed under any circumstances" id="CWE-416-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-426" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CWE-426-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-427" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CWE-427-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-476" desc="Avoid null pointer dereferencing" id="CWE-476-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-476" desc="Do not check for null after dereferencing" id="CWE-476-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-532" desc="Avoid passing sensitive data to functions that write to log files" id="CWE-532-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-59" desc="Avoid race conditions while checking for the existence of a symbolic link" id="CWE-59-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-611" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="CWE-611-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-617" desc="Do not use assertions" id="CWE-617-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-668" desc="Protect against file name injection" id="CWE-668-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="CWE-704-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CWE-704-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="CWE-704-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="CWE-704-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="CWE-704-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="An implicit conversion shall not be performed between pointer to void and an arithmetic type" id="CWE-704-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="CWE-704-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="CWE-704-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CWE-704-k" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CWE-704-l" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CWE-704-e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-704" desc="A conversion should not be performed from pointer to void into pointer to object" id="CWE-704-f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-732" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="CWE-732-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-732" desc="Call 'umask' before calling 'mkstemp'" id="CWE-732-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-77" desc="Protect against command injection" id="CWE-77-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-770" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="CWE-770-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-772" desc="Ensure resources are freed" id="CWE-772-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-772" desc="Define a virtual destructor in classes used as base classes which have virtual functions" id="CWE-772-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-78" desc="Protect against command injection" id="CWE-78-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Avoid buffer overflow due to defining incorrect format limits" id="CWE-787-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Avoid overflow when writing to a buffer" id="CWE-787-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Prevent buffer overflows from tainted data" id="CWE-787-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Avoid buffer write overflow from tainted data" id="CWE-787-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Avoid accessing arrays out of bounds" id="CWE-787-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-787-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-787" desc="Ensure the output buffer is large enough when using path manipulation functions" id="CWE-787-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-798" desc="Do not hard code string literals" id="CWE-798-a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-835" desc="Avoid infinite loops" id="CWE-835-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-843" desc="A cast should not be performed between a pointer to object type and a different pointer to object type" id="CWE-843-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-863" desc="Do not use 'cuserid' function" id="CWE-863-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CWE-89" desc="Protect against SQL injection" id="CWE-89-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="EXCEPT" desc="Throw by value, catch by reference" id="EXCEPT-02" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Place an opening brace '{' on its own line" id="FORMAT-02" sev="3">
               <Stats authTot="15;" total="15"/>
            </Rule>
            <Rule cat="FORMAT" desc="Place a closing brace '}' on its own line" id="FORMAT-03" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="FORMAT" desc="Physical lines should be less than eighty characters" id="FORMAT-04" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="FORMAT" desc="The length of a macro should not exceed 10 lines" id="FORMAT-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Only one statement shall be allowed per line" id="FORMAT-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding assignment operators" id="FORMAT-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character following assignment operators" id="FORMAT-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding bitwise operators" id="FORMAT-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character following bitwise operators" id="FORMAT-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding and following bitwise operator '&amp;'" id="FORMAT-11" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character between a conditional statement keyword and its opening parenthesis" id="FORMAT-12" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a maximum of 1 ASCII space character following the opening parenthesis in conditional statements" id="FORMAT-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding ternary conditional operator" id="FORMAT-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character following ternary conditional operator" id="FORMAT-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding and following relational and equality operators" id="FORMAT-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be no white space following '.' or '->' operator" id="FORMAT-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be no white space preceding '.' or '->' operator" id="FORMAT-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character following all commas" id="FORMAT-19" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character following all semicolons" id="FORMAT-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There should be no space between a unary operator &quot;!&quot; or &quot;~&quot; and its operand" id="FORMAT-21" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There should be no space between a increment/decrement operator (++/--) and its operand" id="FORMAT-22" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be no white spaces between the 'return' statement or the 'sizeof' operator and the following opening parenthesis" id="FORMAT-23" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be no spaces after the opening '(' and before closing ')' parenthesis that enclose the operand of the 'return' statement or the 'sizeof' operator" id="FORMAT-24" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="FORMAT-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Parenthesis shall be used with the &quot;return&quot; statement" id="FORMAT-25_b" sev="3">
               <Stats authTot="12;" total="12"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be a single ASCII space character preceding and following logical operators" id="FORMAT-26" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Line should be indented by a multiple of four spaces" id="FORMAT-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="In a function definition, the return type of the function should be written on a separate line directly above the function name" id="FORMAT-28" sev="3">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="FORMAT" desc="Multiple variable declarations shall not be allowed on the same line" id="FORMAT-29" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="FORMAT" desc="Place left parenthesis directly after function name" id="FORMAT-30" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Separate logical tests in conditional expressions" id="FORMAT-31" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Each variable should be declared in a separate declaration statement" id="FORMAT-33" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="FORMAT" desc="Braces &quot;{}&quot; which enclose a block should be placed in the same column" id="FORMAT-34" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="FORMAT" desc="When declaring functions, the leading parenthesis and the first argument are to be written on the same line as the function name" id="FORMAT-35" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Sibling statement lines should be indented to the same level" id="FORMAT-36" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="First line in control statement body should be indented more than control statement keyword" id="FORMAT-37" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line" id="FORMAT-38" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="FORMAT-42" sev="3">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" id="FORMAT-43" sev="3">
               <Stats authTot="15;" total="15"/>
            </Rule>
            <Rule cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will not have an empty line after &quot;{&quot; nor before &quot;}&quot;" id="FORMAT-44" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There should be no space between a unary operator &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; and its operand" id="FORMAT-45" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There should be no space between an increment/decrement operator (++/--) and its operand in macro definition" id="FORMAT-46" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Place CV-qualifiers on the right hand side of the type they apply to" id="FORMAT-47_a" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="FORMAT" desc="CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" id="FORMAT-47_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Parameter names in function declarations should not be enclosed in parentheses" id="FORMAT-48" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Local variable names in variable declarations should not be enclosed in parentheses" id="FORMAT-49" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Use parentheses to indicate the precedence of operators in expressions" id="FORMAT-50" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" id="FORMAT-32" sev="4">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="FORMAT" desc="Sort #include directives in alphabetical order" id="FORMAT-39" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="Tabs that do not use ASCII spaces shall not be used" id="FORMAT-01" sev="5">
               <Stats authTot="160;" total="160"/>
            </Rule>
            <Rule cat="FORMAT" desc="White spaces after the opening square bracket '[' and before its closing square bracket ']' shall be used in consistent way" id="FORMAT-40" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="FORMAT" desc="There shall be no space between '[' opening square bracket and preceding token" id="FORMAT-41" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Explicit alignment specifiers in all declarations of an object with external linkage shall be the same" id="GLOBAL-ALIGNDECL" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="All declarations of an object or function shall have compatible types" id="GLOBAL-COMPATDECLS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="GLOBAL-CONDMUTEXVAR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="GLOBAL-EXCSPECDECL" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="An identifier with external linkage shall have external definition" id="GLOBAL-NOEXTERNDEF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="An inline function that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFINLINE" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="The One Definition Rule shall not be violated" id="GLOBAL-ONEDEFRULE" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A function template that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFTEMPL" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A type that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFTYPE" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="An identifier with external linkage shall have no more then one external definition" id="GLOBAL-ONEEXTERNDEF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="GLOBAL-ONEFILEDECL" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A project shall not contain non-volatile POD variables having only one use" id="GLOBAL-ONEUSEVAR" sev="3">
               <Stats authTot="9;" total="9"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Predicates shall not have persistent side effects" id="GLOBAL-PREDICATENOSE" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Identifiers that define functions with external linkage shall be unique" id="GLOBAL-REUSEDEXTFUN" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Identifiers that define objects with external linkage shall be unique" id="GLOBAL-REUSEDEXTVAR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="The identifier name of a non-member object with static storage duration shall not be reused within a namespace" id="GLOBAL-REUSEDQUALGLOBVAR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="The identifier name of a non-member static function shall not be reused within a namespace" id="GLOBAL-REUSEDQUALSTATFUN" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Identifiers that define functions with internal linkage shall be unique" id="GLOBAL-REUSEDSTATFUN" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Identifiers that define objects with internal linkage shall be unique" id="GLOBAL-REUSEDSTATVAR" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="All class templates, function templates, class template member functions and class template static members shall be instantiated at least one" id="GLOBAL-TEMPLNOINST" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A class, union or enum name (including qualification, if any) shall be a unique identifier" id="GLOBAL-UNIQUETYPE" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A tag name shall be a unique identifier" id="GLOBAL-UNIQUETYPEC" sev="3">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A typedef name (including qualification, if any) shall be a unique identifier" id="GLOBAL-UNIQUETYPEDEF" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A typedef name shall be a unique identifier" id="GLOBAL-UNIQUETYPEDEFC" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Every defined function with external linkage shall be used at least once" id="GLOBAL-UNUSEDFUNC" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A project shall not contain unused type declarations" id="GLOBAL-UNUSEDTYPE" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="GLOBAL" desc="There shall be no unused parameters (named or unnamed) in the set of parameters for a virtual function and all the functions that override it" id="GLOBAL-UNUSEDVIRTPARAM" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="GLOBAL-VIRTBASECLASS" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="GLOBAL-AVOIDEXTERN" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="GLOBAL" desc="A project should not contain unused variables with external linkage" id="GLOBAL-UNUSEDEXTVAR" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-10_1_1" desc="For multiple inheritance use virtual common base class" id="HICPP-10_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-10_2_1" desc="Each overriding virtual function shall be declared with the override or final specifier" id="HICPP-10_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-10_3_1" desc="Ensure that a derived class has at most one base class which is not an interface class" id="HICPP-10_3_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-11_1_1" desc="Avoid &quot;public&quot; data members" id="HICPP-11_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-11_1_1" desc="Avoid 'protected' data members" id="HICPP-11_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-11_2_1" desc="Avoid using the friend mechanism" id="HICPP-11_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_1_1" desc="Constructors allowing for conversion should be made explicit" id="HICPP-12_1_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_1_1" desc="User-conversion cast operators should be made explicit" id="HICPP-12_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_2_1" desc="Make destructors virtual in base classes" id="HICPP-12_2_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_3_1" desc="Write operator delete if you write operator new" id="HICPP-12_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_3_1" desc="Write operator delete[] if you write operator new[]" id="HICPP-12_3_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_1" desc="Do not use dynamic type of an object under construction" id="HICPP-12_4_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_1" desc="Do not use dynamic type of an object under destruction" id="HICPP-12_4_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_2" desc="All member variables should be initialized in constructor" id="HICPP-12_4_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_3" desc="Do not specify both an NSDMI and a member initializer in a constructor for the same non-static member" id="HICPP-12_4_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_4" desc="List members in an initialization list in the order in which they are declared" id="HICPP-12_4_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_4_5" desc="Use delegating constructors to reduce code duplication" id="HICPP-12_4_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_1" desc="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" id="HICPP-12_5_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_2" desc="Define special members as =default when the behavior is equivalent to the compiler's behavior" id="HICPP-12_5_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_3" desc="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="HICPP-12_5_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_4" desc="All user-provided move constructors and move assignment operators shall not exit with an exception" id="HICPP-12_5_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_6" desc="User-defined copy and move assignment operators should use user-defined no-throw swap function" id="HICPP-12_5_6-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_7" desc="Declare assignment operators with the ref-qualifier &amp;" id="HICPP-12_5_7-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-12_5_8" desc="The copy assignment operator shall be declared protected or private in an abstract class" id="HICPP-12_5_8-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_1_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="HICPP-13_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_1_2" desc="Avoid Overloading on Forwarding References" id="HICPP-13_1_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_1" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="HICPP-13_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_1" desc="Avoid overloading comma operator &quot;,&quot;" id="HICPP-13_2_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_2" desc="A relational operator shall return a boolean value" id="HICPP-13_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_2" desc="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="HICPP-13_2_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_3" desc="Declare binary arithmetic and bitwise operators as non-members" id="HICPP-13_2_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_4" desc="When overloading the subscript operator (operator[]), implement both const and non-const versions" id="HICPP-13_2_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-13_2_5" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="HICPP-13_2_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-14_1_1" desc="Do not use functions with variable numbers of arguments" id="HICPP-14_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-14_2_1" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="HICPP-14_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-14_2_2" desc="Overloaded function templates shall not be explicitly specialized" id="HICPP-14_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-14_2_3" desc="Declare 'extern' an explicitly instantiated template" id="HICPP-14_2_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_1_1" desc="Only use instances of std::exception for exceptions" id="HICPP-15_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_1_1" desc="Always throw the created std::exception object" id="HICPP-15_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_2_1" desc="Do not throw from within destructor" id="HICPP-15_2_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_3_1" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="HICPP-15_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_3_2" desc="Always catch exceptions" id="HICPP-15_3_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_3_2" desc="Avoid throwing exceptions from functions that are declared not to throw" id="HICPP-15_3_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-15_3_2" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="HICPP-15_3_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="Avoid using macro definitions" id="HICPP-16_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="HICPP-16_1_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="Use multiple include guards" id="HICPP-16_1_1-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="#error directive shall not be used" id="HICPP-16_1_1-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="The #pragma directive shall not be used" id="HICPP-16_1_1-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_1" desc="#undef shall not be used" id="HICPP-16_1_1-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_2" desc="Do not allow absolute or relative path names in #include statements" id="HICPP-16_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_2" desc="The \ character should not occur in a header file name" id="HICPP-16_1_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_3" desc="Match the filename in a #include directive to the one on the filesystem" id="HICPP-16_1_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_4" desc="Use &lt;> brackets for system and standard library headers. Use quotes for all other headers" id="HICPP-16_1_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-16_1_5" desc="Avoid duplication of #include directives" id="HICPP-16_1_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_1_1" desc="Avoid using vector&lt;bool>" id="HICPP-17_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_2_1" desc="The error indicator 'errno' shall not be used" id="HICPP-17_2_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_2_1" desc="Wrap use of the C Standard Library" id="HICPP-17_2_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_1" desc="Do not use std::move on objects declared with the const or const &amp; type" id="HICPP-17_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_2" desc="The 'std::forward' function should be used to forward forwarding references" id="HICPP-17_3_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_2" desc="The 'std::forward' function should only be used to forward forwarding references" id="HICPP-17_3_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_2" desc="The 'std::move' function should be used to forward rvalue references" id="HICPP-17_3_2-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_3" desc="Do not subsequently use the argument to std::forward" id="HICPP-17_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_4" desc="Do not create smart pointers of array type" id="HICPP-17_3_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_3_5" desc="Do not create an rvalue reference of std::array" id="HICPP-17_3_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_4_1" desc="Use const container calls when the result is immediately converted to a const iterator" id="HICPP-17_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_4_2" desc="Prefer 'std::make_shared' to the direct use of new" id="HICPP-17_4_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-17_5_1" desc="Follow remove-like algorithms by erase to remove elements from a container" id="HICPP-17_5_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_1_1" desc="Do not use platform-specific multi-threading facilities" id="HICPP-18_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_2_1" desc="Use high_integrity::thread in place of std::thread" id="HICPP-18_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_2_2" desc="Do not use global variable with different locks set" id="HICPP-18_2_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_2_2" desc="Make const member functions thread-safe" id="HICPP-18_2_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_2_3" desc="Do not share volatile data between threads" id="HICPP-18_2_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_2_4" desc="Use std::call_once rather than the Double-Checked Locking pattern" id="HICPP-18_2_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_1" desc="Avoid double locking" id="HICPP-18_3_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_2" desc="Do not acquire locks in different order" id="HICPP-18_3_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_3" desc="Do not use std::recursive_mutex" id="HICPP-18_3_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_4" desc="Only use std::unique lock when std::lock guard cannot be used" id="HICPP-18_3_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_5" desc="Do not access the members of std::mutex directly" id="HICPP-18_3_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_3_6" desc="Do not use relaxed atomics" id="HICPP-18_3_6-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-18_4_1" desc="Do not use std::condition_variable_any on a std::mutex" id="HICPP-18_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="Avoid conditions that always evaluate to the same value" id="HICPP-1_2_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="Avoid switch with unreachable branches" id="HICPP-1_2_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="HICPP-1_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="HICPP-1_2_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="HICPP-1_2_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code in switch statement" id="HICPP-1_2_1-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code in 'for' loop" id="HICPP-1_2_1-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="HICPP-1_2_1-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="HICPP-1_2_1-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_1" desc="Avoid unreachable methods" id="HICPP-1_2_1-h" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_2_2" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="HICPP-1_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_3_1" desc="Do not use the increment operator (++) on an operand of type 'bool'" id="HICPP-1_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_3_2" desc="The 'register' storage class specifier shall not be used" id="HICPP-1_3_2-a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_3_3" desc="The C library shall not be used" id="HICPP-1_3_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_3_4" desc="Do not use deprecated STL library features" id="HICPP-1_3_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-1_3_5" desc="Do not use throw exception specifications" id="HICPP-1_3_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_1_1" desc="Tabs that do not use ASCII spaces shall not be used" id="HICPP-2_1_1-a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_2_1" desc="Do not use the following digraphs: &lt;%, %>, &lt;:, :>, %:, %:%:" id="HICPP-2_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_2_1" desc="Trigraphs shall not be used" id="HICPP-2_2_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_3_1" desc="Prefer C++ style comment" id="HICPP-2_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_3_2" desc="Do not use comments to remove sections of code" id="HICPP-2_3_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_4_1" desc="Different identifiers shall be typographically unambiguous" id="HICPP-2_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_5_1" desc="String literals with different encoding prefixes shall not be concatenated" id="HICPP-2_5_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_5_2" desc="Octal constants (other than zero) shall not be used" id="HICPP-2_5_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-2_5_3" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="HICPP-2_5_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_1_1" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="HICPP-3_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_1_1" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="HICPP-3_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_1_1" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="HICPP-3_1_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_1_1" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="HICPP-3_1_1-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_1_1" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="HICPP-3_1_1-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_2_1" desc="Always declare functions at file scope" id="HICPP-3_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_3_1" desc="Do not use variables with static storage duration" id="HICPP-3_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_4_1" desc="The address of an object with automatic storage shall not be returned from a function" id="HICPP-3_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_4_2" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="HICPP-3_4_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_4_3" desc="Prefer smart pointers over raw local pointers" id="HICPP-3_4_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_4_3" desc="Do not call lock() directly on a mutex" id="HICPP-3_4_3-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_4_3" desc="Use RAII to prevent resource leaks" id="HICPP-3_4_3-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_5_1" desc="Do not subtract two pointers that do not address elements of the same array" id="HICPP-3_5_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_5_1" desc="Do not compare two unrelated pointers" id="HICPP-3_5_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_5_1" desc="Unions shall not be used" id="HICPP-3_5_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-3_5_1" desc="typedefs should be used in place of the basic types" id="HICPP-3_5_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_1_1" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="HICPP-4_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_1_1" desc="Do not pass an expression with array type to a function with a pointer or array type parameter" id="HICPP-4_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_1" desc="Apply the U suffix to literals used in a context that requires an unsigned integral expression" id="HICPP-4_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid signed integer overflows" id="HICPP-4_2_2-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid incorrect shift operations" id="HICPP-4_2_2-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid data loss when converting between integer types" id="HICPP-4_2_2-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="HICPP-4_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid explicit type conversions (casts)" id="HICPP-4_2_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="HICPP-4_2_2-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid wraparounds when performing arithmetic integer operations" id="HICPP-4_2_2-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Avoid value change when converting between integer types" id="HICPP-4_2_2-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_2_2" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="HICPP-4_2_2-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_3_1" desc="Avoid implicit conversions from wider to narrower floating type" id="HICPP-4_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_3_1" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="HICPP-4_3_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-4_4_1" desc="Avoid implicit conversions from floating to integral type" id="HICPP-4_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_1" desc="Avoid magic numbers" id="HICPP-5_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function arguments" id="HICPP-5_1_2-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="HICPP-5_1_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="HICPP-5_1_2-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="HICPP-5_1_2-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="HICPP-5_1_2-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Do not use more than one volatile between two adjacent sequence points" id="HICPP-5_1_2-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function calls" id="HICPP-5_1_2-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="The increment (++) and decrement (--) operators should not be mixed with other operators in an expression" id="HICPP-5_1_2-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="The comma operator shall not be used" id="HICPP-5_1_2-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_2" desc="The result of a built-in assignment operator should not be used" id="HICPP-5_1_2-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_3" desc="Use parentheses unless all operators in the expression are the same" id="HICPP-5_1_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_3" desc="The operands of a logical &amp;&amp; or || shall be primary-expressions" id="HICPP-5_1_3-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_4" desc="Do not capture variables implicitly in a lambda" id="HICPP-5_1_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_5" desc="Include a parameter list in every lambda expression" id="HICPP-5_1_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="HICPP-5_1_6-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="HICPP-5_1_6-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="HICPP-5_1_6-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="HICPP-5_1_6-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="HICPP-5_1_6-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_1_6" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="HICPP-5_1_6-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_2_1" desc="Avoid null pointer dereferencing" id="HICPP-5_2_1-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_2_1" desc="Avoid accessing arrays out of bounds" id="HICPP-5_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_2_1" desc="Avoid accessing arrays and pointers out of bounds" id="HICPP-5_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_2_2" desc="Functions shall not call themselves, either directly or indirectly" id="HICPP-5_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_2_2" desc="Do not use recursion" id="HICPP-5_2_2-b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_3_1" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="HICPP-5_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_3_2" desc="Do not use calloc, malloc, realloc and free functions" id="HICPP-5_3_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_3_3" desc="Properly deallocate dynamically allocated resources" id="HICPP-5_3_3-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_3_3" desc="Never provide brackets ([]) for delete when deallocating non-arrays" id="HICPP-5_3_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_3_3" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="HICPP-5_3_3-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_4_1" desc="C-style casts should not be used" id="HICPP-5_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_4_1" desc="Avoid using reinterpret_cast" id="HICPP-5_4_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_4_1" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="HICPP-5_4_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_4_2" desc="Do not cast an expression to an enumeration type" id="HICPP-5_4_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_4_3" desc="Down casting (casting from base to derived class) shall not be allowed" id="HICPP-5_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_5_1" desc="Avoid division by zero" id="HICPP-5_5_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_6_1" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="HICPP-5_6_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_7_1" desc="Floating-point expressions shall not be tested for equality or inequality" id="HICPP-5_7_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_7_2" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="HICPP-5_7_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-5_8_1" desc="The conditional operator should not be used as a sub-expression" id="HICPP-5_8_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_1" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="HICPP-6_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_1" desc="'if' and 'else' should be followed by a compound statement" id="HICPP-6_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_2" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="HICPP-6_1_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_2" desc="The final clause of a switch statement shall be the default clause" id="HICPP-6_1_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_3" desc="Every switch branch should be unconditionally terminated" id="HICPP-6_1_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_4" desc="Every switch statement will have at least two cases and a potential default" id="HICPP-6_1_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_1_4" desc="A switch expression shall not represent a value that is effectively Boolean" id="HICPP-6_1_4-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_2_1" desc="A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" id="HICPP-6_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_2_2" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="HICPP-6_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_2_3" desc="Do not modify for loop counter within a body of the loop" id="HICPP-6_2_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_2_4" desc="The third clause of a 'for' statement shall be well-formed" id="HICPP-6_2_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_3_1" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="HICPP-6_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_3_1" desc="The goto statement shall jump to a label declared later in the same function body" id="HICPP-6_3_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_3_1" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="HICPP-6_3_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_3_2" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="HICPP-6_3_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_4_1" desc="Declare variables as locally as possible" id="HICPP-6_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-6_4_1" desc="Postpone variable definitions as long as possible" id="HICPP-6_4_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_1" desc="Multiple variable declarations shall not be allowed on the same line" id="HICPP-7_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_1" desc="Each variable should be declared in a separate declaration statement" id="HICPP-7_1_1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_10" desc="Use static_assert for assertions involving compile time constants" id="HICPP-7_1_10-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_2" desc="Declare local variable as const whenever possible" id="HICPP-7_1_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_2" desc="Declare parameters as const whenever possible" id="HICPP-7_1_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_3" desc="Do not place type specifiers before non-type specifiers in a declaration" id="HICPP-7_1_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_4" desc="Place CV-qualifiers on the right hand side of the type they apply to" id="HICPP-7_1_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_5" desc="Do not inline large functions" id="HICPP-7_1_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_6" desc="The plain char type shall be used only for the storage and use of character values" id="HICPP-7_1_6-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_6" desc="Use class types or typedefs to abstract scalar quantities and standard integer types" id="HICPP-7_1_6-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_6" desc="Use class types or typedefs to abstract scalar quantities and standard integer types" id="HICPP-7_1_6-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_7" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="HICPP-7_1_7-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_8" desc="Use auto id = expr when declaring a variable that is the same type as the initializer function call" id="HICPP-7_1_8-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_1_9" desc="Do not explicitly specify the return type of a lambda" id="HICPP-7_1_9-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_2_1" desc="Use an explicit enumeration base and ensure that it is large enough to store all enumerators" id="HICPP-7_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_2_2" desc="Initialize all, only the first, or none of the enumerators in an enumeration" id="HICPP-7_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_3_1" desc="using-directives shall not be used" id="HICPP-7_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_4_1" desc="Do not use static keyword except inside functions and classes" id="HICPP-7_4_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_4_2" desc="An inline function that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_4_2" desc="A function template that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_4_2" desc="A type that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_4_3" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="HICPP-7_4_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-7_5_1" desc="The 'asm' declaration should not be used" id="HICPP-7_5_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_1_1" desc="The declaration should not contain more than one level of pointer indirection" id="HICPP-8_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_2_1" desc="The identifiers used in the declaration and definition of a function shall be identical" id="HICPP-8_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_2_2" desc="Avoid functions with more than 5 parameters" id="HICPP-8_2_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_2_3" desc="Pass small objects with a trivial copy constructor by value" id="HICPP-8_2_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_2_4" desc="Do not pass std::unique_ptr by const reference" id="HICPP-8_2_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_3_1" desc="Follow the Cyclomatic Complexity limit of 10" id="HICPP-8_3_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_3_3" desc="Do not use default arguments" id="HICPP-8_3_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_3_4" desc="Define =delete functions with parameters of type rvalue reference to const" id="HICPP-8_3_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_4_1" desc="Avoid use before initialization" id="HICPP-8_4_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_4_1" desc="Do not use resources that have been freed" id="HICPP-8_4_1-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_4_1" desc="All automatic variables shall have been assigned a value before being used" id="HICPP-8_4_1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-8_4_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="HICPP-8_4_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_1_1" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="HICPP-9_1_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_1_2" desc="Do not redefine an inherited virtual function with a different default parameter value" id="HICPP-9_1_2-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_1_3" desc="Const member functions shall not return non-const pointers or references to class-data" id="HICPP-9_1_3-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_1_4" desc="Public member functions shall not return non-const handles to private/protected class-data" id="HICPP-9_1_4-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_1_5" desc="Do not introduce virtual functions in a final class" id="HICPP-9_1_5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="HICPP-9_2_1" desc="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="HICPP-9_2_1-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="INIT" desc="All member variables should be initialized in constructor" id="INIT-06" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All functions shall have a cyclomatic complexity number of 20 or less" id="JSF-003" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Follow the Essential Complexity limit of 1" id="JSF-003_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Capital 'L' shall be used instead of lowercase 'l' to indicate long" id="JSF-014" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Ensure that array indices are within the bounds of the array" id="JSF-015" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The error indicator 'errno' shall not be used" id="JSF-017" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The macro 'offsetof', in library &lt;stddef.h>, shall not be used" id="JSF-018" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="'setlocale' function shall not be used" id="JSF-019" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="&lt;locale.h> shall not be used" id="JSF-019_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The 'setjmp' macro and the 'longjmp' function shall not be used" id="JSF-020" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The standard header file &lt;setjmp.h> shall not be used" id="JSF-020_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The standard header file &lt;signal.h> shall not be used" id="JSF-021" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="JSF-021_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The input/output library &lt;stdio.h> shall not be used" id="JSF-022" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="The library functions atof, atoi and atol from library &lt;stdlib.h> shall not be used" id="JSF-023" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="JSF-024" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="JSF-024_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The library function 'getenv' of &lt;stdlib.h> shall not be used" id="JSF-024_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="JSF-024_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The time handling functions of library &lt;time.h> shall not be used" id="JSF-025" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="JSF-026" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="The #if preprocessor directive should not be used" id="JSF-026_b" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="#error directive shall not be used" id="JSF-026_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The #pragma directive shall not be used" id="JSF-026_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="#undef shall not be used" id="JSF-026_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The #define pre-processor directive shall not be used to create inline macros" id="JSF-029" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="JSF" desc="The #define pre-processor directive shall not be used to define constant values" id="JSF-030" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="The #include directive shall use the &lt;filename.h> notation to include header files" id="JSF-033" sev="2">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="JSF" desc="User-specified C++ external identifiers should differ in the first 64 characters" id="JSF-046_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters" id="JSF-046_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters" id="JSF-046_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers for constant and enumerator values shall be lowercase" id="JSF-052" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot; " id="JSF-053.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The statements forming the body of a 'while', 'do...while', 'switch' or 'for' statement shall always be enclosed in braces" id="JSF-059_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The statements forming the body of an 'if', 'else if' or 'else' statement shall always be enclosed in braces" id="JSF-059_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Declare both private copy constructor and copy assignment operator at the same time" id="JSF-068" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Freed memory shall not be accessed under any circumstances" id="JSF-070.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Destructor shall not be called manually" id="JSF-070.1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Public and protected methods shall not be invoked by class constructor" id="JSF-071" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A class's virtual functions shall not be invoked from any of its constructors" id="JSF-071.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A class's virtual functions shall not be invoked from its destructor" id="JSF-071.1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All member variables shall be initialized in constructor" id="JSF-071_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A class's virtual functions shall not be invoked from any of its constructors" id="JSF-071_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Uninitialized nonstatic member variables shall not be used in base class constructors" id="JSF-071_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Uninitialized nonstatic member variables of nonvirtual base classes shall not be used in virtual base class constructors" id="JSF-071_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Possibly uninitialized nonstatic member variables of base classes shall not be used in base class constructors" id="JSF-071_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Members of the initialization list shall be listed in the order in which they are declared in the class" id="JSF-075" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors" id="JSF-076" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A copy constructor shall copy all data members and bases" id="JSF-077" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor" id="JSF-077.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All base classes with a virtual function shall define a virtual destructor" id="JSF-078" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Call fclose() on pointer member in destructor if the pointer was used to open a file" id="JSF-079" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Call delete on pointer members in destructors" id="JSF-079_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The assignment operator shall handle self-assignment correctly" id="JSF-081" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An assignment operator shall return a reference to *this" id="JSF-082" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An assignment operator shall assign all data members" id="JSF-083_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An assignment operator shall assign all data bases" id="JSF-083_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Multiple inheritance shall be limited to at most 1 protected implementation" id="JSF-088" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A stateful virtual base shall be explicitly declared in each derived class that accesses it" id="JSF-088.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Multiple inheritance shall not use any public implementations" id="JSF-088_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="JSF-089" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An inherited nonvirtual function shall not be redefined in a derived class" id="JSF-094" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Member functions declared in derived class shall not hide functions declared in base classes" id="JSF-094_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An inherited default parameter shall never be redefined" id="JSF-095" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Arrays shall not be treated polymorphically" id="JSF-096" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Arrays shall not be used in interfaces" id="JSF-097" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Neither operand of an equality operator (== or !=) shall be a pointer to a virtual member function" id="JSF-097.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Arrays shall not be used in private or protected methods" id="JSF-097_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Arrays shall not be used in global functions" id="JSF-097_c" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Arrays shall not be passed to functions as array/pointer parameters" id="JSF-097_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions which are called with array argument shall not be declared with pointer parameter" id="JSF-097_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions shall always be declared at file scope" id="JSF-107" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions with variable numbers of arguments shall not be used" id="JSF-108" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A function shall not return a pointer or reference to a non-static local object" id="JSF-111" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="JSF-111_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All exit points of value-returning functions shall be through return statements" id="JSF-114" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions shall not call themselves, either directly or indirectly" id="JSF-119" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Only valid C++ style comments (//) shall be used" id="JSF-126" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="Code that is not used (commented out) shall be deleted" id="JSF-127" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="JSF-135_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers declared in an inner local scope shall not hide identifiers declared in an outer local scope" id="JSF-135_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers declared in a local scope shall not hide identifiers declared in a class scope" id="JSF-135_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers declared in a class scope shall not hide identifiers declared in a global or namespace scope" id="JSF-135_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers declared in an inner class scope shall not hide identifiers declared in outer class scope" id="JSF-135_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="JSF-138_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="JSF-138_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The register storage class specifier shall not be used" id="JSF-140" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All automatic variables shall have been assigned a value before being used" id="JSF-142_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All variables shall be initialized before use" id="JSF-142_b" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" id="JSF-144" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="In an enumerator list, the '=' construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized" id="JSF-145" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The underlying bit representations of floating point numbers shall not be used in any way by the programmer" id="JSF-147" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Enumeration types shall be used instead of integer types (and constants) to select from a limited series of choices" id="JSF-148" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Octal constants (other than zero) shall not be used" id="JSF-149" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A string literal shall not be modified" id="JSF-151.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Multiple variable declarations shall not be allowed on the same line" id="JSF-152" sev="2">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="JSF" desc="Unions shall not be used" id="JSF-153" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="JSF-154" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All the members of a structure (or class) shall be named" id="JSF-156" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The right hand operand of a &amp;&amp; or || operator shall not contain side effects" id="JSF-157" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="JSF-158" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Operators ||, &amp;&amp; shall not be overloaded" id="JSF-159" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Operator unary &amp; shall not be overloaded" id="JSF-159_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="An assignment expression shall be used only as the expression in an expression statement" id="JSF-160" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Signed and unsigned values shall not be mixed in comparison operations" id="JSF-162_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Signed and unsigned values shall not be mixed in second and third operand of conditional operator" id="JSF-162_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Signed and unsigned values shall not be mixed in arithmetic operations" id="JSF-162_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Unsigned arithmetic shall not be used" id="JSF-163" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the left-hand operand" id="JSF-164" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="JSF-164.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The unary minus operator shall not be applied to an unsigned expression" id="JSF-165" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Don't assign the dividend of two integers to a floating-point type" id="JSF-167_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The comma operator shall not be used" id="JSF-168_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="More than 2 levels of pointer indirection shall not be used" id="JSF-170" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Relational operators shall not be applied to pointer types except where they point to the same array" id="JSF-171" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist" id="JSF-173" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The null pointer shall not be de-referenced" id="JSF-174_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The null pointer shall not be de-referenced" id="JSF-174_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="NULL identifier shall not be used; use plain 0 instead" id="JSF-175" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Down casting (casting from base to derived class) shall not be allowed" id="JSF-178" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A pointer to a virtual base class shall not be converted to a pointer to a derived class" id="JSF-179" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="JSF-180_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid implicit conversions from floating to integral type" id="JSF-180_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid implicit conversions from wider to narrower floating type" id="JSF-180_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid conversions of constant values to a narrower type" id="JSF-180_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid implicit conversions from signed to unsigned type" id="JSF-180_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="JSF-180_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="JSF-180_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Type casting from any type to or from pointers shall not be used" id="JSF-182" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Floating point numbers shall not implicitly be converted to integers" id="JSF-184_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="JSF-185" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code in 'else' block" id="JSF-186_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="JSF-186_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code in 'if', 'else', 'while' and 'for' block" id="JSF-186_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code in 'switch' statement" id="JSF-186_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code in 'for' loop" id="JSF-186_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="JSF-186_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There shall be no unreachable code after 'if' or 'switch' statement inside 'while', 'for' or 'do...while' loop" id="JSF-186_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Every defined function with internal linkage shall be used" id="JSF-186_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All non-null statements shall potentially have a side-effect" id="JSF-187" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The goto statement shall not be used" id="JSF-189" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The continue statement shall not be used" id="JSF-190" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The break statement shall not be used (except to terminate the cases of a switch statement)" id="JSF-191" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="JSF-191_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Every non-empty case clause in a switch statement shall be terminated with a break statement" id="JSF-193" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All switch statements that do not intend to test for every enumeration value shall contain a final default clause" id="JSF-194" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Floating point variables shall not be used as loop counters" id="JSF-197" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop" id="JSF-201" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Floating point variables shall not be tested for exact equality or inequality" id="JSF-202" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Evaluation of expressions shall not lead to overflow/underflow" id="JSF-203" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Evaluation of expressions shall not lead to overflow/underflow" id="JSF-203_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="JSF-204.1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Don't write code that depends on the order of evaluation of function arguments" id="JSF-204.1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="JSF-204.1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="JSF-204.1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="JSF-204.1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Do not use more than one volatile in one expression" id="JSF-204.1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Don't write code that depends on the order of evaluation of function calls" id="JSF-204.1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A single operation with side-effect shall only be used in the proper context" id="JSF-204_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A call of function with side-effect shall only be used in the proper context" id="JSF-204_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The second or third operand of a ternary operator '?:' shall not contain side effects" id="JSF-204_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The volatile keyword shall not be used" id="JSF-205" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Dynamic heap memory allocation shall not be used" id="JSF-206" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="C++ exceptions shall not be used" id="JSF-208" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="Typedefs that indicate size and signedness shall be used in place of the basic types" id="JSF-209" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Typedefs that indicate size and signedness shall be used in place of the basic types" id="JSF-209_b" sev="2">
               <Stats authTot="25;" total="25"/>
            </Rule>
            <Rule cat="JSF" desc="Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier" id="JSF-210.1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Algorithms shall not assume particular memory alignment" id="JSF-211" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="JSF-213_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Assuming that non-local static objects, in separate translation units, are initialized in a special order shall not be done" id="JSF-214" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)" id="JSF-001" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Only those characters specified in the C++ basic source character set will be used" id="JSF-009" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Values of character types will be restricted to a defined and documented subset of ISO 10646-1" id="JSF-010" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Trigraphs will not be used" id="JSF-011" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The following digraphs will not be used &lt;%, %>, &lt;:, :>, %:, %:%:" id="JSF-012" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Wide string literals (for example L&quot;abc&quot;) will not be used" id="JSF-013" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="#ifndef, #define and #endif will be used to prevent multiple inclusions of the same header file" id="JSF-027" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="JSF-028" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="JSF-028_b" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="The #define pre-processor directive will only be used as part of the technique to prevent multiple inclusions of the same header file" id="JSF-031" sev="3">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="JSF" desc="The #include pre-processor directive will only be used to include header (*.h) files" id="JSF-032" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="JSF" desc="A header file will contain a mechanism that prevents multiple inclusions of itself" id="JSF-035" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Header files (*.h) will not contain non-const variable definitions or function definitions" id="JSF-039_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Source lines will be kept to a length of 120 characters or less" id="JSF-041" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Each expression-statement will be on a separate line" id="JSF-042" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All indentations will be consistent" id="JSF-044" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers will not begin with the underscore character &quot;_&quot;" id="JSF-047" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="JSF" desc="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" id="JSF-048" sev="3">
               <Stats authTot="24;" total="24"/>
            </Rule>
            <Rule cat="JSF" desc="Begin class, struct, union, enum, and typedef names with an uppercase letter" id="JSF-050" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All letters contained in function and variable names will be composed entirely of lowercase letters" id="JSF-051" sev="3">
               <Stats authTot="19;" total="19"/>
            </Rule>
            <Rule cat="JSF" desc="Header files will always have a file name extension of &quot;.h&quot;" id="JSF-053" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="Implementation files will always have a file name extension of &quot;.cpp&quot;" id="JSF-054" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The public section of a class will be declared before the protected section and before the private section" id="JSF-057_a" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="JSF" desc="The protected section of a class will be declared before the private section" id="JSF-057_b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line" id="JSF-058" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="JSF-060_a" sev="3">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" id="JSF-060_b" sev="3">
               <Stats authTot="15;" total="15"/>
            </Rule>
            <Rule cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will not have an empty line after &quot;{&quot; nor before &quot;}&quot;" id="JSF-060_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="JSF-061" sev="3">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="JSF" desc="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" id="JSF-062" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="JSF" desc="There will be no white space following '.' or '->' operator" id="JSF-063_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There will be no white space preceding '.' or '->' operator" id="JSF-063_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There will be no space between a unary operator '!' or '~' and its operand" id="JSF-063_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There will be no space between a increment/decrement operator (++/--) and its operand" id="JSF-063_d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There will be no space between a unary operator '&amp;', '*', '+', '-' and its operand" id="JSF-063_e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="There should be no space between an increment/decrement operator (++/--) and its operand in macro definition" id="JSF-063_f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A member function that does not affect the state of an object will be declared const" id="JSF-069" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Initialization of nonstatic class members will be performed through the member initialization list rather than through assignment in the body of a constructor" id="JSF-074" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="When two operators are opposites (such as == and !=), both will be defined" id="JSF-085" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="When one of opposite operators (== and !=) is defined, the other should be defined too and one will be defined in terms of the other" id="JSF-085_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Namespaces will not be nested more than two levels deep" id="JSF-099" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All partial and explicit specializations for a template should be declared in the same file as the declaration of their primary template" id="JSF-104" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions with more than 7 arguments will not be used" id="JSF-110" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Functions will have a single exit point" id="JSF-113" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="If a function returns error information, then that error information will be tested" id="JSF-115" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Each variable declaration will be commented" id="JSF-132_a" sev="3">
               <Stats authTot="21;" total="21"/>
            </Rule>
            <Rule cat="JSF" desc="Each typedef will be commented" id="JSF-132_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Each enumeration value will be commented" id="JSF-132_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Each structure member variable will be commented" id="JSF-132_d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Every source file will be documented with an introductory comment that provides information on the file" id="JSF-133_a" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="JSF" desc="Every source file will contain copyright information" id="JSF-133_b" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="JSF" desc="External objects will not be declared in more than one file" id="JSF-139" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="External objects will not be declared in implementation files" id="JSF-139_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A class, structure, or enumeration will not be declared in the definition of its type" id="JSF-141" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Variables will not be introduced until they can be initialized with meaningful values" id="JSF-143" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid unused local variables" id="JSF-143_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Hexadecimal constants will be represented using all uppercase letters" id="JSF-150" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Numeric values in code will not be used; symbolic values will be used instead" id="JSF-151" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The implementation of integer division shall be documented" id="JSF-167" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A typedef will be used to simplify program syntax when declaring function pointers" id="JSF-176" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Redundant explicit casts will not be used" id="JSF-181_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid explicit cast from derived to a base class" id="JSF-181_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Labels will not be used, except in switch statements" id="JSF-188" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary" id="JSF-192" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A switch expression will not represent a Boolean value" id="JSF-195" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Every switch statement will have at least two cases and a potential default" id="JSF-196" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="JSF-198" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="JSF-199" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Null initialize or increment expressions in for loops will not be used; a while loop will be used instead" id="JSF-200" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Unencapsulated global data will be avoided" id="JSF-207" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="JSF" desc="A file should directly include only headers containing declarations and definitions needed to a compilation" id="JSF-037" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Tabs should be avoided" id="JSF-043" sev="4">
               <Stats authTot="160;" total="160"/>
            </Rule>
            <Rule cat="JSF" desc="Public data should only be used in structs, not in classes" id="JSF-067_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Protected data should only be used in structs, not in classes" id="JSF-067_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid using the friend mechanism" id="JSF-070" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Hierarchies should be based on abstract classes" id="JSF-087" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Every nonlocal name, except main(), should be placed in some namespace" id="JSF-098" sev="4">
               <Stats authTot="17;" total="17"/>
            </Rule>
            <Rule cat="JSF" desc="Don't write namespace usings in a header file or before an #include" id="JSF-100" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="In a class template with a dependent base, any name that may be found in that dependent base should be referred to using a qualifier" id="JSF-105" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A function definition should not be placed in a class specification" id="JSF-109" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Dereferenced local pointer initialized by new in function scope should not be returned" id="JSF-112" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="JSF-115_a" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Built-in-types should be passed by value unless you are modifying them" id="JSF-116" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Arguments should be passed by reference" id="JSF-117" sev="4">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="JSF" desc="An object should be passed as const reference if the function should not change the value of the object" id="JSF-117.1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor" id="JSF-117_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="JSF-118" sev="4">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="JSF" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="JSF-118_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Only functions with 1 or 2 statements should be considered candidates for inline functions" id="JSF-121" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Trivial accessor and mutator functions should be inlined" id="JSF-122" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Classes which have only getters/setters (accessors/mutators) are not allowed" id="JSF-123" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Trivial forwarding functions should be inlined" id="JSF-124" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Pass and return by reference when possible" id="JSF-125_a" sev="4">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="JSF" desc="Document functions in comments that precede function definitions" id="JSF-134" sev="4">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="JSF" desc="Document functions in comments that precede function declarations" id="JSF-134_b" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Objects should be defined at block scope if they are only accessed from within a single function" id="JSF-136_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Declarations of local variables should be at the smallest feasible scope" id="JSF-136_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="All declarations at file scope should be static where possible" id="JSF-137" sev="4">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="JSF" desc="Pointers to pointers should be avoided" id="JSF-169" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="User-defined conversion functions should be avoided" id="JSF-177" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Constructors allowing for conversion should be made explicit" id="JSF-177_b" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="JSF" desc="Every possible measure should be taken to avoid type casting" id="JSF-183" sev="4">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid using static_cast on pointers" id="JSF-183_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Avoid using reinterpret_cast" id="JSF-183_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Pointer arithmetic will not be used" id="JSF-215" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="JSF" desc="Consider using op= instead of stand-alone op" id="JSF-125_b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of blocks of code in a function" id="METRICS-03" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of function calls within function" id="METRICS-04" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Class inheritance level" id="METRICS-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of data member(s) per class should not exceed 15" id="METRICS-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of methods per class" id="METRICS-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of parameter(s) per method should not exceed 10" id="METRICS-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of private data member(s) per class" id="METRICS-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of private methods per class" id="METRICS-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of protected data member(s) per class" id="METRICS-11" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of protected methods per class" id="METRICS-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of public data member(s) per class" id="METRICS-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Number of public methods per class" id="METRICS-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid functions with more than 5 parameters" id="METRICS-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Macros should not use more than 5 parameters" id="METRICS-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Follow the Cyclomatic Complexity limit of 10" id="METRICS-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The percentage of comment lines versus the total number of module lines should be between 20 and 60" id="METRICS-19" sev="3">
               <Stats authTot="19;" total="19"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid too long functions (declarations and statements)" id="METRICS-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid too long functions (blocks)" id="METRICS-21" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid functions with over 75 lines of code" id="METRICS-22" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Nested block depth should not be higher than 5" id="METRICS-23" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)" id="METRICS-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Source lines will be kept to a length of 120 characters or less" id="METRICS-26" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="METRICS" desc="Functions with more than 7 parameters will not be used" id="METRICS-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Follow the Cyclomatic Complexity limit of 20" id="METRICS-28" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="No function should be longer than 60 lines of code" id="METRICS-30" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The assertion density of the code should average to a minimum of two assertions per function" id="METRICS-31" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="METRICS" desc="All functions with more than 20 lines should contain at least 2 assertions" id="METRICS-32" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="A global function should not be called from more than 5 different functions" id="METRICS-36" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="A function should not call more than 7 different functions" id="METRICS-37" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The number of statements within function should be in range 1 - 50" id="METRICS-38" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The value of VOCF metric for a function should not be higher than 4" id="METRICS-39" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Statements within function should not be nested deeper than 4 levels" id="METRICS-40" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The number of blocks of comments before and inside function to the number of statements in function should be > 0.2" id="METRICS-41" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Report the value of Halstead's delivered bugs (B) for a function" id="METRICS-43" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="The number of execution paths in a function should not be higher than 80" id="METRICS-44" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid functions with over 50 lines" id="METRICS-01" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid switch statements with many cases" id="METRICS-02" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid structs, unions, or classes with more than 20 fields" id="METRICS-17" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Avoid source files that are longer than 500 lines" id="METRICS-24" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Report Cyclomatic Complexity" id="METRICS-29" sev="5">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="METRICS" desc="Report Essential Complexity" id="METRICS-33" sev="5">
               <Stats authTot="22;" total="22"/>
            </Rule>
            <Rule cat="METRICS" desc="Follow the Essential Complexity limit of 4" id="METRICS-34" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Follow the Essential Complexity limit of 10" id="METRICS-35" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="METRICS" desc="Follow the Essential Complexity limit of 1" id="METRICS-42" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Only use characters defined in the ISO C standard" id="MISRA-005" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Values of character types shall be restricted to a defined and documented subset of ISO 10646-1" id="MISRA-006" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use wide string literals" id="MISRA-008" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" id="MISRA-013" sev="3">
               <Stats authTot="28;" total="28"/>
            </Rule>
            <Rule cat="MISRA" desc="Explicitly declare 'char' type as signed or unsigned" id="MISRA-014" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The underlying bit representations of floating point numbers shall not be used" id="MISRA-016" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="All functions shall be declared before use" id="MISRA-020" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="MISRA-024" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="External object should not be declared in more than one file" id="MISRA-027" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="External objects should not be declared in implementation files" id="MISRA-027_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The use of a tag shall agree with its declaration" id="MISRA-029" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="All automatic variables shall have been assigned a value before being used" id="MISRA-030" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="MISRA-038" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The comma operator shall not be used, except in the control expression of a for loop" id="MISRA-042" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="MISRA-043" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Avoid mixing arithmetic of different precisions in the same expression" id="MISRA-043_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="MISRA-043_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="MISRA-043_d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Redundant explicit cast to the same type is not allowed" id="MISRA-044" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use the volatile keyword" id="MISRA-046_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Assignment statements should not be nested within other assignment statements" id="MISRA-046_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="MISRA-048_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Don't cast the dividend of two integers to a floating-point type" id="MISRA-048_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="MISRA-048_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Avoid unintentionally discarding the remainder of integer division" id="MISRA-048_d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="A null statement shall only occur on a line by itself" id="MISRA-054" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use the break statement" id="MISRA-058" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use floating point variables as loop counters" id="MISRA-065" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use functions with variable numbers of arguments" id="MISRA-069" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call" id="MISRA-071_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Functions shall always have visible prototype at the function call" id="MISRA-071_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Provide none or all identifiers for function arguments" id="MISRA-073" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Provide expression for return statement of non-void functions" id="MISRA-083" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Avoid expressions in return statements of void functions" id="MISRA-084" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA-089" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Enclose in parentheses whole definition of a function-like macro" id="MISRA-096" sev="3">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA" desc="Use only non-ambiguous forms of defined pre-processor operator" id="MISRA-100" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Pointer arithmetic should not be used" id="MISRA-101" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="No more than 2 levels of pointer indirection should be used" id="MISRA-102" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use non-constant pointers to functions" id="MISRA-104" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="All the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type" id="MISRA-105" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The NULL pointer shall not be dereferenced" id="MISRA-107_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The NULL pointer shall not be dereferenced" id="MISRA-107_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="All members of structure or union should be fully specified" id="MISRA-108" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Unions shall not be used to access the sub-parts of larger data structure" id="MISRA-110" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="All the members of a structure (or class/union) shall be named" id="MISRA-113" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Standard library function names shall not be reused" id="MISRA-115" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="The 'setlocale' function should not be used" id="MISRA-121_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not include &lt;locale.h> header" id="MISRA-121_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRA-023" sev="4">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="MISRA" desc="Provisions should be made for appropriate run-time checking" id="MISRA-004_a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Provisions should be made for appropriate run-time checking" id="MISRA-004_b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_c" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_d" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Declare objects at function scope" id="MISRA-022" sev="5">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="MISRA" desc="The 'register' storage class specifier shall not be used" id="MISRA-028" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Document integer division" id="MISRA-041" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="MISRA-051" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="MISRA-051_b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA" desc="Do not use labels" id="MISRA-055" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2004" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="MISRA2004-13_1" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2004" desc="Floating-point expressions shall not be tested for equality or inequality" id="MISRA2004-13_3" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2004" desc="The controlling expression of a for statement shall not contain any objects of floating type" id="MISRA2004-13_4" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_aj" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Every defined function with internal linkage shall be used" id="MISRA2008-0_1_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Every defined function with external linkage shall be used" id="MISRA2008-0_1_10_b" sev="2">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no unused parameters (named or unnamed) in nonvirtual functions" id="MISRA2008-0_1_11" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no unused parameters (named or unnamed) in the set of parameters for a virtual function and all the functions that override it" id="MISRA2008-0_1_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code in 'else' block" id="MISRA2008-0_1_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="MISRA2008-0_1_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code in 'if/else/while/for' block" id="MISRA2008-0_1_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code in switch statement" id="MISRA2008-0_1_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code in 'for' loop" id="MISRA2008-0_1_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code after 'if' or 'switch' statement outside 'for/while/catch' block" id="MISRA2008-0_1_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unreachable code after 'if' or 'switch' statement inside 'while/for/catch' block" id="MISRA2008-0_1_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_aa" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_p" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_q" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_r" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_rz" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_s" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_sz" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_t" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_u" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_v" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_w" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_x" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_y" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_z" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unused variables" id="MISRA2008-0_1_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Eliminate unused private member variables" id="MISRA2008-0_1_3_c" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project should not contain unused variables with external linkage" id="MISRA2008-0_1_3_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project should not contain unused variables with internal linkage" id="MISRA2008-0_1_3_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain non-volatile POD variables having only one use" id="MISRA2008-0_1_4" sev="2">
               <Stats authTot="9;" total="9"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A project shall not contain unused type declarations" id="MISRA2008-0_1_5" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid unused values" id="MISRA2008-0_1_6" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="MISRA2008-0_1_7" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All functions with void return type shall have external side effect(s)" id="MISRA2008-0_1_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All functions with void return type shall have external side effect(s)" id="MISRA2008-0_1_8_b" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRA2008-0_1_9" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An object shall not be assigned to an overlapping object" id="MISRA2008-0_2_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An object shall not be assigned to an overlapping object" id="MISRA2008-0_2_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If a function generates error information, then that error information shall be tested" id="MISRA2008-0_3_2" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="MISRA2008-10_1_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An accessible base class shall not be both virtual and non-virtual in the same hierarchy" id="MISRA2008-10_1_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy" id="MISRA2008-10_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each overriding virtual function shall be declared with the virtual keyword" id="MISRA2008-10_3_2" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="MISRA2008-10_3_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Member data in non-POD class types shall be private" id="MISRA2008-11_0_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not use dynamic type of an object under construction" id="MISRA2008-12_1_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not use dynamic type of an object under destruction" id="MISRA2008-12_1_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="MISRA2008-12_1_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A copy constructor shall only initialize its base classes and the nonstatic members of the class of which it is a member" id="MISRA2008-12_8_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The copy assignment operator shall be declared protected or private in an abstract class" id="MISRA2008-12_8_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not declare non-member generic functions in associated namespaces" id="MISRA2008-14_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="MISRA2008-14_5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="MISRA2008-14_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="MISRA2008-14_6_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The function shall resolve to a function declared previously in the translation unit" id="MISRA2008-14_6_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All class templates, function templates, class template member functions and class template static members shall be instantiated at least one." id="MISRA2008-14_7_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="MISRA2008-14_7_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Overloaded function templates shall not be explicitly specialized" id="MISRA2008-14_8_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="MISRA2008-15_0_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="MISRA2008-15_1_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="NULL shall not be thrown explicitly" id="MISRA2008-15_1_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An empty throw (throw;) shall only be used in the compound statement of a catch handler" id="MISRA2008-15_1_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Exceptions shall be raised only after start-up and before termination of the program" id="MISRA2008-15_3_1" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases" id="MISRA2008-15_3_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_3_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_3_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A class type exception shall always be caught by reference" id="MISRA2008-15_3_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="MISRA2008-15_3_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last" id="MISRA2008-15_3_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="MISRA2008-15_4_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A class destructor shall not exit with an exception" id="MISRA2008-15_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="MISRA2008-15_5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid throwing exceptions from functions that are declared not to throw" id="MISRA2008-15_5_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="MISRA2008-15_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="MISRA2008-15_5_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not throw from within destructor" id="MISRA2008-15_5_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="MISRA2008-15_5_3_d" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="MISRA2008-15_5_3_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Exceptions shall be raised only after start-up and before termination of the program" id="MISRA2008-15_5_3_f" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_5_3_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="MISRA2008-15_5_3_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="MISRA2008-15_5_3_i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Always catch exceptions" id="MISRA2008-15_5_3_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Properly define exit handlers" id="MISRA2008-15_5_3_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid throwing exceptions from functions that are declared not to throw" id="MISRA2008-15_5_3_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="#include directives in a file shall only be preceded by other preprocessor directives or comments" id="MISRA2008-16_0_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Macros shall only be #define'd or #undef'd in the global namespace" id="MISRA2008-16_0_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="#undef shall not be used" id="MISRA2008-16_0_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Function-like macros shall not be defined" id="MISRA2008-16_0_4" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRA2008-16_0_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##" id="MISRA2008-16_0_6" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRA2008-16_0_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token" id="MISRA2008-16_0_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="MISRA2008-16_1_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRA2008-16_1_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid using macro definitions" id="MISRA2008-16_2_1_a" sev="2">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="MISRA2008-16_2_1_c" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_d" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_e" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="#error directive shall not be used" id="MISRA2008-16_2_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #pragma directive shall not be used" id="MISRA2008-16_2_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="#undef shall not be used" id="MISRA2008-16_2_1_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="C++ macros shall only be used for: include guards, type qualifiers, or storage class specifiers" id="MISRA2008-16_2_2" sev="2">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Include guards shall be provided" id="MISRA2008-16_2_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="MISRA2008-16_2_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA2008-16_2_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be at most one occurrence of the # or ## operators in a single macro definition" id="MISRA2008-16_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The names of standard library macros and objects shall not be reused" id="MISRA2008-17_0_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The names of standard library functions shall not be overridden" id="MISRA2008-17_0_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The setjmp macro and the longjmp function shall not be used" id="MISRA2008-17_0_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2008-17_0_5_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The C library shall not be used" id="MISRA2008-18_0_1" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The library functions atof, atoi and atol from library &lt;cstdlib> shall not be used" id="MISRA2008-18_0_2" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The library function 'getenv' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The standard header file &lt;ctime> shall not be used" id="MISRA2008-18_0_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The time handling functions and macros of library &lt;ctime> shall not be used" id="MISRA2008-18_0_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The types defined in the library &lt;ctime> shall not be used" id="MISRA2008-18_0_4_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The unbounded functions of library &lt;cstring> shall not be used" id="MISRA2008-18_0_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The macro offsetof shall not be used" id="MISRA2008-18_2_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Dynamic heap memory allocation shall not be used" id="MISRA2008-18_4_1" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The standard header file &lt;csignal> shall not be used" id="MISRA2008-18_7_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The signal handling facilities of &lt;csignal> shall not be used" id="MISRA2008-18_7_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The error indicator errno shall not be used" id="MISRA2008-19_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The stream input/output library &lt;cstdio> shall not be used" id="MISRA2008-27_0_1" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Different identifiers shall be typographically unambiguous" id="MISRA2008-2_10_1" sev="2">
               <Stats authTot="13;" total="13"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2008-2_10_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2008-2_10_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A typedef name (including qualification, if any) shall be a unique identifier" id="MISRA2008-2_10_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A class, union or enum name (including qualification, if any) shall be a unique identifier" id="MISRA2008-2_10_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used" id="MISRA2008-2_13_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Octal constants (other than zero) shall not be used" id="MISRA2008-2_13_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Octal escape sequences (other than &quot;\0&quot;) shall not be used" id="MISRA2008-2_13_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="MISRA2008-2_13_3" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Literal suffixes shall be upper case" id="MISRA2008-2_13_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Narrow and wide string literals shall not be concatenated" id="MISRA2008-2_13_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Trigraphs shall not be used" id="MISRA2008-2_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The character sequence /* shall not be used within a C-style comment" id="MISRA2008-2_7_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Sections of code shall not be &quot;commented out&quot; using C-style comments" id="MISRA2008-2_7_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="It shall be possible to include any header file in multiple translation units without violating the One Definition Rule" id="MISRA2008-3_1_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Functions shall not be declared at block scope" id="MISRA2008-3_1_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization" id="MISRA2008-3_1_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All declarations of an object or function shall have compatible types" id="MISRA2008-3_2_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The One Definition Rule shall not be violated" id="MISRA2008-3_2_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="MISRA2008-3_2_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2008-3_2_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2008-3_2_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRA2008-3_3_1" sev="2">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If a function has internal linkage then all re-declarations shall include the static storage class specifier" id="MISRA2008-3_3_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" id="MISRA2008-3_4_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" id="MISRA2008-3_4_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="MISRA2008-3_9_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The underlying bit representations of floating-point values shall not be used" id="MISRA2008-3_9_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="NULL shall not be used as an integer value" id="MISRA2008-4_10_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="MISRA2008-4_10_2" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator" id="MISRA2008-4_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Expressions with type enum shall not be used as operands to built-in operators other than [ ], =, ==, !=, &lt;, &lt;=, >, >=, and the unary &amp; operator" id="MISRA2008-4_5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary &amp; operator" id="MISRA2008-4_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="MISRA2008-5_0_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The plain char type shall only be used for the storage and use of character values" id="MISRA2008-5_0_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="signed char and unsigned char type shall only be used for the storage and use of numeric values" id="MISRA2008-5_0_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="MISRA2008-5_0_13" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The first operand of a conditional-operator shall have type bool" id="MISRA2008-5_0_14" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Array indexing shall be the only form of pointer arithmetic" id="MISRA2008-5_0_15" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid accessing arrays out of bounds" id="MISRA2008-5_0_16_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRA2008-5_0_16_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Subtraction between pointers shall only be applied to pointers that address elements of the same array" id="MISRA2008-5_0_17" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc=">, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" id="MISRA2008-5_0_18" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The declaration of objects shall contain no more than two levels of pointer indirection" id="MISRA2008-5_0_19" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="MISRA2008-5_0_20" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="MISRA2008-5_0_21" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An implicit integral conversion shall not change the signedness of the underlying type" id="MISRA2008-5_0_4_a" sev="2">
               <Stats authTot="20;" total="20"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no implicit floating-integral conversions" id="MISRA2008-5_0_5_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no implicit floating-integral conversions" id="MISRA2008-5_0_5_b" sev="2">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no explicit floating-integral conversions of a cvalue expression" id="MISRA2008-5_0_7_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no explicit floating-integral conversions of a cvalue expression" id="MISRA2008-5_0_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" id="MISRA2008-5_0_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" id="MISRA2008-5_0_8_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression" id="MISRA2008-5_0_9" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRA2008-5_14_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="MISRA2008-5_17_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The comma operator shall not be used" id="MISRA2008-5_18_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each operand of a logical &amp;&amp; or || shall be a postfix-expression" id="MISRA2008-5_2_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The &amp;&amp; operator and the || operator shall not be overloaded" id="MISRA2008-5_2_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The comma &quot;,&quot; operator shall not be overloaded" id="MISRA2008-5_2_11_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="MISRA2008-5_2_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="MISRA2008-5_2_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="MISRA2008-5_2_4" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cast shall not remove any const or volatile qualification from the type of a pointer or reference" id="MISRA2008-5_2_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="MISRA2008-5_2_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly" id="MISRA2008-5_2_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="MISRA2008-5_2_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="MISRA2008-5_3_1" sev="2">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="MISRA2008-5_3_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The unary &amp; operator shall not be overloaded" id="MISRA2008-5_3_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand" id="MISRA2008-5_8_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Assignment operators shall not be used in sub-expressions" id="MISRA2008-6_2_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Floating-point expressions shall not be directly or indirectly tested for equality or inequality" id="MISRA2008-6_2_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character" id="MISRA2008-6_2_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The statement forming the body of a switch, while, do while or for statement shall be a compound statement" id="MISRA2008-6_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement" id="MISRA2008-6_4_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All if ... else if constructs shall be terminated with an else clause" id="MISRA2008-6_4_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2008-6_4_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="MISRA2008-6_4_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The final clause of a switch statement shall be the default-clause" id="MISRA2008-6_4_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The condition of a switch statement shall not have bool type" id="MISRA2008-6_4_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Every switch statement shall have at least one case-clause" id="MISRA2008-6_4_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A for loop shall contain a single loop-counter which shall not have floating type" id="MISRA2008-6_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" id="MISRA2008-6_5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The loop-counter shall not be modified within condition or statement" id="MISRA2008-6_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="MISRA2008-6_5_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="MISRA2008-6_5_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A loop-control-variable other than the loop-counter which is modified in statement within a body of the loop shall have type bool" id="MISRA2008-6_5_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRA2008-6_6_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRA2008-6_6_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The continue statement shall only be used within a well-formed for loop" id="MISRA2008-6_6_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="MISRA2008-6_6_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A function shall have a single point of exit at the end of the function" id="MISRA2008-6_6_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Declare local variable as const whenever possible" id="MISRA2008-7_1_1" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Declare parameters as const whenever possible" id="MISRA2008-7_1_1_b" sev="2">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A pointer parameter in a function shall be declared as pointer to const if the corresponding object is not modified" id="MISRA2008-7_1_2_a" sev="2">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A reference parameter in a function shall be declared as reference to const if the corresponding object is not modified" id="MISRA2008-7_1_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRA2008-7_1_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="MISRA2008-7_2_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" id="MISRA2008-7_3_1" sev="2">
               <Stats authTot="17;" total="17"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifier main shall not be used for a function other than the global function main" id="MISRA2008-7_3_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There shall be no unnamed namespaces in header files" id="MISRA2008-7_3_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="using-directives shall not be used" id="MISRA2008-7_3_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier" id="MISRA2008-7_3_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="MISRA2008-7_3_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Assembler instructions shall only be introduced using the asm declaration" id="MISRA2008-7_4_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Assembly language shall be encapsulated and isolated" id="MISRA2008-7_4_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function" id="MISRA2008-7_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2008-7_5_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2008-7_5_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference" id="MISRA2008-7_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively" id="MISRA2008-8_0_1" sev="2">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments" id="MISRA2008-8_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Functions shall not be defined using the ellipsis notation" id="MISRA2008-8_4_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration" id="MISRA2008-8_4_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRA2008-8_4_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A function identifier shall either be used to call the function or it shall be preceded by '&amp;'" id="MISRA2008-8_4_4" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All variables shall have a defined value before they are used" id="MISRA2008-8_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" id="MISRA2008-8_5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Arrays shall not be partially initialized" id="MISRA2008-8_5_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Structures shall not be partially initialized" id="MISRA2008-8_5_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized" id="MISRA2008-8_5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="const member functions shall not return non-const pointers or references to class-data" id="MISRA2008-9_3_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Protected member functions shall not return non-const handles to class-data" id="MISRA2008-9_3_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Public member functions shall not return non-const handles to class-data" id="MISRA2008-9_3_2_b" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="MISRA2008-9_3_3" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Unions shall not be used" id="MISRA2008-9_5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Bit-fields shall be either bool type or an explicitly unsigned or signed integral type" id="MISRA2008-9_6_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Bit-fields shall not have enum type" id="MISRA2008-9_6_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRA2008-9_6_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Classes should not be derived from virtual bases" id="MISRA2008-10_1_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All accessible entity names within a multiple inheritance hierarchy should be unique" id="MISRA2008-10_2_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="MISRA2008-12_1_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The viable function set for a function call should either contain no function specializations, or only contain function specializations" id="MISRA2008-14_8_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="An exception object should not have pointer type" id="MISRA2008-15_0_2" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="MISRA2008-15_3_2" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The \ character should not occur in a header file name" id="MISRA2008-16_2_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The # and ## operators should not be used" id="MISRA2008-16_3_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Digraphs should not be used" id="MISRA2008-2_5_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Sections of code should not be &quot;commented out&quot; using C++ comments" id="MISRA2008-2_7_3" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="typedefs that indicate size and signedness should be used in place of the basic numerical types" id="MISRA2008-3_9_2" sev="4">
               <Stats authTot="28;" total="28"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRA2008-5_19_1_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRA2008-5_19_1_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression" id="MISRA2008-5_2_10" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Casts from a base class to a derived class should not be performed on polymorphic types" id="MISRA2008-5_2_3" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="A cast should not convert a pointer type to an integral type" id="MISRA2008-5_2_9" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Functions should not call themselves, either directly or indirectly" id="MISRA2008-7_5_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid accessing arrays out of bounds" id="MISRA2008-0_3_1_a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid null pointer dereferencing" id="MISRA2008-0_3_1_b" sev="5">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid division by zero" id="MISRA2008-0_3_1_c" sev="5">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRA2008-0_3_1_d" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2008-0_3_1_e" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not check for null after dereferencing" id="MISRA2008-0_3_1_f" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid overflow when reading from a buffer" id="MISRA2008-0_3_1_g" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Avoid overflow when writing to a buffer" id="MISRA2008-0_3_1_h" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRA2008-0_3_1_i" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Do not compare two unrelated pointers" id="MISRA2008-0_3_1_j" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="Use of floating-point arithmetic shall be documented" id="MISRA2008-0_4_2" sev="5">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All uses of the #pragma directive shall be documented" id="MISRA2008-16_6_1" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2008" desc="All usage of assembler shall be documented" id="MISRA2008-7_4_1" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Precautions shall be taken in order to prevent the contents of a header file being included more than once" id="MISRA2012-DIR-4_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Validate values passed to library functions" id="MISRA2012-DIR-4_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Dynamic memory allocation shall not be used" id="MISRA2012-DIR-4_12" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid tainted data in array indexes" id="MISRA2012-DIR-4_14_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Protect against integer overflow/underflow from tainted data" id="MISRA2012-DIR-4_14_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid buffer read overflow from tainted data" id="MISRA2012-DIR-4_14_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid buffer write overflow from tainted data" id="MISRA2012-DIR-4_14_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Protect against command injection" id="MISRA2012-DIR-4_14_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Protect against file name injection" id="MISRA2012-DIR-4_14_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Protect against SQL injection" id="MISRA2012-DIR-4_14_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Prevent buffer overflows from tainted data" id="MISRA2012-DIR-4_14_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="MISRA2012-DIR-4_14_i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Protect against environment injection" id="MISRA2012-DIR-4_14_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid printing tainted data on the output console" id="MISRA2012-DIR-4_14_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Exclude unsanitized user input from format strings" id="MISRA2012-DIR-4_14_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="MISRA2012-DIR-4_15" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid accessing arrays out of bounds" id="MISRA2012-DIR-4_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid null pointer dereferencing" id="MISRA2012-DIR-4_1_b" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid division by zero" id="MISRA2012-DIR-4_1_c" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRA2012-DIR-4_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2012-DIR-4_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not check for null after dereferencing" id="MISRA2012-DIR-4_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid overflow when reading from a buffer" id="MISRA2012-DIR-4_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid overflow when writing to a buffer" id="MISRA2012-DIR-4_1_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRA2012-DIR-4_1_i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not compare two unrelated pointers" id="MISRA2012-DIR-4_1_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid wraparounds when performing arithmetic integer operations" id="MISRA2012-DIR-4_1_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid signed integer overflows" id="MISRA2012-DIR-4_1_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid data loss when converting between integer types" id="MISRA2012-DIR-4_1_m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Assembly language shall be encapsulated and isolated" id="MISRA2012-DIR-4_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Consistently check the returned value of non-void functions" id="MISRA2012-DIR-4_7_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Always check the returned value of non-void function" id="MISRA2012-DIR-4_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not use global variable with different locks set" id="MISRA2012-DIR-5_1" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Variable should be used in context of single critical section" id="MISRA2012-DIR-5_1_b" sev="2">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="There shall be no data races between threads" id="MISRA2012-DIR-5_1_c" sev="2">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not acquire locks in different order" id="MISRA2012-DIR-5_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="A thread should not be created by another thread" id="MISRA2012-DIR-5_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="All resources obtained dynamically by means of Standard Library functions shall be explicitly released" id="MISRA2012-DIR-4_13_a" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not use resources that have been freed" id="MISRA2012-DIR-4_13_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not free resources using invalid pointers" id="MISRA2012-DIR-4_13_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not abandon unreleased locks" id="MISRA2012-DIR-4_13_d" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Avoid double locking" id="MISRA2012-DIR-4_13_e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Do not release a lock that has not been acquired" id="MISRA2012-DIR-4_13_f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="All usage of assembly language should be documented" id="MISRA2012-DIR-4_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Sections of code should not be &quot;commented out&quot;" id="MISRA2012-DIR-4_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="MISRA2012-DIR-4_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="typedefs to basic types should contain some digits in their name" id="MISRA2012-DIR-4_6_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="typedefs should be used in place of the basic types" id="MISRA2012-DIR-4_6_b" sev="4">
               <Stats authTot="25;" total="25"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="MISRA2012-DIR-4_6_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="MISRA2012-DIR-4_8" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-DIR" desc="A function should be used in preference to a function-like macro where they are interchangeable" id="MISRA2012-DIR-4_9" sev="4">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="MISRA2012-RULE-12_5" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function shall not be declared implicitly" id="MISRA2012-RULE-17_3" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRA2012-RULE-17_4" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRA2012-RULE-17_4_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="MISRA2012-RULE-17_6" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function declared with a _Noreturn function specifier shall not return to its caller" id="MISRA2012-RULE-17_9" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Pointers to variably-modified array types should not be used" id="MISRA2012-RULE-18_10" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Any value passed to a function in &lt;ctype.h> shall be representable as an 'unsigned char' or be the value 'EOF'" id="MISRA2012-RULE-21_13" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2012-RULE-21_17_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid overflow when writing to a buffer" id="MISRA2012-RULE-21_17_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The 'size_t' argument passed to any function in &lt;string.h> shall have an appropriate value" id="MISRA2012-RULE-21_18" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRA2012-RULE-21_19_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRA2012-RULE-21_19_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRA2012-RULE-21_20" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All arguments to any type-generic macros declared in &lt;tgmath.h> shall have appropriate essential type" id="MISRA2012-RULE-21_22" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions" id="MISRA2012-RULE-22_12" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A thread synchronization object should not be initialized by a thread" id="MISRA2012-RULE-22_14_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The second argument passed to the 'mtx_init()' function call should be either 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', or 'mtx_timed | mtx_recursive'" id="MISRA2012-RULE-22_14_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A thread-specific storage should not be created by a thread" id="MISRA2012-RULE-22_20" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use resources that have been freed" id="MISRA2012-RULE-22_2_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not free resources using invalid pointers" id="MISRA2012-RULE-22_2_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid writing to a stream which has been opened as read only" id="MISRA2012-RULE-22_4" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A pointer to a FILE object shall not be dereferenced" id="MISRA2012-RULE-22_5_a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="MISRA2012-RULE-22_5_b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of a pointer to a FILE shall not be used after the associated stream has been closed" id="MISRA2012-RULE-22_6" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The argument of an integer-constant macro shall have an appropriate form" id="MISRA2012-RULE-7_5" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid use before initialization" id="MISRA2012-RULE-9_1" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Atomic objects shall be properly initialized before being accessed" id="MISRA2012-RULE-9_7" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="MISRA2012-RULE-10_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="MISRA2012-RULE-10_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="MISRA2012-RULE-10_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="MISRA2012-RULE-10_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="MISRA2012-RULE-10_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An operand of essentially signed or enum type should not be used as right hand side operand to the bitwise shifting operator" id="MISRA2012-RULE-10_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="MISRA2012-RULE-10_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Floating-point expressions shall not be explicitly (syntactically) tested for equality (==) or inequality (!=)" id="MISRA2012-RULE-10_1_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="MISRA2012-RULE-10_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="MISRA2012-RULE-10_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="MISRA2012-RULE-10_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="MISRA2012-RULE-10_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The second and third operands of the ternary operator shall have the same essential type category" id="MISRA2012-RULE-10_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="MISRA2012-RULE-10_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="MISRA2012-RULE-10_7_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="MISRA2012-RULE-10_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="MISRA2012-RULE-10_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The _Atomic qualifier shall not be applied to the incomplete type void" id="MISRA2012-RULE-11_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to a function and any other type" id="MISRA2012-RULE-11_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to a function and any other type" id="MISRA2012-RULE-11_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="MISRA2012-RULE-11_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="MISRA2012-RULE-11_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="MISRA2012-RULE-11_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="MISRA2012-RULE-11_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A conversion shall not remove any 'const', 'volatile' or '_Atomic' qualification from the type pointed to by a pointer" id="MISRA2012-RULE-11_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The macro NULL shall be the only permitted form of integer null pointer constant" id="MISRA2012-RULE-11_9_a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The macro NULL shall be the only permitted form of integer null pointer constant" id="MISRA2012-RULE-11_9_b" sev="2">
               <Stats authTot="25;" total="25"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid incorrect shift operations" id="MISRA2012-RULE-12_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the essential type of the left-hand operand" id="MISRA2012-RULE-12_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Structure and union members of atomic objects shall not be directly accessed" id="MISRA2012-RULE-12_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Initializer lists shall not contain persistent side effects" id="MISRA2012-RULE-13_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2012-RULE-13_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRA2012-RULE-13_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRA2012-RULE-13_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRA2012-RULE-13_2_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRA2012-RULE-13_2_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use more than one volatile in one expression" id="MISRA2012-RULE-13_2_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRA2012-RULE-13_2_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of an expression with atomic type should be independent from thread interleaving" id="MISRA2012-RULE-13_2_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects" id="MISRA2012-RULE-13_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="MISRA2012-RULE-14_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="MISRA2012-RULE-14_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="MISRA2012-RULE-14_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The first clause of a 'for' loop shall be well-formed" id="MISRA2012-RULE-14_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The second clause of a 'for' loop shall be well-formed" id="MISRA2012-RULE-14_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The third clause of a 'for' statement shall be well-formed" id="MISRA2012-RULE-14_2_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Controlling expressions shall not be invariant" id="MISRA2012-RULE-14_3_zc" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" id="MISRA2012-RULE-14_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The goto statement shall jump to a label declared later in the same function" id="MISRA2012-RULE-15_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement" id="MISRA2012-RULE-15_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The body of an iteration-statement or a selection-statement shall be a compound-statement" id="MISRA2012-RULE-15_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The body of an iteration-statement or a selection-statement shall be a compound-statement" id="MISRA2012-RULE-15_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All 'if ... else if' constructs shall be terminated with an 'else' statement" id="MISRA2012-RULE-15_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRA2012-RULE-16_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2012-RULE-16_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRA2012-RULE-16_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRA2012-RULE-16_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Always provide a default branch for switch statements" id="MISRA2012-RULE-16_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRA2012-RULE-16_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRA2012-RULE-16_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Every switch statement shall have at least two switch-clauses" id="MISRA2012-RULE-16_1_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2012-RULE-16_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every switch-clause" id="MISRA2012-RULE-16_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every switch-clause" id="MISRA2012-RULE-16_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Every 'switch' statement shall have a 'default' label" id="MISRA2012-RULE-16_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRA2012-RULE-16_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A default label shall appear as either the first or the last switch label of a switch statement" id="MISRA2012-RULE-16_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Every switch statement shall have at least two switch-clauses" id="MISRA2012-RULE-16_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A switch-expression shall not have essentially Boolean type" id="MISRA2012-RULE-16_7_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A switch-expression shall not have essentially Boolean type" id="MISRA2012-RULE-16_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function declared with a _Noreturn function specifier shall have void return type" id="MISRA2012-RULE-17_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function type shall not be type qualified" id="MISRA2012-RULE-17_13" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The features of &lt;stdarg.h> shall not be used" id="MISRA2012-RULE-17_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The features of &lt;stdarg.h> shall not be used" id="MISRA2012-RULE-17_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;stdarg.h> shall not be used" id="MISRA2012-RULE-17_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Functions shall not call themselves, either directly or indirectly" id="MISRA2012-RULE-17_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="MISRA2012-RULE-17_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value returned by a function having non-void return type shall be used" id="MISRA2012-RULE-17_7_a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value returned by a function having non-void return type shall be used" id="MISRA2012-RULE-17_7_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid accessing arrays out of bounds" id="MISRA2012-RULE-18_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid accessing arrays and pointers out of bounds" id="MISRA2012-RULE-18_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRA2012-RULE-18_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Subtraction between pointers shall only be applied to pointers that address elements of the same array" id="MISRA2012-RULE-18_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc=">, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" id="MISRA2012-RULE-18_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRA2012-RULE-18_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2012-RULE-18_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The address of an object with thread storage duration shall not be assigned to an object with static storage duration" id="MISRA2012-RULE-18_6_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Flexible array members shall not be declared" id="MISRA2012-RULE-18_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Variable-length arrays should not be used" id="MISRA2012-RULE-18_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An object shall not be used outside its lifetime" id="MISRA2012-RULE-18_9" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRA2012-RULE-1_1_a_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRA2012-RULE-1_1_a_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRA2012-RULE-1_1_b_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRA2012-RULE-1_1_b_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid division by zero" id="MISRA2012-RULE-1_3_a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid use before initialization" id="MISRA2012-RULE-1_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use resources that have been freed" id="MISRA2012-RULE-1_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid overflow when reading from a buffer" id="MISRA2012-RULE-1_3_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid overflow when writing to a buffer" id="MISRA2012-RULE-1_3_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2012-RULE-1_3_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRA2012-RULE-1_3_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRA2012-RULE-1_3_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRA2012-RULE-1_3_i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRA2012-RULE-1_3_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use more than one volatile in one expression" id="MISRA2012-RULE-1_3_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRA2012-RULE-1_3_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function shall not return a pointer or reference to a non-static local object" id="MISRA2012-RULE-1_3_m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist" id="MISRA2012-RULE-1_3_n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="MISRA2012-RULE-1_3_o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="MISRA2012-RULE-1_4_j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The 'rsize_t' type should not be used" id="MISRA2012-RULE-1_4_k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The 'errno_t' type should not be used" id="MISRA2012-RULE-1_4_l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="MISRA2012-RULE-1_4_m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="MISRA2012-RULE-1_4_n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRA2012-RULE-1_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Storage type modifiers shall be associated with the type, not the variable or the function" id="MISRA2012-RULE-1_5_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Function types shall be in prototype form" id="MISRA2012-RULE-1_5_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use macro ATOMIC_VAR_INIT" id="MISRA2012-RULE-1_5_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use 'bool', 'false' or 'true' identifiers in the #undef directive" id="MISRA2012-RULE-1_5_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use the ungetc function on a stream with the file position indicator 0" id="MISRA2012-RULE-1_5_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not pass 0 value as a size argument to the realloc function" id="MISRA2012-RULE-1_5_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="MISRA2012-RULE-20_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRA2012-RULE-20_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A line whose first token is # shall be a valid preprocessing directive" id="MISRA2012-RULE-20_13" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" id="MISRA2012-RULE-20_14" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The ', &amp; or \ characters and the /* or // character sequences shall not occur in a header file name" id="MISRA2012-RULE-20_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The ', &amp; or \ characters and the /* or // character sequences shall not occur in a header file name" id="MISRA2012-RULE-20_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA2012-RULE-20_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A macro shall not be defined with the same name as a keyword" id="MISRA2012-RULE-20_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A macro shall not be defined with the same name as a keyword" id="MISRA2012-RULE-20_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Tokens that look like a preprocessing directive shall not occur within a macro argument" id="MISRA2012-RULE-20_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses" id="MISRA2012-RULE-20_7" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="MISRA2012-RULE-20_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" id="MISRA2012-RULE-20_9_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;time.h> shall not be used" id="MISRA2012-RULE-21_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The time handling functions and macros of library &lt;time.h> shall not be used" id="MISRA2012-RULE-21_10_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The types defined in the library &lt;time.h> shall not be used" id="MISRA2012-RULE-21_10_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;tgmath.h> shall not be used" id="MISRA2012-RULE-21_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The features provided by &lt;fenv.h> should not be used" id="MISRA2012-RULE-21_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;fenv.h> shall not be used" id="MISRA2012-RULE-21_12_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The Standard Library function 'memcmp' shall not be used to compare null-terminated strings" id="MISRA2012-RULE-21_14" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="MISRA2012-RULE-21_15" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="MISRA2012-RULE-21_16" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRA2012-RULE-21_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="#define and #undef shall not be used on a reserved identifier or reserved macro name (for C90 code)" id="MISRA2012-RULE-21_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="#define and #undef shall not be used on a reserved identifier or reserved macro name (for C99 code)" id="MISRA2012-RULE-21_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not #define nor #undef identifier 'defined'" id="MISRA2012-RULE-21_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_21" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All arguments to any multi-argument type-generic macros declared in &lt;tgmath.h> shall have the same standard type" id="MISRA2012-RULE-21_23" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The random number generator functions of  &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_24" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Only 'memory_order_seq_cst' should be used as an explicit memory order argument" id="MISRA2012-RULE-21_25" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The Standard Library function mtx_timedlock() shall not be invoked on a mutex that does not support timeout" id="MISRA2012-RULE-21_26" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An identifier with name which starts with underscore shall not be declared" id="MISRA2012-RULE-21_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A reserved identifier or macro name shall not be declared (for C90 code)" id="MISRA2012-RULE-21_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A reserved identifier or macro name shall not be declared (for C99 code)" id="MISRA2012-RULE-21_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The memory allocation and deallocation functions of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_3" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2012-RULE-21_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2012-RULE-21_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;signal.h> shall not be used" id="MISRA2012-RULE-21_5_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The standard header file &lt;signal.h> shall not be used" id="MISRA2012-RULE-21_5_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The Standard Library input/output functions shall not be used" id="MISRA2012-RULE-21_6" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_7" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The library functions 'quick_exit' and '_Exit' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_9" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All resources obtained dynamically by means of Standard Library functions shall be explicitly released" id="MISRA2012-RULE-22_1" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of 'errno' shall only be tested when the last function to be called was an errno-setting-function" id="MISRA2012-RULE-22_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not join or detach a thread that was previously joined or detached" id="MISRA2012-RULE-22_11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Thread objects, thread synchronization objects and thread-specific storage pointers shall not have automatic storage duration" id="MISRA2012-RULE-22_13" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A thread synchronization object should not be destroyed by a thread" id="MISRA2012-RULE-22_15" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not abandon unreleased locks" id="MISRA2012-RULE-22_16" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not release a lock that has not been acquired" id="MISRA2012-RULE-22_17" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid double locking" id="MISRA2012-RULE-22_18" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A condition variable shall be associated with at most one mutex variable" id="MISRA2012-RULE-22_19" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The same file shall not be opened for read and write access at the same time on different stream" id="MISRA2012-RULE-22_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The macro 'EOF' should be compared with the unmodified return value from the Standard Library function" id="MISRA2012-RULE-22_7" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of 'errno' shall be set to zero prior to a call to an errno-setting-function" id="MISRA2012-RULE-22_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The value of 'errno' shall be tested against zero after calling an errno-setting-function" id="MISRA2012-RULE-22_9" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression" id="MISRA2012-RULE-23_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic association shall list an appropriate type" id="MISRA2012-RULE-23_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The controlling expression of a generic selection shall have an essential type that matches its standard type" id="MISRA2012-RULE-23_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Enumerated types should not be mixed with integer types in generic selections" id="MISRA2012-RULE-23_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A default association shall appear as either the first or the last association of a generic selection" id="MISRA2012-RULE-23_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'else' block" id="MISRA2012-RULE-2_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="MISRA2012-RULE-2_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'if', 'else', 'while', 'for' block" id="MISRA2012-RULE-2_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'switch' statement" id="MISRA2012-RULE-2_1_d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'for' loop" id="MISRA2012-RULE-2_1_e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRA2012-RULE-2_1_f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'if' or 'switch' statement inside 'while'/'for'/'do...while' loop" id="MISRA2012-RULE-2_1_g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid unreachable methods" id="MISRA2012-RULE-2_1_h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRA2012-RULE-2_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid unused values" id="MISRA2012-RULE-2_2_b" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The character sequence /* shall not be used within a C-style comment" id="MISRA2012-RULE-3_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The character sequence // shall not be used within a C-style comment" id="MISRA2012-RULE-3_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The character sequence /* shall not be used within a C++-style comment" id="MISRA2012-RULE-3_1_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Line-splicing shall not be used in // comments" id="MISRA2012-RULE-3_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRA2012-RULE-4_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="External identifiers shall be distinct" id="MISRA2012-RULE-5_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="MISRA2012-RULE-5_2_a_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="MISRA2012-RULE-5_2_a_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="MISRA2012-RULE-5_2_b_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="MISRA2012-RULE-5_2_b_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2012-RULE-5_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2012-RULE-5_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="MISRA2012-RULE-5_4_a_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="MISRA2012-RULE-5_4_a_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="MISRA2012-RULE-5_4_b_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="MISRA2012-RULE-5_4_b_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers shall be distinct from macro names (c90)" id="MISRA2012-RULE-5_5_c90" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers shall be distinct from macro names (c99)" id="MISRA2012-RULE-5_5_c99" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A typedef name shall be a unique identifier" id="MISRA2012-RULE-5_6_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A tag name shall be a unique identifier" id="MISRA2012-RULE-5_7_a" sev="2">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers that define objects with external linkage shall be unique" id="MISRA2012-RULE-5_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers that define functions with external linkage shall be unique" id="MISRA2012-RULE-5_8_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Bit-fields shall only be declared with an appropriate type" id="MISRA2012-RULE-6_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Single-bit named bit fields shall not be of a signed type" id="MISRA2012-RULE-6_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A bit field shall not be declared as a member of a union" id="MISRA2012-RULE-6_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Octal constants shall not be used" id="MISRA2012-RULE-7_1" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A 'u' or 'U' suffix shall be applied to all integer constants that are represented in an unsigned type" id="MISRA2012-RULE-7_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The lowercase character 'l' shall not be used in a literal suffix" id="MISRA2012-RULE-7_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A string literal shall not be assigned to an object unless the object's type is pointer to const-qualified char" id="MISRA2012-RULE-7_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An inline function shall be declared with the static storage class" id="MISRA2012-RULE-8_10" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRA2012-RULE-8_12" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The restrict type qualifier shall not be used" id="MISRA2012-RULE-8_14" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All declarations of an object with external linkage and an explicit alignment specification shall specify the same alignment" id="MISRA2012-RULE-8_15" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All declarations of an object with internal linkage and an explicit alignment specification shall specify the same alignment" id="MISRA2012-RULE-8_15_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRA2012-RULE-8_1_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRA2012-RULE-8_1_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRA2012-RULE-8_2_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Function types shall have named parameters" id="MISRA2012-RULE-8_2_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Function types shall be in prototype form" id="MISRA2012-RULE-8_2_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRA2012-RULE-8_3_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRA2012-RULE-8_3_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="All declarations of an object or function shall have compatible types" id="MISRA2012-RULE-8_3_c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A compatible declaration shall be visible when an object or function with external linkage is defined" id="MISRA2012-RULE-8_4_a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A compatible declaration shall be visible when an object or function with external linkage is defined" id="MISRA2012-RULE-8_4_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="MISRA2012-RULE-8_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2012-RULE-8_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2012-RULE-8_6_b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage" id="MISRA2012-RULE-8_8" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRA2012-RULE-9_2" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Arrays shall not be partially initialized" id="MISRA2012-RULE-9_3" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An element of an object shall not be initialized more than once" id="MISRA2012-RULE-9_4" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="MISRA2012-RULE-9_5" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An initializer using chained designators shall not contain initializers without designators" id="MISRA2012-RULE-9_6" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The cast operation to essentially enumeration type is not allowed" id="MISRA2012-RULE-10_5_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not cast from or to essentially Boolean type" id="MISRA2012-RULE-10_5_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Do not use casts between essentially character types and essentially floating types" id="MISRA2012-RULE-10_5_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A conversion should not be performed between a pointer to object and an integer type" id="MISRA2012-RULE-11_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A conversion should not be performed from pointer to void into pointer to object" id="MISRA2012-RULE-11_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Use parentheses to indicate the precedence of operators in expressions" id="MISRA2012-RULE-12_1_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Parenthesis shall be used with 'sizeof' statement" id="MISRA2012-RULE-12_1_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The comma operator should not be used" id="MISRA2012-RULE-12_3" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRA2012-RULE-12_4_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRA2012-RULE-12_4_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator" id="MISRA2012-RULE-13_3" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The result of an assignment operator should not be used" id="MISRA2012-RULE-13_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The goto statement should not be used" id="MISRA2012-RULE-15_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There should be no more than one break or goto statement used to terminate any iteration statement" id="MISRA2012-RULE-15_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function should have a single point of exit at the end" id="MISRA2012-RULE-15_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function that never returns should be declared with a _Noreturn function specifier" id="MISRA2012-RULE-17_11" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function identifier shall only be used with either a preceding &amp;, or with a parenthesised parameter list" id="MISRA2012-RULE-17_12" sev="4">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function parameter should not be modified" id="MISRA2012-RULE-17_8" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="MISRA2012-RULE-18_4" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Declarations should contain no more than two levels of pointer nesting" id="MISRA2012-RULE-18_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The union keyword should not be used" id="MISRA2012-RULE-19_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="#include directives should only be preceded by preprocessor directives or comments" id="MISRA2012-RULE-20_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The # and ## preprocessor operators should not be used" id="MISRA2012-RULE-20_10" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="#undef should not be used" id="MISRA2012-RULE-20_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection should only be expanded from a macro" id="MISRA2012-RULE-23_1" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection used in a macro definition should have a macro parameter in the controlling expression" id="MISRA2012-RULE-23_1_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection should contain at least one non-default association" id="MISRA2012-RULE-23_3" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection should not depend on implicit pointer type conversion" id="MISRA2012-RULE-23_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A generic selection that is expanded from a macro should evaluate its argument only once" id="MISRA2012-RULE-23_7" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function should not contain unused type declarations" id="MISRA2012-RULE-2_3_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A source file should not contain unused type declarations" id="MISRA2012-RULE-2_3_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function should not contain unused local tag declarations" id="MISRA2012-RULE-2_4_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A source file should not contain unused tag declarations" id="MISRA2012-RULE-2_4_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A source file should not contain unused macro definitions" id="MISRA2012-RULE-2_5" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A function should not contain unused label declarations" id="MISRA2012-RULE-2_6" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="There should be no unused parameters in functions" id="MISRA2012-RULE-2_7" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A project should not contain unused variables with external linkage" id="MISRA2012-RULE-2_8_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A project should not contain unused variables with internal linkage" id="MISRA2012-RULE-2_8_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Avoid unused local variables" id="MISRA2012-RULE-2_8_c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Trigraphs should not be used" id="MISRA2012-RULE-4_2" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers that define objects with internal linkage should be unique" id="MISRA2012-RULE-5_9_a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Identifiers that define functions with internal linkage should be unique" id="MISRA2012-RULE-5_9_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The small integer variants of the minimum-width integer constant macros should not be used" id="MISRA2012-RULE-7_6" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="When an array with external linkage is declared, its size should be explicitly specified" id="MISRA2012-RULE-8_11" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRA2012-RULE-8_13_a" sev="4">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRA2012-RULE-8_13_b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="The alignment specification of zero should not appear in an object declaration" id="MISRA2012-RULE-8_16" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="At most one explicit alignment specifier should appear in an object declaration" id="MISRA2012-RULE-8_17" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="MISRA2012-RULE-8_7" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRA2012-RULE" desc="An object should be defined at block scope if its identifier only appears in a single function" id="MISRA2012-RULE-8_9" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-DIR_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid null pointer dereferencing" id="MISRAC2012-DIR_4_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid division by zero" id="MISRAC2012-DIR_4_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRAC2012-DIR_4_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-DIR_4_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Do not check for null after dereferencing" id="MISRAC2012-DIR_4_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-DIR_4_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-DIR_4_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-DIR_4_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Do not compare two unrelated pointers" id="MISRAC2012-DIR_4_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid wraparounds when performing arithmetic integer operations" id="MISRAC2012-DIR_4_1-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid signed integer overflows" id="MISRAC2012-DIR_4_1-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_1" desc="Avoid data loss when converting between integer types" id="MISRAC2012-DIR_4_1-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_10" desc="Use multiple include guards" id="MISRAC2012-DIR_4_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_11" desc="Validate values passed to library functions" id="MISRAC2012-DIR_4_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_12" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-DIR_4_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Ensure resources are freed" id="MISRAC2012-DIR_4_13-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Do not use resources that have been freed" id="MISRAC2012-DIR_4_13-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Do not free resources using invalid pointers" id="MISRAC2012-DIR_4_13-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Do not abandon unreleased locks" id="MISRAC2012-DIR_4_13-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Avoid double locking" id="MISRAC2012-DIR_4_13-e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_13" desc="Do not release a lock that has not been acquired" id="MISRAC2012-DIR_4_13-f" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Avoid tainted data in array indexes" id="MISRAC2012-DIR_4_14-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Protect against integer overflow/underflow from tainted data" id="MISRAC2012-DIR_4_14-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Avoid buffer read overflow from tainted data" id="MISRAC2012-DIR_4_14-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Avoid buffer write overflow from tainted data" id="MISRAC2012-DIR_4_14-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Protect against command injection" id="MISRAC2012-DIR_4_14-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Protect against file name injection" id="MISRAC2012-DIR_4_14-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Protect against SQL injection" id="MISRAC2012-DIR_4_14-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Prevent buffer overflows from tainted data" id="MISRAC2012-DIR_4_14-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="MISRAC2012-DIR_4_14-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Protect against environment injection" id="MISRAC2012-DIR_4_14-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Avoid printing tainted data on the output console" id="MISRAC2012-DIR_4_14-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_14" desc="Exclude unsanitized user input from format strings" id="MISRAC2012-DIR_4_14-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_15" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="MISRAC2012-DIR_4_15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_2" desc="All usage of assembler shall be documented" id="MISRAC2012-DIR_4_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_3" desc="Assembly language shall be encapsulated and isolated" id="MISRAC2012-DIR_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_4" desc="Sections of code should not be &quot;commented out&quot;" id="MISRAC2012-DIR_4_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_5" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="MISRAC2012-DIR_4_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_6" desc="typedefs to basic types should contain some digits in their name" id="MISRAC2012-DIR_4_6-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_6" desc="typedefs should be used in place of the basic types" id="MISRAC2012-DIR_4_6-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_6" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="MISRAC2012-DIR_4_6-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_7" desc="Consistently check the returned value of non-void functions" id="MISRAC2012-DIR_4_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_7" desc="Always check the returned value of non-void function" id="MISRAC2012-DIR_4_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_8" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="MISRAC2012-DIR_4_8-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_4_9" desc="A function should be used in preference to a function-like macro" id="MISRAC2012-DIR_4_9-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_5_1" desc="Do not use global variable with different locks set" id="MISRAC2012-DIR_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_5_1" desc="Variable should be used in context of single critical section" id="MISRAC2012-DIR_5_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_5_1" desc="There shall be no data races between threads" id="MISRAC2012-DIR_5_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_5_2" desc="Do not acquire locks in different order" id="MISRAC2012-DIR_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-DIR_5_3" desc="A thread should not be created by another thread" id="MISRAC2012-DIR_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="MISRAC2012-RULE_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="MISRAC2012-RULE_10_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="MISRAC2012-RULE_10_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="MISRAC2012-RULE_10_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="MISRAC2012-RULE_10_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_1" desc="Floating-point expressions shall not be explicitly (syntactically) tested for equality (==) or inequality (!=)" id="MISRAC2012-RULE_10_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_2" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="MISRAC2012-RULE_10_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="MISRAC2012-RULE_10_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="MISRAC2012-RULE_10_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_4" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="MISRAC2012-RULE_10_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_4" desc="The second and third operands of the ternary operator shall have the same essential type category" id="MISRAC2012-RULE_10_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_5" desc="The cast operation to essentially enumeration type is not allowed" id="MISRAC2012-RULE_10_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_5" desc="Do not cast from or to essentially Boolean type" id="MISRAC2012-RULE_10_5-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_5" desc="Do not use casts between essentially character types and essentially floating types" id="MISRAC2012-RULE_10_5-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_6" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="MISRAC2012-RULE_10_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_10_8" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="MISRAC2012-RULE_10_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="MISRAC2012-RULE_11_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between non compatible pointer to a function types" id="MISRAC2012-RULE_11_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_10" desc="The '_Atomic' qualifier should not be used with the 'void' type" id="MISRAC2012-RULE_11_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_2" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="MISRAC2012-RULE_11_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_3" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="MISRAC2012-RULE_11_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_4" desc="A conversion should not be performed between a pointer to object and an integer type" id="MISRAC2012-RULE_11_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_5" desc="A conversion should not be performed from pointer to void into pointer to object" id="MISRAC2012-RULE_11_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_6" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="MISRAC2012-RULE_11_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_7" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="MISRAC2012-RULE_11_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_8" desc="A conversion shall not remove any 'const', 'volatile' or '_Atomic' qualification from the type pointed to by a pointer" id="MISRAC2012-RULE_11_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_9" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="MISRAC2012-RULE_11_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_11_9" desc="Use NULL instead of literal zero (0) as the null-pointer-constant" id="MISRAC2012-RULE_11_9-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_1" desc="Use parentheses to indicate the precedence of operators in expressions" id="MISRAC2012-RULE_12_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_1" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="MISRAC2012-RULE_12_1-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_2" desc="Avoid incorrect shift operations" id="MISRAC2012-RULE_12_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_2" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the essential type of the left-hand operand" id="MISRAC2012-RULE_12_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_3" desc="The comma operator shall not be used" id="MISRAC2012-RULE_12_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRAC2012-RULE_12_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRAC2012-RULE_12_4-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_5" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="MISRAC2012-RULE_12_5-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_12_6" desc="Members of atomic objects of structure and union types should not be directly accessed" id="MISRAC2012-RULE_12_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_1" desc="Initializer lists shall not contain persistent side effects" id="MISRAC2012-RULE_13_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_13_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_13_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_13_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_13_2-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_13_2-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_13_2-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_13_2-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_2" desc="The value of an expression with atomic type should be independent from thread interleaving" id="MISRAC2012-RULE_13_2-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_3" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" id="MISRAC2012-RULE_13_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_4" desc="The result of a built-in assignment operator should not be used" id="MISRAC2012-RULE_13_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_5" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRAC2012-RULE_13_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_6" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="MISRAC2012-RULE_13_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_6" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_13_6" desc="The function call shall not be the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_1" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="MISRAC2012-RULE_14_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_1" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="MISRAC2012-RULE_14_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_2" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="MISRAC2012-RULE_14_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_2" desc="The first clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_2" desc="The second clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_2" desc="The third clause of a 'for' statement shall be well-formed" id="MISRAC2012-RULE_14_2-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_3" desc="Avoid conditions that always evaluate to the same value" id="MISRAC2012-RULE_14_3-ac" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_14_4" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="MISRAC2012-RULE_14_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_1" desc="The goto statement shall not be used" id="MISRAC2012-RULE_15_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_2" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRAC2012-RULE_15_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_3" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRAC2012-RULE_15_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_4" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="MISRAC2012-RULE_15_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_5" desc="A function shall have a single point of exit at the end of the function" id="MISRAC2012-RULE_15_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_6" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="MISRAC2012-RULE_15_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_6" desc="'if' and 'else' should be followed by a compound statement" id="MISRAC2012-RULE_15_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_15_7" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="MISRAC2012-RULE_15_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRAC2012-RULE_16_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_1" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_2" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_4" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_4" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_5" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_6" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="MISRAC2012-RULE_17_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end should not be used" id="MISRAC2012-RULE_17_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_1" desc="The standard header file &lt;stdarg.h> or &lt;cstdarg> shall not be used" id="MISRAC2012-RULE_17_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_10" desc="Functions declared as 'noreturn' shall have the 'void' return type" id="MISRAC2012-RULE_17_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_11" desc="Declare non-returning functions with the attribute that specifies that they do not return" id="MISRAC2012-RULE_17_11-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_12" desc="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="MISRAC2012-RULE_17_12-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_13" desc="Do not include any type qualifiers in the specification of a function type" id="MISRAC2012-RULE_17_13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_2" desc="Functions shall not call themselves, either directly or indirectly" id="MISRAC2012-RULE_17_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_3" desc="Functions shall always have visible prototype at the function call" id="MISRAC2012-RULE_17_3-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_5" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="MISRAC2012-RULE_17_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_6" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="MISRAC2012-RULE_17_6-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_8" desc="A function parameter should not be modified" id="MISRAC2012-RULE_17_8-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_17_9" desc="Never return from functions that should not return" id="MISRAC2012-RULE_17_9-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-RULE_18_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays and pointers out of bounds" id="MISRAC2012-RULE_18_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_1" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRAC2012-RULE_18_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_10" desc="Pointers to variably-modified array types should not be used" id="MISRAC2012-RULE_18_10-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_2" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-RULE_18_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_3" desc="Do not compare two unrelated pointers" id="MISRAC2012-RULE_18_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_4" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="MISRAC2012-RULE_18_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_5" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="MISRAC2012-RULE_18_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_18_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_18_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_6" desc="The address of an object with thread storage duration shall not be assigned to an object with static storage duration" id="MISRAC2012-RULE_18_6-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_7" desc="Flexible array members shall not be declared" id="MISRAC2012-RULE_18_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_8" desc="Variable-length arrays should not be used" id="MISRAC2012-RULE_18_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_18_9" desc="Do not modify objects with temporary lifetime" id="MISRAC2012-RULE_18_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned or copied to an overlapping object" id="MISRAC2012-RULE_19_1-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_19_2" desc="The union keyword should not be used" id="MISRAC2012-RULE_19_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Avoid division by zero" id="MISRAC2012-RULE_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Avoid use before initialization" id="MISRAC2012-RULE_1_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_1_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-RULE_1_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_1_3-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_1_3-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_1_3-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_1_3-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_1_3-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_1_3-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_1_3-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_1_3-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_1_3-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_1_3-n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_3" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="MISRAC2012-RULE_1_3-o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_4" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="MISRAC2012-RULE_1_4-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_4" desc="The 'rsize_t' type should not be used" id="MISRAC2012-RULE_1_4-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_4" desc="The 'errno_t' type should not be used" id="MISRAC2012-RULE_1_4-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_4" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="MISRAC2012-RULE_1_4-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_4" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="MISRAC2012-RULE_1_4-n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRAC2012-RULE_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Storage type modifiers shall be associated with the type, not the variable or the function" id="MISRAC2012-RULE_1_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Function types shall be in prototype form" id="MISRAC2012-RULE_1_5-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Do not use the macro ATOMIC_VAR_INIT" id="MISRAC2012-RULE_1_5-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Do not use the 'bool', 'false' or 'true' identifiers in the #undef directive" id="MISRAC2012-RULE_1_5-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Do not use the ungetc function on a stream with the file position indicator zero" id="MISRAC2012-RULE_1_5-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_1_5" desc="Do not pass 0 value as a size argument to the realloc function" id="MISRAC2012-RULE_1_5-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_1" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="MISRAC2012-RULE_20_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_10" desc="The # and ## preprocessor operators should not be used" id="MISRAC2012-RULE_20_10-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_11" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="MISRAC2012-RULE_20_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_12" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRAC2012-RULE_20_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_13" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="MISRAC2012-RULE_20_13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_14" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRAC2012-RULE_20_14-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_2" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="MISRAC2012-RULE_20_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_2" desc="The \ character should not occur in a header file name" id="MISRAC2012-RULE_20_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_3" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRAC2012-RULE_20_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C90" id="MISRAC2012-RULE_20_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C99" id="MISRAC2012-RULE_20_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_5" desc="#undef shall not be used" id="MISRAC2012-RULE_20_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_6" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRAC2012-RULE_20_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_7" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="MISRAC2012-RULE_20_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_8" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="MISRAC2012-RULE_20_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_20_9" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRAC2012-RULE_20_9-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_1" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRAC2012-RULE_21_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="MISRAC2012-RULE_21_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="MISRAC2012-RULE_21_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_1" desc="Do not #define nor #undef identifier 'defined'" id="MISRAC2012-RULE_21_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_10" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="MISRAC2012-RULE_21_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_10" desc="The time handling functions and macros of the library &lt;time.h> shall not be used" id="MISRAC2012-RULE_21_10-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_10" desc="The types defined in the library &lt;time.h> shall not be used" id="MISRAC2012-RULE_21_10-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_11" desc="The standard header file &lt;tgmath.h> shall not be used" id="MISRAC2012-RULE_21_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_12" desc="The features provided by &lt;fenv.h> should not be used" id="MISRAC2012-RULE_21_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_12" desc="The standard header file &lt;fenv.h> shall not be used" id="MISRAC2012-RULE_21_12-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_13" desc="Do not pass incorrect values to ctype.h library functions" id="MISRAC2012-RULE_21_13-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_14" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="MISRAC2012-RULE_21_14-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_15" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="MISRAC2012-RULE_21_15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_16" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="MISRAC2012-RULE_21_16-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_17" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-RULE_21_17-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_17" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_21_17-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_18" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="MISRAC2012-RULE_21_18-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_19" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRAC2012-RULE_21_19-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_19" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRAC2012-RULE_21_19-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused" id="MISRAC2012-RULE_21_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="MISRAC2012-RULE_21_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="MISRAC2012-RULE_21_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_20" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRAC2012-RULE_21_20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_21" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_21-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_22" desc="All arguments to any type-generic macros declared in &lt;tgmath.h> shall have appropriate essential type" id="MISRAC2012-RULE_21_22-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_23" desc="All arguments to any multi-argument type-generic macros declared in &lt;tgmath.h> shall have the same standard type" id="MISRAC2012-RULE_21_23-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_24" desc="The random number generator functions 'rand()' and 'srand()' should not be used" id="MISRAC2012-RULE_21_24-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_25" desc="Only 'memory_order_seq_cst' should be used as an explicit memory order argument" id="MISRAC2012-RULE_21_25-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_26" desc="The Standard Library function mtx_timedlock() shall not be invoked on a mutex that does not support timeout" id="MISRAC2012-RULE_21_26-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_3" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-RULE_21_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_4" desc="The facilities provided by &lt;setjmp.h> should not be used" id="MISRAC2012-RULE_21_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_4" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="MISRAC2012-RULE_21_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_5" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="MISRAC2012-RULE_21_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_5" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="MISRAC2012-RULE_21_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_6" desc="The Standard Library input/output functions shall not be used" id="MISRAC2012-RULE_21_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_7" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="MISRAC2012-RULE_21_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_8" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_8" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_8" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_21_9" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="MISRAC2012-RULE_21_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_1" desc="Ensure resources are freed" id="MISRAC2012-RULE_22_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_10" desc="Properly use errno value" id="MISRAC2012-RULE_22_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_11" desc="Do not join or detach a thread that was previously joined or detached" id="MISRAC2012-RULE_22_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_12" desc="Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions" id="MISRAC2012-RULE_22_12-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_13" desc="Thread objects, thread synchronization objects and thread-specific storage pointers shall not have automatic storage duration" id="MISRAC2012-RULE_22_13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_14" desc="A thread synchronization object should not be initialized by a thread" id="MISRAC2012-RULE_22_14-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_14" desc="The second argument passed to the 'mtx_init()' function call should be either 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', or 'mtx_timed | mtx_recursive'" id="MISRAC2012-RULE_22_14-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_15" desc="A thread synchronization object should not be destroyed by a thread" id="MISRAC2012-RULE_22_15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_16" desc="Do not abandon unreleased locks" id="MISRAC2012-RULE_22_16-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_17" desc="Do not release a lock that has not been acquired" id="MISRAC2012-RULE_22_17-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_18" desc="Avoid double locking" id="MISRAC2012-RULE_22_18-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_19" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="MISRAC2012-RULE_22_19-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_2" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_2" desc="Do not free resources using invalid pointers" id="MISRAC2012-RULE_22_2-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_20" desc="A thread-specific storage should not be created by a thread" id="MISRAC2012-RULE_22_20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_3" desc="The same file shall not be opened for read and write access at the same time on different streams" id="MISRAC2012-RULE_22_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_4" desc="Avoid writing to a stream which has been opened as read only" id="MISRAC2012-RULE_22_4-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced" id="MISRAC2012-RULE_22_5-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="MISRAC2012-RULE_22_5-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_6" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_6-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_7" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="MISRAC2012-RULE_22_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_8" desc="Properly use errno value" id="MISRAC2012-RULE_22_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_22_9" desc="Properly use errno value" id="MISRAC2012-RULE_22_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_1" desc="A generic selection should only be expanded from a macro" id="MISRAC2012-RULE_23_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_1" desc="A generic selection used in a macro definition should have a macro parameter in the controlling expression" id="MISRAC2012-RULE_23_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_2" desc="A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression" id="MISRAC2012-RULE_23_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_3" desc="A generic selection shall indicate at least one non-default association" id="MISRAC2012-RULE_23_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_4" desc="A generic association shall list an appropriate type" id="MISRAC2012-RULE_23_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_5" desc="A generic selection should not depend on implicit pointer type conversion" id="MISRAC2012-RULE_23_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_6" desc="The controlling expression of a generic selection shall have an essential type that matches its standard type" id="MISRAC2012-RULE_23_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_6" desc="Enumerated types should not be mixed with integer types in generic selections" id="MISRAC2012-RULE_23_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_7" desc="A generic selection that is expanded from a macro shall evaluate its argument only once" id="MISRAC2012-RULE_23_7-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_23_8" desc="The default association shall be placed first or last in the association list" id="MISRAC2012-RULE_23_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="MISRAC2012-RULE_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="MISRAC2012-RULE_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="MISRAC2012-RULE_2_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in switch statement" id="MISRAC2012-RULE_2_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in 'for' loop" id="MISRAC2012-RULE_2_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRAC2012-RULE_2_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="MISRAC2012-RULE_2_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_1" desc="Avoid unreachable methods" id="MISRAC2012-RULE_2_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_2" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRAC2012-RULE_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_2" desc="Avoid unused values" id="MISRAC2012-RULE_2_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_3" desc="A function should not contain unused type declarations" id="MISRAC2012-RULE_2_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_3" desc="A source file should not contain unused type declarations" id="MISRAC2012-RULE_2_3-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_4" desc="A function should not contain unused local tag declarations" id="MISRAC2012-RULE_2_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_4" desc="A source file should not contain unused tag declarations" id="MISRAC2012-RULE_2_4-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_5" desc="A source file should not contain unused macro definitions" id="MISRAC2012-RULE_2_5-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_6" desc="A function should not contain unused label declarations" id="MISRAC2012-RULE_2_6-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_7" desc="There should be no unused parameters in functions" id="MISRAC2012-RULE_2_7-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_8" desc="A project should not contain unused variables with external linkage" id="MISRAC2012-RULE_2_8-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_8" desc="A project should not contain unused variables with internal linkage" id="MISRAC2012-RULE_2_8-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_2_8" desc="Avoid unused local variables" id="MISRAC2012-RULE_2_8-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_3_1" desc="The character sequence // shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C++-style comment" id="MISRAC2012-RULE_3_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_3_2" desc="Line-splicing shall not be used in // comments" id="MISRAC2012-RULE_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_4_1" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRAC2012-RULE_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_4_2" desc="Trigraphs shall not be used" id="MISRAC2012-RULE_4_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_1" desc="External identifiers shall be distinct" id="MISRAC2012-RULE_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_3" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="MISRAC2012-RULE_5_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_3" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="MISRAC2012-RULE_5_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="MISRAC2012-RULE_5_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="MISRAC2012-RULE_5_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="MISRAC2012-RULE_5_4-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="MISRAC2012-RULE_5_4-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)" id="MISRAC2012-RULE_5_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)" id="MISRAC2012-RULE_5_5-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_6" desc="A typedef name shall be a unique identifier" id="MISRAC2012-RULE_5_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_7" desc="A tag name shall be a unique identifier" id="MISRAC2012-RULE_5_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_8" desc="Identifiers that define objects with external linkage shall be unique" id="MISRAC2012-RULE_5_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_8" desc="Identifiers that define functions with external linkage shall be unique" id="MISRAC2012-RULE_5_8-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_9" desc="Identifiers that define objects with internal linkage shall be unique" id="MISRAC2012-RULE_5_9-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_5_9" desc="Identifiers that define functions with internal linkage shall be unique" id="MISRAC2012-RULE_5_9-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_6_1" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="MISRAC2012-RULE_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_6_2" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRAC2012-RULE_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_6_3" desc="A member of a union shall not be declared as a bit-field" id="MISRAC2012-RULE_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_1" desc="Octal constants (other than zero) shall not be used" id="MISRAC2012-RULE_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_2" desc="A 'U' suffix shall be applied to all constants of unsigned type" id="MISRAC2012-RULE_7_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_3" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="MISRAC2012-RULE_7_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_4" desc="A string literal shall not be modified" id="MISRAC2012-RULE_7_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_5" desc="Arguments of integer-constant macros should be decimal, octal, or hexadecimal constants with appropriate values" id="MISRAC2012-RULE_7_5-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_7_6" desc="The small integer variants of the minimum-width integer constant macros should not be used" id="MISRAC2012-RULE_7_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_1" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_1" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_10" desc="An inline function shall be declared with the static storage class" id="MISRAC2012-RULE_8_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_11" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="MISRAC2012-RULE_8_11-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_12" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRAC2012-RULE_8_12-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_13" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_14" desc="The restrict type qualifier shall not be used" id="MISRAC2012-RULE_8_14-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_15" desc="Explicit alignment specifiers in all declarations of an object with external linkage shall be the same" id="MISRAC2012-RULE_8_15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_15" desc="Explicit alignment specifiers in all declarations of an object with internal linkage shall be the same" id="MISRAC2012-RULE_8_15-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_16" desc="The zero-alignment specifier should not be used in an object declaration" id="MISRAC2012-RULE_8_16-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_17" desc="A declaration of an object should contain at most one explicit alignment specifier" id="MISRAC2012-RULE_8_17-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_2" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRAC2012-RULE_8_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_2" desc="Function types shall have named parameters" id="MISRAC2012-RULE_8_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_2" desc="Function types shall be in prototype form" id="MISRAC2012-RULE_8_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_3" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_3" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRAC2012-RULE_8_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_3" desc="All declarations of an object or function shall have compatible types" id="MISRAC2012-RULE_8_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_4" desc="A declaration shall be visible when an object or function with external linkage is defined" id="MISRAC2012-RULE_8_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_4" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_5" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="MISRAC2012-RULE_8_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_6" desc="An identifier with external linkage shall have no more then one external definition" id="MISRAC2012-RULE_8_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_6" desc="An identifier with external linkage shall have external definition" id="MISRAC2012-RULE_8_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_7" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="MISRAC2012-RULE_8_7-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_8" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRAC2012-RULE_8_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_8_9" desc="Objects shall be defined at block scope if they are only accessed from within a single function" id="MISRAC2012-RULE_8_9-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_1" desc="Avoid use before initialization" id="MISRAC2012-RULE_9_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRAC2012-RULE_9_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_3" desc="Arrays shall not be partially initialized" id="MISRAC2012-RULE_9_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_4" desc="An element of an object shall not be initialized more than once" id="MISRAC2012-RULE_9_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_5" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="MISRAC2012-RULE_9_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_6" desc="An initializer using chained designators shall not contain initializers without designators" id="MISRAC2012-RULE_9_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRAC2012-RULE_9_7" desc="Atomic objects shall be properly initialized before being accessed" id="MISRAC2012-RULE_9_7-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="MISRACPP2023-0_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="MISRACPP2023-0_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="MISRACPP2023-0_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code in switch statement" id="MISRACPP2023-0_0_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code in 'for' loop" id="MISRACPP2023-0_0_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRACPP2023-0_0_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="MISRACPP2023-0_0_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="MISRACPP2023-0_0_1-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last" id="MISRACPP2023-0_0_1-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_1" desc="A 'try' statement of a 'try-block' should contain a potentially-throwing statement" id="MISRACPP2023-0_0_1-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_0_2" desc="Avoid conditions that always evaluate to the same value" id="MISRACPP2023-0_0_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_1_1" desc="Avoid unused values" id="MISRACPP2023-0_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_1_2" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="MISRACPP2023-0_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_1" desc="Avoid unused local variables" id="MISRACPP2023-0_2_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_1" desc="A project should not contain unused variables with internal linkage" id="MISRACPP2023-0_2_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_2" desc="Eliminate unused parameters" id="MISRACPP2023-0_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_2" desc="There shall be no unused named parameters in virtual functions" id="MISRACPP2023-0_2_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_3" desc="Types declared in an unnamed namespace scope should be used at least once" id="MISRACPP2023-0_2_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_3" desc="Types declared in a block scope should be used at least once" id="MISRACPP2023-0_2_3-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_2_4" desc="Avoid unreachable methods" id="MISRACPP2023-0_2_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_3_1" desc="Do not use object representations to compare floating-point values" id="MISRACPP2023-0_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_3_1" desc="Floating-point expressions shall not be explicitly (syntactically) tested for equality (==) or inequality (!=)" id="MISRACPP2023-0_3_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_3_1" desc="Do not use floating point variables as loop counters" id="MISRACPP2023-0_3_1-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_3_1" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="MISRACPP2023-0_3_1-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-0_3_2" desc="Do not pass incorrect values to library functions" id="MISRACPP2023-0_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_0_1" desc="Each variable should be declared in a separate declaration statement" id="MISRACPP2023-10_0_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_1_1" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRACPP2023-10_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_1_1" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRACPP2023-10_1_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_1_1" desc="Declare reference parameters as const references whenever possible" id="MISRACPP2023-10_1_1-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_1_2" desc="The volatile qualifier shall be used appropriately" id="MISRACPP2023-10_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_2_1" desc="An enumeration shall be defined with an explicit underlying type" id="MISRACPP2023-10_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_2_1" desc="An explicit or implicit enumerator value shall not be the result of a narrowing conversion" id="MISRACPP2023-10_2_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_2_2" desc="Prefer Scoped Enums to Unscoped Enums" id="MISRACPP2023-10_2_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_2_3" desc="The numeric value of an unscoped enumeration with no fixed underlying type shall not be used" id="MISRACPP2023-10_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_3_1" desc="There shall be no unnamed namespaces in header files" id="MISRACPP2023-10_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-10_4_1" desc="The 'asm' declaration should not be used" id="MISRACPP2023-10_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-11_3_1" desc="C-style arrays shall not be used" id="MISRACPP2023-11_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-11_3_2" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="MISRACPP2023-11_3_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-11_6_1" desc="All non-class variables with automatic storage duration should be explicitly initialized" id="MISRACPP2023-11_6_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-11_6_2" desc="Avoid use before initialization" id="MISRACPP2023-11_6_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-11_6_3" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRACPP2023-11_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-12_2_1" desc="Do not declare member variables as bit-fields" id="MISRACPP2023-12_2_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-12_2_2" desc="A bit-field shall have an appropriate type" id="MISRACPP2023-12_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-12_2_2" desc="All enumeration values should be representable within the width of the bit-field" id="MISRACPP2023-12_2_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-12_2_3" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRACPP2023-12_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-12_3_1" desc="The union keyword should not be used" id="MISRACPP2023-12_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_1_1" desc="Classes should not be derived from virtual bases" id="MISRACPP2023-13_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_1_2" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="MISRACPP2023-13_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_1" desc="Each overriding virtual function shall be declared with the override or final specifier" id="MISRACPP2023-13_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_1" desc="Only one of virtual, override or final should be specified in a member function declaration" id="MISRACPP2023-13_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_2" desc="Parameters in an overriding virtual function shall not specify different default arguments" id="MISRACPP2023-13_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_3" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRACPP2023-13_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_3" desc="The parameters in all overrides of a function should either be unnamed or have identical names" id="MISRACPP2023-13_3_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-13_3_4" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="MISRACPP2023-13_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-14_1_1" desc="Non-static data members should be either all private or all public" id="MISRACPP2023-14_1_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_0_1" desc="Special member functions shall be provided appropriately" id="MISRACPP2023-15_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_0_1" desc="Destructor shall have a non-empty body" id="MISRACPP2023-15_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_0_2" desc="User-provided copy and move member functions of a class should have appropriate signatures" id="MISRACPP2023-15_0_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_1" desc="Do not use dynamic type of an object under construction" id="MISRACPP2023-15_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_1" desc="Do not use dynamic type of an object under destruction" id="MISRACPP2023-15_1_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_2" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="MISRACPP2023-15_1_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_3" desc="Constructors allowing for conversion should be made explicit" id="MISRACPP2023-15_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_3" desc="User-conversion cast operators should be made explicit" id="MISRACPP2023-15_1_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_4" desc="All direct, non-static data members of a non-aggregate class should be initialized at the top of a constructor body" id="MISRACPP2023-15_1_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_4" desc="All direct, non-static data members of an aggregate class should be initialized as soon as the object is created" id="MISRACPP2023-15_1_4-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_1_5" desc="A class shall only define an initializer-list constructor when it is the only constructor" id="MISRACPP2023-15_1_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-15_8_1" desc="Check for assignment to self in operator=" id="MISRACPP2023-15_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-16_5_1" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="MISRACPP2023-16_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-16_5_2" desc="The unary &amp; operator shall not be overloaded" id="MISRACPP2023-16_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-16_6_1" desc="If you'd like to support mixed-mode operations make operators a non-member functions" id="MISRACPP2023-16_6_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-17_8_1" desc="Function templates shall not be explicitly specialized" id="MISRACPP2023-17_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_1_1" desc="An exception object should not have pointer type" id="MISRACPP2023-18_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_1_2" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="MISRACPP2023-18_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_2_2" desc="The string handling functions from &lt;cstring>, &lt;cstdlib>, &lt;cwchar> and &lt;cinttypes> shall not be used" id="MISRACPP2023-18_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_3_1" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="MISRACPP2023-18_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_3_2" desc="A class type exception shall always be caught by reference" id="MISRACPP2023-18_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_3_3" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="MISRACPP2023-18_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_4_1" desc="Exception-unfriendly functions shall be noexcept" id="MISRACPP2023-18_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_4_1" desc="Functions used as initializers of non-constexpr, non-local variables shall be noexcept" id="MISRACPP2023-18_4_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_5_1" desc="Avoid throwing exceptions from functions that are declared not to throw" id="MISRACPP2023-18_5_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_5_2" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRACPP2023-18_5_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_5_2" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRACPP2023-18_5_2-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-18_5_2" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRACPP2023-18_5_2-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_0_1" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="MISRACPP2023-19_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_0_2" desc="Function-like macros shall not be defined" id="MISRACPP2023-19_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_0_3" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="MISRACPP2023-19_0_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_0_4" desc="#undef should only be used for macros defined previously in the same file" id="MISRACPP2023-19_0_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_1_1" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="MISRACPP2023-19_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_1_2" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRACPP2023-19_1_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_1_3" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRACPP2023-19_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_2_1" desc="Use multiple include guards" id="MISRACPP2023-19_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_2_2" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRACPP2023-19_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_2_3" desc="Non-standard characters should not occur in header file names in #include directives" id="MISRACPP2023-19_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_3_1" desc="The # and ## preprocessor operators should not be used" id="MISRACPP2023-19_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_3_2" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="MISRACPP2023-19_3_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_3_3" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRACPP2023-19_3_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_3_4" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="MISRACPP2023-19_3_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_3_5" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRACPP2023-19_3_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_6_1" desc="The #pragma directive shall not be used" id="MISRACPP2023-19_6_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-19_6_1" desc="The '_Pragma' operator should not be used" id="MISRACPP2023-19_6_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_10_1" desc="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="MISRACPP2023-21_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_10_2" desc="The facilities provided by &lt;setjmp.h> should not be used" id="MISRACPP2023-21_10_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_10_2" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="MISRACPP2023-21_10_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_10_3" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="MISRACPP2023-21_10_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_2_1" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="MISRACPP2023-21_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_2_3" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRACPP2023-21_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_2_4" desc="The macro offsetof, in library stddef.h, shall not be used" id="MISRACPP2023-21_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_1" desc="Dynamic heap memory allocation shall not be used" id="MISRACPP2023-21_6_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_2" desc="Dynamic heap memory allocation shall not be used" id="MISRACPP2023-21_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_2" desc="Any member function named 'allocate' or 'deallocate' enclosed by namespace 'std' should not be used" id="MISRACPP2023-21_6_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_2" desc="The 'std::unique_ptr::release' function should not be used" id="MISRACPP2023-21_6_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_3" desc="Destructor should not be called manually" id="MISRACPP2023-21_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_3" desc="Do not declare the 'new' and 'delete' operators" id="MISRACPP2023-21_6_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_3" desc="The memory management functions from the &lt;new> and &lt;memory> headers should not be used" id="MISRACPP2023-21_6_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_3" desc="Advanced memory management operators 'new' and 'delete' should not be used" id="MISRACPP2023-21_6_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_4" desc="Define both sized and unsized versions of operator delete" id="MISRACPP2023-21_6_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-21_6_5" desc="Do not delete objects with incomplete class at the point of deletion" id="MISRACPP2023-21_6_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-22_3_1" desc="The 'assert' macro shall not be used with a constant expression" id="MISRACPP2023-22_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-22_4_1" desc="The literal value zero shall be the only value assigned to errno" id="MISRACPP2023-22_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-23_11_1" desc="The raw pointer constructors of 'std::shared_ptr' and 'std::unique_ptr' should not be used" id="MISRACPP2023-23_11_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-24_5_1" desc="The character handling functions from &lt;cctype> and &lt;cwctype> shall not be used" id="MISRACPP2023-24_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-24_5_2" desc="The C++ Standard Library functions 'memcpy', 'memmove' and 'memcmp' from &lt;cstring> should not be used" id="MISRACPP2023-24_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_1" desc="The 'setlocale' function should not be used" id="MISRACPP2023-25_5_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_1" desc="The 'std::locale::global' function should not be used" id="MISRACPP2023-25_5_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_2" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRACPP2023-25_5_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_2" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRACPP2023-25_5_2-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_2" desc="The address of the 'localeconv', 'getenv', 'setlocale' or, 'strerror' function should not be taken" id="MISRACPP2023-25_5_2-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-25_5_3" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRACPP2023-25_5_3-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-26_3_1" desc="Avoid using vector&lt;bool>" id="MISRACPP2023-26_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_3_1" desc="Predicates shall not have persistent side effects" id="MISRACPP2023-28_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_1" desc="Do not use std::move on objects declared with the const or const &amp; type" id="MISRACPP2023-28_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_2" desc="The 'std::forward' function should be used to forward forwarding references" id="MISRACPP2023-28_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_2" desc="The 'std::forward' function should only be used to forward forwarding references" id="MISRACPP2023-28_6_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_3" desc="Do not subsequently use the argument to std::forward" id="MISRACPP2023-28_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_3" desc="Do not rely on the value of a moved-from object" id="MISRACPP2023-28_6_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-28_6_4" desc="The result of std::remove, std::remove_if, std::unique and empty shall be used" id="MISRACPP2023-28_6_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-30_0_1" desc="The input/output library stdio.h shall not be used" id="MISRACPP2023-30_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-30_0_1" desc="Prefer iostream.h to stdio.h" id="MISRACPP2023-30_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-30_0_2" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="MISRACPP2023-30_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_2" desc="Do not include headers deprecated in the C++17 standard" id="MISRACPP2023-4_1_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_2" desc="The 'uncaught_exception' function deprecated in the C++17 standard should not be used" id="MISRACPP2023-4_1_2-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_2" desc="Do not use throw exception specifications" id="MISRACPP2023-4_1_2-c" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_2" desc="A constexpr static data member should not be declared outside the class definition" id="MISRACPP2023-4_1_2-d" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_3" desc="Avoid incorrect shift operations" id="MISRACPP2023-4_1_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_3" desc="Avoid signed integer overflows" id="MISRACPP2023-4_1_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_3" desc="Avoid null pointer dereferencing" id="MISRACPP2023-4_1_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_1_3" desc="Avoid division by zero" id="MISRACPP2023-4_1_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRACPP2023-4_6_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRACPP2023-4_6_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRACPP2023-4_6_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRACPP2023-4_6_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRACPP2023-4_6_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRACPP2023-4_6_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-4_6_1" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRACPP2023-4_6_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_0_1" desc="Trigraphs shall not be used" id="MISRACPP2023-5_0_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="Do not declare entities in the standard library namespaces: posix, std and stdN" id="MISRACPP2023-5_10_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="Do not use identifiers which begin with one or two underscores (`_' or `__')" id="MISRACPP2023-5_10_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="An identifier shall not contain a double underscore '__'" id="MISRACPP2023-5_10_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="MISRACPP2023-5_10_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="A user-defined literal suffix should be directly preceded by a literal operator" id="MISRACPP2023-5_10_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="A macro identifier should have an appropriate form" id="MISRACPP2023-5_10_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_10_1" desc="Do not declare identifiers with names reserved in the standard library" id="MISRACPP2023-5_10_1-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_1" desc="Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" id="MISRACPP2023-5_13_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_2" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRACPP2023-5_13_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_3" desc="Octal constants (other than zero) shall not be used" id="MISRACPP2023-5_13_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_4" desc="A 'U' suffix shall be applied to all constants of unsigned type" id="MISRACPP2023-5_13_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_5" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="MISRACPP2023-5_13_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_6" desc="An integer-literal of type long long shall not use a single 'L' or 'l' in any suffix" id="MISRACPP2023-5_13_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_7" desc="String literals with different encoding prefixes shall not be concatenated" id="MISRACPP2023-5_13_7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_13_7" desc="String literals with and without encoding prefixes should not be concatenated" id="MISRACPP2023-5_13_7-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_7_1" desc="The character sequence /* shall not be used within a C-style comment" id="MISRACPP2023-5_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_7_2" desc="Sections of code should not be &quot;commented out&quot;" id="MISRACPP2023-5_7_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-5_7_3" desc="Line-splicing shall not be used in // comments" id="MISRACPP2023-5_7_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_1" desc="Always declare functions at file scope" id="MISRACPP2023-6_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_1" desc="Parameter names in function declarations should not be enclosed in parentheses" id="MISRACPP2023-6_0_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_1" desc="Local variable names in variable declarations should not be enclosed in parentheses" id="MISRACPP2023-6_0_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_2" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="MISRACPP2023-6_0_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_3" desc="The global namespace shall only contain main() and namespace declarations" id="MISRACPP2023-6_0_3-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_0_4" desc="The identifier main shall not be used for a function other than the global function main" id="MISRACPP2023-6_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_1" desc="The One Definition Rule shall not be violated" id="MISRACPP2023-6_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_2" desc="All declarations of an object or function shall have compatible types" id="MISRACPP2023-6_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_2" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="MISRACPP2023-6_2_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_3" desc="An identifier with external linkage shall have no more then one external definition" id="MISRACPP2023-6_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_3" desc="A type that is used in multiple translation units shall be defined in one and only one file" id="MISRACPP2023-6_2_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_3" desc="An inline function that is used in multiple translation units shall be defined in one and only one file" id="MISRACPP2023-6_2_3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_3" desc="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="MISRACPP2023-6_2_3-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_2_4" desc="Don't define entities with linkage in a header file" id="MISRACPP2023-6_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="MISRACPP2023-6_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="MISRACPP2023-6_4_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="MISRACPP2023-6_4_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="MISRACPP2023-6_4_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="MISRACPP2023-6_4_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_1" desc="Member variable names in derived classes should not be the same as member variable names in base classes" id="MISRACPP2023-6_4_1-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_2" desc="Never redefine an inherited nonvirtual function" id="MISRACPP2023-6_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_2" desc="Member functions declared in derived class should not hide functions declared in base classes" id="MISRACPP2023-6_4_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_4_3" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="MISRACPP2023-6_4_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_5_1" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRACPP2023-6_5_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_5_2" desc="Do not use static keyword except inside functions and classes" id="MISRACPP2023-6_5_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_5_2" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="MISRACPP2023-6_5_2-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_7_1" desc="Local variables shall not have static storage duration" id="MISRACPP2023-6_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_7_2" desc="Avoid unencapsulated global variables (including variables declared in namespaces and public static members)" id="MISRACPP2023-6_7_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_1" desc="Do not point to a wrapped object that has been freed" id="MISRACPP2023-6_8_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_1" desc="Do not read the value of a non-active union field" id="MISRACPP2023-6_8_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_1" desc="Do not use an object after its lifetime has ended" id="MISRACPP2023-6_8_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_2" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRACPP2023-6_8_2-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_2" desc="Never return lambdas that capture local objects by reference" id="MISRACPP2023-6_8_2-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_3" desc="The address of an object with automatic storage duration shall not be assigned to an object with a greater lifetime" id="MISRACPP2023-6_8_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_8_4" desc="Member functions returning references to their object should be ref-qualified appropriately" id="MISRACPP2023-6_8_4-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_9_1" desc="The same type aliases shall be used in all declarations of the same entity" id="MISRACPP2023-6_9_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-6_9_2" desc="The names of the standard signed integer types and standard unsigned integer types should not be used" id="MISRACPP2023-6_9_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_1" desc="There shall be no conversion from type bool" id="MISRACPP2023-7_0_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_2" desc="There shall be no conversion to type bool" id="MISRACPP2023-7_0_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_3" desc="The plain char type shall be used only for the storage and use of character values" id="MISRACPP2023-7_0_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_3" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="MISRACPP2023-7_0_3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_4" desc="Operands of bitwise and complement operators shall have an unsigned type" id="MISRACPP2023-7_0_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_4" desc="Operands of shift operators shall have an unsigned type" id="MISRACPP2023-7_0_4-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_5" desc="Integral promotion and the usual arithmetic conversions shall not change the signedness or the type category of an operand" id="MISRACPP2023-7_0_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_0_6" desc="Assignment between numeric types shall be appropriate" id="MISRACPP2023-7_0_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_11_1" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="MISRACPP2023-7_11_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_11_1" desc="The 'NULL' identifier should not be used" id="MISRACPP2023-7_11_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_11_2" desc="Do not pass an expression with array type to a function with a pointer or array type parameter" id="MISRACPP2023-7_11_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-7_11_3" desc="A conversion from function type to pointer-to-function type shall only occur in appropriate contexts" id="MISRACPP2023-7_11_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_0_1" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="MISRACPP2023-8_0_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_0_1" desc="Use parentheses to indicate the precedence of operators in expressions" id="MISRACPP2023-8_0_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_14_1" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRACPP2023-8_14_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_18_1" desc="An object shall not be assigned or copied to an overlapping object" id="MISRACPP2023-8_18_1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_18_1" desc="An object shall not be assigned to an overlapping object" id="MISRACPP2023-8_18_1-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_18_1" desc="An object shall not be assigned to an overlapping object" id="MISRACPP2023-8_18_1-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_18_2" desc="The result of a built-in assignment operator should not be used" id="MISRACPP2023-8_18_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_19_1" desc="The comma operator shall not be used" id="MISRACPP2023-8_19_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_1_1" desc="A non-transient lambda shall not implicitly capture this" id="MISRACPP2023-8_1_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_1_2" desc="Variables should be captured explicitly in a non-transient lambda" id="MISRACPP2023-8_1_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_20_1" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="MISRACPP2023-8_20_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_20_1" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="MISRACPP2023-8_20_1-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_1" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="MISRACPP2023-8_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_10" desc="Do not use recursion" id="MISRACPP2023-8_2_10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_11" desc="An argument passed via ellipsis shall have an appropriate type" id="MISRACPP2023-8_2_11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_2" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="MISRACPP2023-8_2_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_3" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="MISRACPP2023-8_2_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_4" desc="Casts shall not be performed between a pointer to a function and any other type" id="MISRACPP2023-8_2_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_5" desc="Avoid using reinterpret_cast" id="MISRACPP2023-8_2_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_6" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="MISRACPP2023-8_2_6-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_6" desc="An object with enumeration type shall not be converted to an object with pointer type" id="MISRACPP2023-8_2_6-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_7" desc="A cast should not convert a pointer type to an integral type" id="MISRACPP2023-8_2_7-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_7" desc="A cast should not convert a pointer type to 'intptr_t' and 'uintptr_t' types" id="MISRACPP2023-8_2_7-b" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_8" desc="A cast should not convert a pointer type to an integral type" id="MISRACPP2023-8_2_8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_2_9" desc="The operand to typeid shall not be an expression of polymorphic class type" id="MISRACPP2023-8_2_9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_3_1" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="MISRACPP2023-8_3_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_3_2" desc="The built-in unary + operator should not be used" id="MISRACPP2023-8_3_2-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_1" desc="Avoid accessing arrays out of bounds" id="MISRACPP2023-8_7_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_1" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRACPP2023-8_7_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_1" desc="Avoid overflow when reading from a buffer" id="MISRACPP2023-8_7_1-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_1" desc="Avoid overflow when writing to a buffer" id="MISRACPP2023-8_7_1-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_1" desc="Avoid overflow due to reading a not zero terminated string" id="MISRACPP2023-8_7_1-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_7_2" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRACPP2023-8_7_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-8_9_1" desc="Do not compare two unrelated pointers" id="MISRACPP2023-8_9_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_2_1" desc="Expression statements shall not be explicit calls to constructors of temporary objects only" id="MISRACPP2023-9_2_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_3_1" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="MISRACPP2023-9_3_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_3_1" desc="'if' and 'else' should be followed by a compound statement" id="MISRACPP2023-9_3_1-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_1" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="MISRACPP2023-9_4_1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="The first or the last label of a switch statement should be the 'default' label unless all enumeration values are tested" id="MISRACPP2023-9_4_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="Every switch branch should be unconditionally terminated" id="MISRACPP2023-9_4_2-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRACPP2023-9_4_2-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRACPP2023-9_4_2-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="Every switch statement shall have at least two switch-clauses" id="MISRACPP2023-9_4_2-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="The 'switch' statement should not contain labels other than 'case' and 'default'" id="MISRACPP2023-9_4_2-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_4_2" desc="The condition of a 'switch' statement should only be preceded by an optional simple-declaration" id="MISRACPP2023-9_4_2-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_5_1" desc="Legacy 'for' statements should be simple" id="MISRACPP2023-9_5_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_5_2" desc="A for-range-initializer shall contain at most one function call" id="MISRACPP2023-9_5_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_6_1" desc="The goto statement shall not be used" id="MISRACPP2023-9_6_1-a" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_6_2" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRACPP2023-9_6_2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_6_3" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRACPP2023-9_6_3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_6_4" desc="Never return from functions that should not return" id="MISRACPP2023-9_6_4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MISRACPP2023-9_6_5" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRACPP2023-9_6_5-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Avoid hiding the global new" id="MRM-32" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Declare a copy assignment operator for classes with dynamically allocated memory" id="MRM-37" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Declare a copy constructor for classes with dynamically allocated memory" id="MRM-38" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Adhere to convention when writing new" id="MRM-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Write operator delete if you write operator new" id="MRM-26" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="MRM" desc="Write operator delete[] if you write operator new[]" id="MRM-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Identifiers for constant and enumerator values shall be lowercase" id="NAMING-42" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="All &quot;#define&quot; constants shall be in uppercase" id="NAMING-01" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="In an enumerated list, list members (elements) shall be in uppercase and names or tags for the list shall be in lowercase" id="NAMING-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Use lowercase for file names" id="NAMING-03" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="NAMING" desc="Global prefixes should only be used for global variables" id="NAMING-04" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin local variable names with a lowercase letters" id="NAMING-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin global variable names with a lowercase letters" id="NAMING-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin member variable names with a lowercase letters" id="NAMING-07" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all boolean type variables with 'b'" id="NAMING-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin class, struct, union, enum, and typedef names with an uppercase letter" id="NAMING-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="The names of abstract data types, structures, typedefs, and enumerated types are to begin with an uppercase letter" id="NAMING-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="The name of enumeration type shall begin with an uppercase letter and contain a suffix '_t' at the end" id="NAMING-11" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="The names of structures shall begin with an uppercase letter and contain a suffix '_t' at the end" id="NAMING-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin constant variables with 'c'" id="NAMING-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin class data member names with 'its'" id="NAMING-14" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all double type variable with 'd'" id="NAMING-15" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all float type variables with 'f'" id="NAMING-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all function names with uppercase letter" id="NAMING-17" sev="3">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin global variable names with 'the'" id="NAMING-18" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all integer type variable with 'i'" id="NAMING-19" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="NAMING" desc="Functions that begin with 'is' should return boolean values" id="NAMING-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all long integer variables with 'li'" id="NAMING-21" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Prefix a variable type 'pointer' with a 'p' character" id="NAMING-22" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all short integer variables with 'si'" id="NAMING-23" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all signed character variables with 'c'" id="NAMING-24" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all terminated characters string variables with 'sz'" id="NAMING-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all unsigned character type variables with 'uc'" id="NAMING-26" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Begin all unsigned integer type variables with 'ui'" id="NAMING-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Use lowercase letters for structure and union member names" id="NAMING-28" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Append names of non-scalar typedefs with &quot;_t&quot;" id="NAMING-29" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Implementation files in C always have the file name extension &quot;.c&quot;" id="NAMING-30" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Do not use typenames that differ only by the use of uppercase and lowercase letters" id="NAMING-31" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="An include file for a class should have a file name of the form &lt;class name> + extension" id="NAMING-32" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Do not use identifiers which begin with one or two underscores (`_' or `__')" id="NAMING-33" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="NAMING" desc="An identifier shall not contain a double underscore '__'" id="NAMING-33_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Global function names should start with lowercase" id="NAMING-34" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="NAMING" desc="Member function names should start with lowercase" id="NAMING-35" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Names of parameters in declaration and definition should be identical" id="NAMING-36" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Include files in C++ always have the file name extension '.hh'" id="NAMING-37" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="Implementation files in C++ always have the file name extension &quot;.cc&quot;" id="NAMING-38" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="NAMING" desc="Inline definition files always have the file name extension &quot;.icc&quot;" id="NAMING-39" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter" id="NAMING-40" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="Header files will always have a file name extension of '.h'" id="NAMING-41" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" id="NAMING-43" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING" desc="All letters contained in function and variable names will be composed entirely of lowercase letters" id="NAMING-44" sev="3">
               <Stats authTot="19;" total="19"/>
            </Rule>
            <Rule cat="NAMING" desc="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" id="NAMING-45" sev="3">
               <Stats authTot="24;" total="24"/>
            </Rule>
            <Rule cat="NAMING" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="NAMING-46" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Different identifiers shall be typographically unambiguous" id="NAMING-47" sev="3">
               <Stats authTot="13;" total="13"/>
            </Rule>
            <Rule cat="NAMING" desc="The \ character should not occur in a header file name" id="NAMING-48" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="NAMING-51" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="A user-defined literal suffix should be directly preceded by a literal operator" id="NAMING-51_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Universal character names shall be used only inside character or string literals" id="NAMING-52" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" id="NAMING-53" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Use visually distinct identifiers" id="NAMING-54" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="A macro identifier should have an appropriate form" id="NAMING-55" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Do not declare identifiers with names reserved in the standard library" id="NAMING-56" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="The parameters in all overrides of a function should either be unnamed or have identical names" id="NAMING-57" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" id="NAMING-49" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="NAMING-50" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for array variables and parameters" id="NAMING-HN-01" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for bool types" id="NAMING-HN-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for bool pointer, array, or reference types" id="NAMING-HN-03" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for byte types" id="NAMING-HN-04" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for byte pointer, array, or reference types" id="NAMING-HN-05" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for char types" id="NAMING-HN-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for array of char types" id="NAMING-HN-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for pointer, array, or reference to array of char types" id="NAMING-HN-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for char pointer, array, or reference types" id="NAMING-HN-09" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for char pointer or reference types" id="NAMING-HN-10" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for constant parameters" id="NAMING-HN-11" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for double-precision floating point types" id="NAMING-HN-12" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for double-precision floating point pointer, array, or reference types" id="NAMING-HN-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for dword types" id="NAMING-HN-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for dword pointer, array, or reference types" id="NAMING-HN-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for dynamically allocated array" id="NAMING-HN-16" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for floating point types" id="NAMING-HN-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for floating point pointer, array, or reference types" id="NAMING-HN-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for class declaration" id="NAMING-HN-19" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for structs declaration" id="NAMING-HN-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for ifstream type variables and parameters" id="NAMING-HN-21" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for int types" id="NAMING-HN-22" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for int pointer, array, or reference types" id="NAMING-HN-23" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for istream type parameters and variables" id="NAMING-HN-24" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for long int types" id="NAMING-HN-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for long double-precision floating point types" id="NAMING-HN-26" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for long double-precision floating point pointer, array, or reference types" id="NAMING-HN-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for long int pointer, array, or reference types" id="NAMING-HN-28" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for member variables" id="NAMING-HN-29" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for int types" id="NAMING-HN-30" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for int pointer, array, or reference types" id="NAMING-HN-31" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for ofstream type parameters and variables" id="NAMING-HN-32" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for ostream type parameters and variables" id="NAMING-HN-33" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for pointer" id="NAMING-HN-34" sev="3">
               <Stats authTot="7;" total="7"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for reference parameters" id="NAMING-HN-35" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for short int types" id="NAMING-HN-36" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for short int pointer, array, or reference types" id="NAMING-HN-37" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for static variables" id="NAMING-HN-38" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for string types" id="NAMING-HN-39" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for string pointer, array, or reference types" id="NAMING-HN-40" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for unsigned types" id="NAMING-HN-41" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for void pointer types" id="NAMING-HN-42" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for word types" id="NAMING-HN-43" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="NAMING-HN" desc="Hungarian notation for word pointer, array, or reference types" id="NAMING-HN-44" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="OOP" desc="Do not directly access global data from a constructor" id="OOP-08" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OOP" desc="Avoid calling virtual functions from constructors" id="OOP-16" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OOP" desc="Make destructors virtual in base classes" id="OOP-24" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OOP" desc="A pointer to an abstract class shall not be converted to a pointer of a class that inherits from that abstract class" id="OOP-29" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OOP" desc="Make base class destructors public and virtual, or protected and nonvirtual" id="OOP-31" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OOP" desc="If a class has virtual functions it shall have a virtual destructor" id="OOP-23" sev="2">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="OOP" desc="Public member functions shall not return non-const handles to private/protected class-data" id="OOP-36" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="OPT" desc="Pass objects by reference instead of by value" id="OPT-14" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Protect against command injection" id="OWASP2017-A1-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Avoid printing tainted data on the output console" id="OWASP2017-A1-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Protect against environment injection" id="OWASP2017-A1-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Exclude unsanitized user input from format strings" id="OWASP2017-A1-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Protect against SQL injection" id="OWASP2017-A1-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A1" desc="Avoid passing unvalidated binary data to log methods" id="OWASP2017-A1-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A10" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2017-A10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A2" desc="Do not use weak encryption functions" id="OWASP2017-A2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A3" desc="Properly seed pseudorandom number generators" id="OWASP2017-A3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A4" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2017-A4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A5" desc="Protect against file name injection" id="OWASP2017-A5-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A5" desc="Observe correct revocation order while relinquishing privileges" id="OWASP2017-A5-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A5" desc="Ensure that privilege relinquishment is successful" id="OWASP2017-A5-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A6" desc="Properly use errno value" id="OWASP2017-A6-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A6" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2017-A6-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2017-A6" desc="Do not leave 'catch' blocks empty" id="OWASP2017-A6-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API10" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2019-API10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API10" desc="Do not use 'syslog' function for logging purposes" id="OWASP2019-API10-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API2" desc="Do not use weak encryption functions" id="OWASP2019-API2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid buffer overflow due to defining incorrect format limits" id="OWASP2019-API3-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid overflow due to reading a not zero terminated string" id="OWASP2019-API3-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid overflow when reading from a buffer" id="OWASP2019-API3-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid overflow when writing to a buffer" id="OWASP2019-API3-g" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="OWASP2019-API3-h" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid buffer read overflow from tainted data" id="OWASP2019-API3-i" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid buffer write overflow from tainted data" id="OWASP2019-API3-j" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid race conditions while checking for the existence of a symbolic link" id="OWASP2019-API3-m" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Do not pass empty container iterators to std algorithms as destinations" id="OWASP2019-API3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid accessing arrays out of bounds" id="OWASP2019-API3-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid accessing arrays and pointers out of bounds" id="OWASP2019-API3-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Properly seed pseudorandom number generators" id="OWASP2019-API3-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid passing sensitive data to functions that write to log files" id="OWASP2019-API3-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="OWASP2019-API3-p" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Avoid functions which use time from MFC library" id="OWASP2019-API3-o" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="OWASP2019-API3-q" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API3" desc="Usage of system properties (environment variables) should be restricted" id="OWASP2019-API3-n" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API4" desc="Ensure resources are freed" id="OWASP2019-API4-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API4" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="OWASP2019-API4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API7" desc="Properly use errno value" id="OWASP2019-API7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API7" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2019-API7-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API7" desc="Do not leave 'catch' blocks empty" id="OWASP2019-API7-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Protect against command injection" id="OWASP2019-API8-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Avoid printing tainted data on the output console" id="OWASP2019-API8-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Protect against environment injection" id="OWASP2019-API8-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Protect against file name injection" id="OWASP2019-API8-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Exclude unsanitized user input from format strings" id="OWASP2019-API8-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Protect against SQL injection" id="OWASP2019-API8-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2019-API8-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Use care to ensure that LoadLibrary() will load the correct library" id="OWASP2019-API8-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Avoid passing dynamically created strings into exec" id="OWASP2019-API8-i" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API8" desc="Avoid passing user input into methods as parameters" id="OWASP2019-API8-j" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="All usage of assembler shall be documented" id="OWASP2019-API9-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="Use of floating-point arithmetic shall be documented" id="OWASP2019-API9-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="All uses of the #pragma directive shall be documented and explained" id="OWASP2019-API9-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="Objects or functions with external linkage shall be declared in a header file" id="OWASP2019-API9-e" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="Assert liberally to document internal assumptions and invariants" id="OWASP2019-API9-a" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="When using enum, the values of each member should be explicitly declared" id="OWASP2019-API9-b" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2019-API9" desc="Document integer division" id="OWASP2019-API9-f" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A1" desc="Protect against file name injection" id="OWASP2021-A1-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A1" desc="Observe correct revocation order while relinquishing privileges" id="OWASP2021-A1-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A1" desc="Ensure that privilege relinquishment is successful" id="OWASP2021-A1-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A2" desc="Properly seed pseudorandom number generators" id="OWASP2021-A2-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Protect against command injection" id="OWASP2021-A3-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Avoid printing tainted data on the output console" id="OWASP2021-A3-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Protect against environment injection" id="OWASP2021-A3-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Exclude unsanitized user input from format strings" id="OWASP2021-A3-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Protect against SQL injection" id="OWASP2021-A3-f" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A3" desc="Avoid passing unvalidated binary data to log methods" id="OWASP2021-A3-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A4" desc="Avoid passing sensitive data to functions that write to log files" id="OWASP2021-A4-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A5" desc="Properly use errno value" id="OWASP2021-A5-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A5" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2021-A5-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A5" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2021-A5-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A5" desc="Do not leave 'catch' blocks empty" id="OWASP2021-A5-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A7" desc="Do not use weak encryption functions" id="OWASP2021-A7-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A8" desc="Use care to ensure that LoadLibrary() will load the correct library" id="OWASP2021-A8-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="OWASP2021-A9" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2021-A9-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PARSER" desc="Parser warning" id="PARSER-WARNING" sev="4">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="PARSER" desc="Parser remark" id="PARSER-REMARK" sev="5">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PB" desc="Do not call delete on non-pointers" id="PB-13" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="Don't define entities with linkage in a header file" id="PFO-01" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="Use multiple include guards" id="PFO-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="An include file should not contain more than one class definition" id="PFO-03" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PFO" desc="File with extension '.c' may not include other files with extension '.c'" id="PFO-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="Never include other files in a file with extension '.icc'" id="PFO-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="Use multiple include guards with pattern based on the header file name" id="PFO-07" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PFO" desc="Use mechanism that prevents multiple inclusion of the file i.e. include guards or &quot;#pragma once&quot; preprocessor directive" id="PFO-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="&quot;#pragma once&quot; preprocessor directive should not be used in source files" id="PFO-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PFO" desc="Do not define more than on class in a header file" id="PFO-10" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PFO" desc="Every implementation file should declare a local constant string that describes the file" id="PFO-04" sev="5">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="PORT" desc="Don't use hard coded value of offset in structures" id="PORT-03" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Don't use hex constant '0xffffffff' as an error marker" id="PORT-04" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="A pointer to a long should not be casted to an int pointer" id="PORT-05" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not cast an int pointer to a long pointer" id="PORT-11" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier" id="PORT-26" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Assigning result of ints operation to long without casting at least one of the ints is not allowed" id="PORT-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not assign a long int to an int" id="PORT-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not pass long casted to an int in function call" id="PORT-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Constant assignment to long should not involve int literals" id="PORT-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not initialize a long int with int literals" id="PORT-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not assign the value from 32 bit multiplication to long type" id="PORT-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="The type int shall always be declared as unsigned int or signed int" id="PORT-13" sev="3">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="PORT" desc="Avoid conversions from &quot;shorter&quot; type to &quot;longer&quot; type in assignment" id="PORT-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not cast from &quot;shorter&quot; type to &quot;longer&quot; type" id="PORT-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Avoid conversions from a &quot;shorter&quot; type to a &quot;longer&quot; type in function calls" id="PORT-16" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PORT" desc="Don't use 'i64' or 'L' suffixes directly" id="PORT-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Instead of casting a long type operand of an expression to int cast the result of the expression" id="PORT-19" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not declare variables of long type directly" id="PORT-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not assign a long value to a double" id="PORT-21" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="The names of identifiers should not be longer than 64 characters" id="PORT-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Avoid implicit conversions to a type of narrower size" id="PORT-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Avoid conversions of constant values to a narrower type" id="PORT-28" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="A pointer to a structure should not be passed to a function that writes data to a file" id="PORT-29" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Type long double shall not be used" id="PORT-32" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Type wchar_t shall not be used" id="PORT-33" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C++ external identifiers should differ in the first 64 characters" id="PORT-34_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters" id="PORT-34_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters" id="PORT-34_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C external identifiers should differ in the first 31 characters" id="PORT-35_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C internal identifiers should differ from external identifiers in the first 31 characters" id="PORT-35_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="User-specified C internal identifiers declared in the same scope should differ in the first 31 characters" id="PORT-35_c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="The names of identifiers should not be longer than 31 characters" id="PORT-36_a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="The names of macro identifiers should not be longer than 31 characters" id="PORT-36_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="An integer-literal of type long long shall not use a single 'L' or 'l' in any suffix" id="PORT-38" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not throw an exception across execution boundaries" id="PORT-30" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Do not pass a nonstandard-layout type object across execution boundaries" id="PORT-31" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="PORT-01" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Use arrays of int types instead of large arrays of longs" id="PORT-22" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Use arrays of int types instead of dynamic allocated large arrays of longs" id="PORT-23" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PORT" desc="Don't use large arrays of pointers to bool, char, short, int and float types" id="PORT-24" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Don't use macros in include statement" id="PREPROC-02" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="In a macro function, use parentheses before and after multiplication or division" id="PREPROC-05" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Do not allow absolute or relative path names in #include statements" id="PREPROC-06" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #include directive shall use the &lt;filename.h> notation to include header files" id="PREPROC-09" sev="2">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="PREPROC" desc="Avoid using macro definitions" id="PREPROC-01" sev="3">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #include pre-processor directive will only be used to include header (*.h) files" id="PREPROC-08" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10_b" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10_c" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="PREPROC-11" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #if preprocessor directive should not be used" id="PREPROC-11_b" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PREPROC" desc="C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers" id="PREPROC-12" sev="3">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="PREPROC" desc="Macro should not contain token pasting, variable argument list nor recursive macro calls" id="PREPROC-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="All macros must expand into complete syntactic units" id="PREPROC-14" sev="3">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="PREPROC" desc="Pointer dereference operations may not be hidden in macro definitions" id="PREPROC-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="PREPROC-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The input/output library stdio.h shall not be included" id="PREPROC-18" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PREPROC" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="PREPROC-19" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Match the filename in a #include directive to the one on the filesystem" id="PREPROC-20" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="#error directive shall not be used" id="PREPROC-22" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #pragma directive shall not be used" id="PREPROC-23" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The '_Pragma' operator should not be used" id="PREPROC-23_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator" id="PREPROC-24" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="#undef shall not be used" id="PREPROC-25" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="#undef should only be used for macros defined previously in the same file" id="PREPROC-25_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" id="PREPROC-26" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="PREPROC" desc="Do not use the 'bool', 'false' or 'true' identifiers in the #undef directive" id="PREPROC-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Function-like macros shall not be defined" id="PREPROC-28" sev="3">
               <Stats authTot="8;" total="8"/>
            </Rule>
            <Rule cat="PREPROC" desc="Don't redefine primitive types" id="PREPROC-03" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Don't define part of statement" id="PREPROC-04" sev="4">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="PREPROC" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="PREPROC-17" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Incorrect 'NULL' definition" id="PREPROC-07" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="PREPROC" desc="Avoid token concatenation that may produce universal character names" id="PREPROC-21" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="The methods inside the SIGNAL and SLOT macros have to exist" id="QT-04" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Do not force thread termination by calling QThread::terminate()" id="QT-07" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Do not call new on QMutexLocker" id="QT-09" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Do not directly set specific Widget attributes that are set by Qt kernel" id="QT-12" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Every QObject subclass should contain a Q_OBJECT macro" id="QT-01" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="QObject must not be inherited more than one time" id="QT-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="It's only possible to connect a signal to a slot or a signal to another signal" id="QT-03" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Mark signal emissions with the keyword &quot;emit&quot; to distinguish a signal emission from a normal method call" id="QT-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Do not set Idle or Critical priority to QThreads. Use High/Low/Med only" id="QT-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="If using lock on a mutex in a function, release the lock in the same function" id="QT-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Declare a copy constructor and operator= for any Qt - inherited objects that have pointers" id="QT-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Never mix const and non-const iterators in assignment" id="QT-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="If you use Q_DECLARE_FLAGS, you must also use Q_DECLARE_OPERATORS_FOR_FLAGS" id="QT-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Q_DECLARE_OPERATORS_FOR_FLAGS must be in the global namespace, Q_DECLARE_FLAGS inside the enum's namespace" id="QT-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="The getters and setters of a Q_PROPERTY must exist and the types must match" id="QT-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Properties of enum types must use Q_ENUMS" id="QT-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Non-const function should not be called on the Qt object" id="QT-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="QT" desc="Do not use setWindowFlags function on a Widget" id="QT-11" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="SECURITY" desc="Never use gets()" id="SECURITY-16" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="To make copying efficient, correct, and immune to the slicing problem create containers of pointers instead of containers of objects" id="STL-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Call empty instead of checking size() against zero" id="STL-03" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Avoid using iterative calls to insert in an explicit loop" id="STL-04" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member functions" id="STL-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Instead of anonymous istream_iterator objects use istream_iterator names when used as function parameters" id="STL-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="When using containers of newed pointers, remember to delete the pointers before the container is destroyed" id="STL-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Never create containers of auto_ptrs" id="STL-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Avoid using remove algorithm with list and standard associative containers" id="STL-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Prefer vector and string to dynamically allocated arrays" id="STL-10" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="STL" desc="Use reserve to avoid unnecessary reallocations" id="STL-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Each vector and string should be checked if it is not empty before it is passed to C function" id="STL-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Avoid using vector&lt;bool>" id="STL-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Specify comparison types for associative containers of pointers" id="STL-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="For associative containers never use comparison function returning true for equal values" id="STL-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="For associative containers never use comparison function returning true for equal values" id="STL-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Prefer iterator to const iterator, reverse_iterator, and const_reverse_iterator" id="STL-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Use distance and advance to convert a container's const_iterators to iterators" id="STL-19" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Make sure destination ranges are big enough" id="STL-22" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Follow remove-like algorithms by erase to remove elements from a container" id="STL-23" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Avoid using remove and similar algorithms (i.e., remove_if and unique) on containers of dynamically allocated pointers" id="STL-24" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Proper implementation of copy_if should not be based on returning the remove_copy_if with a not1 in front of the predicate" id="STL-26" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="If accumulate() is used on a container of floating point values, use floating point value as initial one" id="STL-27" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Design functor classes for pass-by-value" id="STL-28" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Make predicates const pure functions" id="STL-29" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Each functor class should has only one operator() function, and it's parameter and return types should be passed to unary_function or binary_function" id="STL-30" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="You must employ ptr_fun, mem_fun, or mem_fun_ref whenever you pass a function to an STL component" id="STL-31" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Make sure less&lt;T> means operator&lt;" id="STL-32" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Prefer algorithm calls to hand-written loops" id="STL-33" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Prefer member functions to algorithms with the same names" id="STL-34" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Do not rely on the conversion of count()'s nonzero values to true and zero to false" id="STL-35" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Do not use an iterator range that isn't really a range" id="STL-36" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="C-style arrays shall not be used" id="STL-37" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="STL" desc="Use != instead of &lt; to compare iterators" id="STL-38" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Use traits classes in conjunction with overloading" id="STL-39" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification" id="STL-40" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Do not declare the non-member to be an overloading of std::swap" id="STL-41" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Member version of swap should never throw exceptions" id="STL-42" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Consider using vector&lt;char> instead of string" id="STL-11" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="It is necessary to be careful when using reverse_iterator's base iterator for erasure purposes" id="STL-20" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Consider istreambuf_iterators for character-by-character input" id="STL-21" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="If you pass a sorted range to an algorithm that also takes a comparison function, be sure that the comparison function you pass behaves the same as the one you used to sort the range" id="STL-25" sev="4">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="STL" desc="Instead of trying to write the container-independent code use class encapsulation" id="STL-01" sev="5">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Factor parameter-independent code out of templates" id="TEMPL-01" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Define non-member functions inside templates when type conversions are desired" id="TEMPL-02" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Do not overload functions within a template class" id="TEMPL-03" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="In template global functions use 'typename' to identify nested dependent type names" id="TEMPL-04" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="In template classes use 'typename' to identify nested dependent type names" id="TEMPL-05" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Don't change default arguments of virtual functions in template classes" id="TEMPL-06" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="TEMPL-07" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="The viable function set for a function call should either contain no function specializations, or only contain function specializations" id="TEMPL-08" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Overloaded function templates shall not be explicitly specialized" id="TEMPL-09" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Function templates shall not be explicitly specialized" id="TEMPL-09_b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="TEMPL-10" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="TEMPL-11" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="TEMPL-12" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Do not declare non-member generic functions in associated namespaces" id="TEMPL-13" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="The function shall resolve to a function declared previously in the translation unit" id="TEMPL-14" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Declare 'extern' an explicitly instantiated template" id="TEMPL-15" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="TEMPL-16" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="TEMPL-17" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="TEMPL" desc="A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations" id="TEMPL-18" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
         </RulesList>
         <CategoriesList>
            <Category desc="DISA ASD STIG" name="APSC_DV" total="105">
               <Category desc="APSC_DV-001850 The application must not display passwords/PINs as clear text." name="APSC_DV-001850" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001750 The application must transmit only cryptographically-protected passwords." name="APSC_DV-001750" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-000480 The application must enforce approved authorizations for controlling the flow of information within the system based on organization-defined information flow control policies." name="APSC_DV-000480" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-000160 The application must implement DoD-approved encryption to protect the confidentiality of remote access sessions." name="APSC_DV-000160" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002460 The application must maintain the confidentiality and integrity of information during preparation for transmission." name="APSC_DV-002460" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002560 The application must not be subject to input handling vulnerabilities." name="APSC_DV-002560" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-003110 The application must not contain embedded authentication data." name="APSC_DV-003110" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002000 The application must terminate all network connections associated with a communications session at the end of the session." name="APSC_DV-002000" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002440 The application must protect the confidentiality and integrity of transmitted information." name="APSC_DV-002440" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002540 The application must not be vulnerable to SQL Injection." name="APSC_DV-002540" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-000500 The application must prevent non-privileged users from executing privileged functions to include disabling, circumventing, or altering implemented security safeguards/countermeasures." name="APSC_DV-000500" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001995 The application must not be vulnerable to race conditions." name="APSC_DV-001995" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002520 The application must protect from canonical representation vulnerabilities." name="APSC_DV-002520" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-003235 The application must not be subject to error handling vulnerabilities." name="APSC_DV-003235" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002400 The application must restrict the ability to launch Denial of Service (DoS) attacks against itself or other information systems." name="APSC_DV-002400" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002290 The application must use the Federal Information Processing Standard (FIPS) 140-2-validated cryptographic modules and random number generator if the application implements encryption, key exchange, digital signature, and hash functionality." name="APSC_DV-002290" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002390 XML-based applications must mitigate DoS attacks by using XML filters, parser options, or gateways." name="APSC_DV-002390" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002590 The application must not be vulnerable to overflow attacks." name="APSC_DV-002590" total="12">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-000170 The application must implement cryptographic mechanisms to protect the integrity of remote access sessions." name="APSC_DV-000170" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001300 The application must protect audit information from unauthorized deletion." name="APSC_DV-001300" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001740 The application must only store cryptographic representations of passwords." name="APSC_DV-001740" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-000650 The application must not write sensitive data into the application logs." name="APSC_DV-000650" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001860 The application must use mechanisms meeting the requirements of applicable federal laws, Executive Orders, directives, policies, regulations, standards, and guidance for authentication to a cryptographic module." name="APSC_DV-001860" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002470 The application must maintain the confidentiality and integrity of information during reception." name="APSC_DV-002470" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002350 The application must use appropriate cryptography in order to protect stored DoD information when required by the information owner or DoD policy." name="APSC_DV-002350" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002570 The application must generate error messages that provide information necessary for corrective actions without revealing information that could be exploited by adversaries." name="APSC_DV-002570" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002010 The application must implement NSA-approved cryptography to protect classified information in accordance with applicable federal laws, Executive Orders, directives, policies, regulations, and standards." name="APSC_DV-002010" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002550 The application must not be vulnerable to XML-oriented attacks." name="APSC_DV-002550" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002530 The application must validate all input." name="APSC_DV-002530" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002510 The application must protect from command injection." name="APSC_DV-002510" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-002480 The application must not disclose unnecessary information to users." name="APSC_DV-002480" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="APSC_DV-001290 The application must protect audit information from unauthorized modification." name="APSC_DV-001290" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="AUTOSAR C++14 Coding Guidelines" name="AUTOSAR" total="567">
               <Category desc="AUTOSAR A16-6-1 #error directive shall not be used" name="AUTOSAR-A16_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-3-1 All overloads of a function shall be visible from where it is called" name="AUTOSAR-A7_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M8-5-2 Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" name="AUTOSAR-M8_5_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-5-1 A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" name="AUTOSAR-A6_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A25-4-1 Ordering predicates used with associative containers and STL sorting and related algorithms shall adhere to a strict weak ordering relation" name="AUTOSAR-A25_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-1-1 The assignment-expression of a throw statement shall not itself cause an exception to be thrown" name="AUTOSAR-M15_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-1-3 An empty throw (throw;) shall only be used in the compound statement of a catch handler" name="AUTOSAR-M15_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-1-2 NULL shall not be thrown explicitly" name="AUTOSAR-M15_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-7-1 If the behavior of a user-defined special member function is identical to implicitly defined special member function, then it shall be defined &quot;=default&quot; or be left undefined" name="AUTOSAR-A12_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-3-2 The unary minus operator shall not be applied to an expression whose underlying type is unsigned" name="AUTOSAR-M5_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-3-1 Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" name="AUTOSAR-M5_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-3-4 Evaluation of the operand to the sizeof operator shall not contain side effects" name="AUTOSAR-M5_3_4" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-3-3 The unary &amp; operator shall not be overloaded" name="AUTOSAR-M5_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-5-2 All user-defined conversion operators shall be defined explicit" name="AUTOSAR-A13_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-5-3 User-defined conversion operators should not be used" name="AUTOSAR-A13_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-6-1 The goto statement shall not be used" name="AUTOSAR-A6_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M27-0-1 The stream input/output library &lt;cstdio> shall not be used" name="AUTOSAR-M27_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-5-1 If &quot;operator[]&quot; is to be overloaded with a non-const version, const version shall also be implemented" name="AUTOSAR-A13_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-16-1 The ternary conditional operator shall not be used as a sub-expression" name="AUTOSAR-A5_16_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-5-4 If two opposite operators are defined, one shall be defined in terms of the other" name="AUTOSAR-A13_5_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-5-5 Comparison operators shall be non-member functions with identical parameter types and noexcept" name="AUTOSAR-A13_5_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A23-0-2 Elements of a container shall only be accessed via valid references, iterators, and pointers" name="AUTOSAR-A23_0_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-1-4 If a function exits with an exception, then before a throw, the function shall place all objects/resources that the function constructed in valid states or it shall delete them" name="AUTOSAR-A15_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A23-0-1 An iterator shall not be implicitly converted to const_iterator" name="AUTOSAR-A23_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M4-5-3 Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary &amp; operator" name="AUTOSAR-M4_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-1-5 Exceptions shall not be thrown across execution boundaries" name="AUTOSAR-A15_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-17-1 The semantic equivalence between a binary operator and its assignment operator form shall be preserved" name="AUTOSAR-M5_17_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-1-2 An exception object shall not be a pointer" name="AUTOSAR-A15_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M4-5-1 Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator" name="AUTOSAR-M4_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-10 Every defined function should be called at least once" name="AUTOSAR-M0_1_10" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-1-1 Only instances of types derived from std::exception shall be thrown" name="AUTOSAR-A15_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-4-1 Hierarchies should be based on interface classes" name="AUTOSAR-A10_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A16-7-1 The #pragma directive shall not be used" name="AUTOSAR-A16_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A11-0-1 A non-POD type should be defined as class" name="AUTOSAR-A11_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A11-0-2 A type defined as struct shall: (1) provide only public data members, (2) not provide any special member functions or methods, (3) not be a base of another struct or class, (4) not inherit from another struct or class" name="AUTOSAR-A11_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-2-3 Enumerations shall be declared as scoped enum classes" name="AUTOSAR-A7_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M8-4-4 A function identifier shall either be used to call the function or it shall be preceded by &amp;" name="AUTOSAR-M8_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-2-2 Enumeration underlying base type shall be explicitly defined" name="AUTOSAR-A7_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-2-1 An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" name="AUTOSAR-A7_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M8-4-2 The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration" name="AUTOSAR-M8_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-7-1 The character \ shall not occur as a last character of a C++ comment" name="AUTOSAR-A2_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-9-1 The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" name="AUTOSAR-M3_9_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-7-3 All declarations of &quot;user-defined&quot; types, static and non-static data members, functions and methods shall be preceded by documentation using &quot;///&quot; comments and &quot;@tag&quot; tags" name="AUTOSAR-A2_7_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-7-2 Sections of code shall not be &quot;commented out&quot;" name="AUTOSAR-A2_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M12-1-1 An object's dynamic type shall not be used from the body of its constructor or destructor" name="AUTOSAR-M12_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-9-3 The underlying bit representations of floating-point values shall not be used" name="AUTOSAR-M3_9_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A1-1-1 All code shall conform to ISO/IEC 14882:2014 - Programming Language C++ and shall not use deprecated features" name="AUTOSAR-A1_1_1" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-1-2 Functions shall not be declared at block scope" name="AUTOSAR-M3_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-4-1 A switch statement shall have at least two case-clauses, distinct from the default label" name="AUTOSAR-A6_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-6-1 All class data members that are initialized by the constructor shall be initialized using member initializers" name="AUTOSAR-A12_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-0-3 Control shall not be transferred into a try or catch block using a goto or a switch statement" name="AUTOSAR-M15_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-6 A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" name="AUTOSAR-M5_2_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-9 A cast shall not convert a pointer type to an integral type" name="AUTOSAR-M5_2_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M14-5-3 A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" name="AUTOSAR-M14_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M18-2-1 The macro offsetof shall not be used" name="AUTOSAR-M18_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-8 An object with integer type or pointer to void type shall not be converted to an object with pointer type" name="AUTOSAR-M5_2_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-6-1 The right hand operand of the integer division or remainder operators shall not be equal to zero" name="AUTOSAR-A5_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-3 Casts from a base class to a derived class should not be performed on polymorphic types" name="AUTOSAR-M5_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-2 A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" name="AUTOSAR-M5_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-5-3 Do statements should not be used" name="AUTOSAR-A6_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-5-2 A for loop shall contain a single loop-counter which shall not have floating-point type" name="AUTOSAR-A6_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-5 Hexadecimal constants should be upper case" name="AUTOSAR-A2_13_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-6 Universal character names shall be used only inside character or string literals" name="AUTOSAR-A2_13_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-5-4 For-init-statement and expression should not perform actions other than loop-counter initialization and modification" name="AUTOSAR-A6_5_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-3 Type wchar_t shall not be used" name="AUTOSAR-A2_13_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-4 String literals shall not be assigned to non-constant pointers" name="AUTOSAR-A2_13_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-1 Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" name="AUTOSAR-A2_13_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-13-2 String literals with different encoding prefixes shall not be concatenated" name="AUTOSAR-A2_13_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-15 Array indexing shall be the only form of pointer arithmetic" name="AUTOSAR-M5_0_15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-16 A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" name="AUTOSAR-M5_0_16" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-17 Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="AUTOSAR-M5_0_17" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-18 >, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" name="AUTOSAR-M5_0_18" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-0-2 At least the basic guarantee for exception safety shall be provided for all operations. In addition, each function may offer either the strong guarantee or the nothrow guarantee" name="AUTOSAR-A15_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M9-3-1 Const member functions shall not return non-const pointers or references to class-data" name="AUTOSAR-M9_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-10 If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" name="AUTOSAR-M5_0_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M9-3-3 If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" name="AUTOSAR-M9_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-11 The plain char type shall only be used for the storage and use of character values" name="AUTOSAR-M5_0_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-12 Signed char and unsigned char type shall only be used for the storage and use of numeric values" name="AUTOSAR-M5_0_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-14 The first operand of a conditional-operator shall have type bool" name="AUTOSAR-M5_0_14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-1-2 A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified" name="AUTOSAR-M7_1_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-4 The register keyword shall not be used" name="AUTOSAR-A7_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-3 CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" name="AUTOSAR-A7_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-2 The constexpr specifier shall be used for values that can be determined at compile time" name="AUTOSAR-A7_1_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-1 Constexpr or const specifiers shall be used for immutable data declaration" name="AUTOSAR-A7_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-8-1 A header file name shall be identical to a type name declared in it if it declares a type" name="AUTOSAR-A2_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-11-1 Volatile keyword shall not be used" name="AUTOSAR-A2_11_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A9-5-1 Unions shall not be used" name="AUTOSAR-A9_5_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-3-1 The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement" name="AUTOSAR-M6_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-20 Non-constant operands to a binary bitwise operator shall have the same underlying type" name="AUTOSAR-M5_0_20" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-21 Bitwise operators shall only be applied to operands of unsigned underlying type" name="AUTOSAR-M5_0_21" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-0-1 The C library facilities shall only be accessed through C++ library headers" name="AUTOSAR-A18_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-0-3 The library &lt;clocale> (locale.h) and the setlocale function shall not be used" name="AUTOSAR-A18_0_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-4-2 Use of floating-point arithmetic shall be documented" name="AUTOSAR-M0_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-0-2 The error state of a conversion from string to a numeric value shall be checked" name="AUTOSAR-A18_0_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-3-1 A function that contains &quot;forwarding reference&quot; as its argument shall not be overloaded" name="AUTOSAR-A13_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-5-1 A pointer to member shall not access non-existent class members" name="AUTOSAR-A5_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M14-6-1 In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" name="AUTOSAR-M14_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-4-2 Type long double shall not be used" name="AUTOSAR-A0_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-4-4 Range, domain and pole errors shall be checked when using math functions" name="AUTOSAR-A0_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A4-7-1 An integer expression shall not lead to data loss" name="AUTOSAR-A4_7_1" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-2-5 Enumerations should be used to represent sets of related named constants" name="AUTOSAR-A7_2_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-2-4 In an enumeration, either (1) none, (2) the first or (3) all enumerators shall be initialized" name="AUTOSAR-A7_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-6 std::make_shared shall be used to construct objects owned by std::shared_ptr" name="AUTOSAR-A20_8_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-5 std::make_unique shall be used to construct objects owned by std::unique_ptr" name="AUTOSAR-A20_8_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-7 A std::weak_ptr shall be used to represent temporary shared ownership" name="AUTOSAR-A20_8_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-2 A std::unique_ptr shall be used to represent exclusive ownership" name="AUTOSAR-A20_8_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-1 An already-owned pointer value shall not be stored in an unrelated smart pointer" name="AUTOSAR-A20_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-4 A std::unique_ptr shall be used over std::shared_ptr if ownership sharing is not required" name="AUTOSAR-A20_8_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A20-8-3 A std::shared_ptr shall be used to represent shared ownership" name="AUTOSAR-A20_8_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A9-6-1 Data types used for interfacing with hardware or conforming to communication protocols shall be trivial, standard-layout and only contain members of types with defined sizes" name="AUTOSAR-A9_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-2-3 Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character" name="AUTOSAR-M6_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-2-2 Floating-point expressions shall not be directly or indirectly tested for equality or inequality" name="AUTOSAR-M6_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-4-1 Destructor of a base class shall be public virtual, public override or protected non-virtual" name="AUTOSAR-A12_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-10-1 An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" name="AUTOSAR-A2_10_1" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-2-1 Assignment operators shall not be used in sub-expressions" name="AUTOSAR-M6_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-2-2 Expression statements shall not be explicit calls to constructors of temporary objects only" name="AUTOSAR-A6_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A6-2-1 Move and copy assignment operators shall either move or respectively copy base classes and data members of a class, without any side effects" name="AUTOSAR-A6_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A9-6-2 Bit-fields shall be used only when interfacing to hardware or conforming to communication protocols" name="AUTOSAR-A9_6_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-4-2 If a public destructor of a class is non-virtual, then the class should be declared final" name="AUTOSAR-A12_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-11 &quot;operator new&quot; and &quot;operator delete&quot; shall be defined together" name="AUTOSAR-A18_5_11" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-11 A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" name="AUTOSAR-A8_4_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-10 Placement new shall be used only with properly aligned pointers to sufficient storage capacity" name="AUTOSAR-A18_5_10" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-10 A parameter shall be passed by reference if it can't be NULL" name="AUTOSAR-A8_4_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-13 A std::shared_ptr shall be passed to a function as: (1) a copy to express the function shares ownership (2) an lvalue reference to express that the function replaces the managed object (3) a const lvalue reference to express that the function retains a reference count" name="AUTOSAR-A8_4_13" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-12 A std::unique_ptr shall be passed to a function as: (1) a copy to express the function assumes ownership (2) an lvalue reference to express that the function replaces the managed object" name="AUTOSAR-A8_4_12" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-1-2 The std::vector&lt;bool> specialization shall not be used" name="AUTOSAR-A18_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-1-1 C-style arrays shall not be used" name="AUTOSAR-A18_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-2-1 An assignment operator shall return a reference to &quot;this&quot;" name="AUTOSAR-A13_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-1-4 A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" name="AUTOSAR-A18_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M18-0-3 The library functions abort, exit, getenv and system from library &lt;cstdlib> shall not be used" name="AUTOSAR-M18_0_3" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-2-2 A binary arithmetic operator and a bitwise operator shall return a &quot;prvalue&quot;" name="AUTOSAR-A13_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-1-3 The std::auto_ptr type shall not be used" name="AUTOSAR-A18_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-1-6 All std::hash specializations for user-defined types shall have a noexcept function call operator" name="AUTOSAR-A18_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-2-3 A relational operator shall return a boolean value" name="AUTOSAR-A13_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M18-0-5 The unbounded functions of library &lt;cstring> shall not be used" name="AUTOSAR-M18_0_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M18-0-4 The time handling functions of library &lt;ctime> shall not be used" name="AUTOSAR-M18_0_4" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M2-10-1 Different identifiers shall be typographically unambiguous" name="AUTOSAR-M2_10_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-14-1 The right hand operand of a logical &amp;&amp;, || operators shall not contain side effects" name="AUTOSAR-M5_14_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-9 A class, structure, or enumeration shall not be declared in the definition of its type" name="AUTOSAR-A7_1_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-8 A non-type specifier shall be placed before a type specifier in a declaration" name="AUTOSAR-A7_1_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-7 Each expression statement and identifier declaration shall be placed on a separate line" name="AUTOSAR-A7_1_7" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-6 The typedef specifier shall not be used" name="AUTOSAR-A7_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-1-5 The auto specifier shall not be used apart from following cases: (1) to declare that a variable has the same type as return type of a function call, (2) to declare that a variable has the same type as initializer of non-fundamental type, (3) to declare parameters of a generic lambda expression, (4) to declare a function template using trailing return type syntax" name="AUTOSAR-A7_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-9-2 Forwarding values to other functions shall be done via: (1) std::move if the value is an rvalue reference, (2) std::forward if the value is forwarding reference" name="AUTOSAR-A18_9_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-9-1 The std::bind shall not be used" name="AUTOSAR-A18_9_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-9-4 An argument to std::forward shall not be subsequently used" name="AUTOSAR-A18_9_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-9-3 The std::move shall not be used on objects declared const or const&amp;" name="AUTOSAR-A18_9_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A14-8-2 Explicit specializations of function templates shall not be used" name="AUTOSAR-A14_8_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-8-1 An object shall not be accessed outside of its lifetime" name="AUTOSAR-A3_8_1" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-3-2 The # and ## operators should not be used" name="AUTOSAR-M16_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-5-4 If a class has a user-declared constructor that takes a parameter of type std::initializer_list, then it shall be the only constructor apart from special member function constructors" name="AUTOSAR-A8_5_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-3-1 There shall be at most one occurrence of the # or ## operators in a single macro definition" name="AUTOSAR-M16_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-3-2 The identifier main shall not be used for a function other than the global function main" name="AUTOSAR-M7_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-3-1 The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" name="AUTOSAR-M7_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A16-2-1 The ', &quot;, /*, //, \ characters shall not occur in a header file name or in #include directive" name="AUTOSAR-A16_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-5-1 In an initialization list, the order of initialization shall be following: (1) virtual base classes in depth and left to right order of the inheritance graph, (2) direct base classes in left to right order of inheritance list, (3) non-static data members in the order they were declared in the class definition" name="AUTOSAR-A8_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-3-4 Using-directives shall not be used" name="AUTOSAR-M7_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-5-0 All memory shall be initialized before it is read" name="AUTOSAR-A8_5_0" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-3-3 There shall be no unnamed namespaces in header files" name="AUTOSAR-M7_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-5-3 A variable of type auto shall not be initialized using {} or ={} braced-initialization" name="AUTOSAR-A8_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-3-6 Using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" name="AUTOSAR-M7_3_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A16-2-2 There shall be no unused include directives" name="AUTOSAR-A16_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-5-2 Braced-initialization {}, without equals sign, shall be used for variable initialization" name="AUTOSAR-A8_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A17-0-1 Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined" name="AUTOSAR-A17_0_1" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A9-3-1 Member functions shall not return non-const &quot;raw&quot; pointers or references to private or protected data owned by the class" name="AUTOSAR-A9_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-5-5 A loop-control-variable other than the loop-counter shall not be modified within condition or expression" name="AUTOSAR-M6_5_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-5-4 The loop-counter shall be modified by one of: --, ++, -= n, or += n; where n remains constant for the duration of the loop" name="AUTOSAR-M6_5_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-4-1 An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" name="AUTOSAR-M3_4_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-5-3 The loop-counter shall not be modified within condition or statement" name="AUTOSAR-M6_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-5-2 If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" name="AUTOSAR-M6_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-5-6 A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" name="AUTOSAR-M6_5_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-1-2 User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" name="AUTOSAR-A13_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-2-1 An object shall not be assigned to an overlapping object" name="AUTOSAR-M0_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M4-10-1 NULL shall not be used as an integer value" name="AUTOSAR-M4_10_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-1-3 User defined literals operators shall only perform conversion of passed parameters" name="AUTOSAR-A13_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-3-3 Pointers to incomplete class types shall not be deleted" name="AUTOSAR-A5_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-3-2 Null pointers shall not be dereferenced" name="AUTOSAR-A5_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-3-1 Evaluation of the operand to the typeid operator shall not contain side effects" name="AUTOSAR-A5_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M18-7-1 The signal handling facilities of &lt;csignal> shall not be used" name="AUTOSAR-M18_7_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A26-5-1 Pseudorandom numbers shall not be generated using std::rand()" name="AUTOSAR-A26_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M4-10-2 Literal zero (0) shall not be used as the null-pointer-constant" name="AUTOSAR-M4_10_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-10-6 A class or enumeration name shall not be hidden by a variable, function or enumerator declaration in the same scope" name="AUTOSAR-A2_10_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A26-5-2 Random number engines shall not be default-initialized" name="AUTOSAR-A26_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-10-4 The identifier name of a non-member object with static storage duration or static function shall not be reused within a namespace" name="AUTOSAR-A2_10_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-10-5 An identifier name of a function with static storage duration or a non-member object with external or internal linkage should not be reused" name="AUTOSAR-A2_10_5" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A4-5-1 Expressions with type enum or enum class shall not be used as operands to built-in and overloaded operators other than the subscript operator [ ], the assignment operator =, the equality operators == and !=, the unary &amp; operator, and the relational operators &lt;, &lt;=, >, >=" name="AUTOSAR-A4_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-5-3 The std::terminate() function shall not be called implicitly" name="AUTOSAR-A15_5_3" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-5-2 Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std::abort(), std::quick_exit(), std::_Exit(), std::terminate() shall not be done" name="AUTOSAR-A15_5_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-5-1 All user-provided class destructors, deallocation functions, move constructors, move assignment operators and swap functions shall not exit with an exception. A noexcept exception specification shall be added to these functions as appropriate" name="AUTOSAR-A15_5_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M9-6-4 Named bit-fields with signed integer type shall have a length of more than one bit" name="AUTOSAR-M9_6_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-10 The increment (++) and decrement (--) operators shall not be mixed with other operators in an expression" name="AUTOSAR-M5_2_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-12 An identifier with array type passed as a function argument shall not decay to a pointer" name="AUTOSAR-M5_2_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-2-11 The comma operator, &amp;&amp; operator and the || operator shall not be overloaded" name="AUTOSAR-M5_2_11" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A14-7-2 Template specialization shall be declared in the same file (1) as the primary template (2) as a user-defined type, for which the specialization is declared" name="AUTOSAR-A14_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-9-1 Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" name="AUTOSAR-A3_9_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-2-3 Include guards shall be provided" name="AUTOSAR-M16_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-6 Trivial accessor and mutator functions should be inlined" name="AUTOSAR-A3_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-5 A function definition shall only be placed in a class definition if (1) the function is intended to be inlined (2) it is a member function template (3) it is a member function of a class template" name="AUTOSAR-A3_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-4 When an array with external linkage is declared, its size shall be stated explicitly" name="AUTOSAR-A3_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-3 Implementation files, that are defined locally in the project, should have a file name extension of &quot;.cpp&quot;" name="AUTOSAR-A3_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-2 Header files, that are defined locally in the project, shall have a file name extension of one of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" name="AUTOSAR-A3_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-1-1 It shall be possible to include any header file in multiple translation units without violating the One Definition Rule" name="AUTOSAR-A3_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-3-1 Only those characters specified in the C++ Language Standard basic source character set shall be used in the source code" name="AUTOSAR-A2_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M10-1-2 A base class shall only be declared virtual if it is used in a diamond hierarchy" name="AUTOSAR-M10_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M10-1-1 Classes should not be derived from virtual bases" name="AUTOSAR-M10_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M8-0-1 An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively" name="AUTOSAR-M8_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-2 All if ... else if constructs shall be terminated with an else clause" name="AUTOSAR-M6_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-1 An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement" name="AUTOSAR-M6_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A17-1-1 Use of the C Standard Library shall be encapsulated and isolated" name="AUTOSAR-A17_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A21-8-1 Arguments to character-handling functions shall be representable as an unsigned char" name="AUTOSAR-A21_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M10-1-3 An accessible base class shall not be both virtual and non-virtual in the same hierarchy" name="AUTOSAR-M10_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-6 The final clause of a switch statement shall be the default-clause" name="AUTOSAR-M6_4_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A25-1-1 Non-static data members or captured values of predicate function objects that are state related to this object's identity shall not be copied" name="AUTOSAR-A25_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-5 An unconditional throw or break statement shall terminate every non-empty switch-clause" name="AUTOSAR-M6_4_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-4 A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" name="AUTOSAR-M6_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-3 A switch statement shall be a well-formed switch statement" name="AUTOSAR-M6_4_3" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M2-7-1 The character sequence /* shall not be used within a C-style comment" name="AUTOSAR-M2_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-4-7 The condition of a switch statement shall not have bool type" name="AUTOSAR-M6_4_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-1 dynamic_cast should not be used" name="AUTOSAR-A5_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-3-2 If a function generates error information, then that error information shall be tested" name="AUTOSAR-M0_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-5 An array or container shall not be accessed beyond its range" name="AUTOSAR-A5_2_5" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-3-1 Minimization of run-time failures shall be ensured by the use of at least one of: (a) static analysis tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle run-time faults" name="AUTOSAR-M0_3_1" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-4 reinterpret_cast shall not be used" name="AUTOSAR-A5_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-3 A cast shall not remove any const or volatile qualification from the type of a pointer or reference" name="AUTOSAR-A5_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-2 Traditional C-style casts shall not be used" name="AUTOSAR-A5_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-4-5 Checked exceptions that could be thrown from a function shall be specified together with the function declaration and they shall be identical in all function declarations and for all its overriders" name="AUTOSAR-A15_4_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M17-0-2 The names of standard library macros and objects shall not be reused" name="AUTOSAR-M17_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-4-3 The noexcept specification of a function shall either be identical across all translation units, or identical or more restrictive between a virtual member function and an overrider" name="AUTOSAR-A15_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-4-4 A declaration of non-throwing function shall contain noexcept specification" name="AUTOSAR-A15_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M17-0-3 The names of standard library functions shall not be overridden" name="AUTOSAR-M17_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-4-1 Dynamic exception-specification shall not be used" name="AUTOSAR-A15_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-4-2 If a function is declared to be noexcept, noexcept(true) or noexcept(&lt;true condition>), then it shall not exit with an exception" name="AUTOSAR-A15_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-1-1 Class shall not be derived from more than one base class which is not an interface class" name="AUTOSAR-A10_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M17-0-5 The setjmp macro and the longjmp function shall not be used" name="AUTOSAR-M17_0_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-1-2 All #else, #elif and #endif pre-processor directives shall reside in the same file as the #if or #ifdef directive to which they are related" name="AUTOSAR-M16_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A11-3-1 Friend declarations shall not be used" name="AUTOSAR-A11_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-1-1 The defined pre-processor operator shall only be used in one of the two standard forms" name="AUTOSAR-M16_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-5-2 The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" name="AUTOSAR-M7_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-5-1 A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function" name="AUTOSAR-M7_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-2-4 An identifier with external linkage shall have exactly one definition" name="AUTOSAR-M3_2_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A16-0-1 The pre-processor shall only be used for unconditional and conditional file inclusion and include guards, and using the following directives: (1) #ifndef, (2) #ifdef, (3) #if, (4) #if defined, (5) #elif, (6) #else, (7) #define, (8) #endif, (9) #include" name="AUTOSAR-A16_0_1" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M10-2-1 All accessible entity names within a multiple inheritance hierarchy should be unique" name="AUTOSAR-M10_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M8-3-1 Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments" name="AUTOSAR-M8_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-1 Constructors shall explicitly initialize all virtual base classes, all direct non-virtual base classes and all non-static data members" name="AUTOSAR-A12_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-2 Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type" name="AUTOSAR-A12_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-3-4 Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" name="AUTOSAR-M15_3_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-3 If all user-defined constructors of a class initialize data members with constant values that are the same across all constructors, then data members shall be initialized using NSDMI instead" name="AUTOSAR-A12_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-3-7 Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last" name="AUTOSAR-M15_3_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-4 All constructors that are callable with a single argument of fundamental type shall be declared explicit" name="AUTOSAR-A12_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-3-6 Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" name="AUTOSAR-M15_3_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-2-1 All declarations of an object or function shall have compatible types" name="AUTOSAR-M3_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A17-6-1 Non-standard entities shall not be added to standard namespaces" name="AUTOSAR-A17_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-2-3 A type, object or function that is used in multiple translation units shall be declared in one and only one file" name="AUTOSAR-M3_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-10-1 A pointer to member virtual function shall only be tested for equality with null-pointer-constant" name="AUTOSAR-A5_10_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-2-2 The One Definition Rule shall not be violated" name="AUTOSAR-M3_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-2-6 The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" name="AUTOSAR-A5_2_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-5 Common class initialization for non-constant members shall be done by a delegating constructor" name="AUTOSAR-A12_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-3-1 Exceptions shall be raised only after start-up and before termination" name="AUTOSAR-M15_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-1-6 Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors" name="AUTOSAR-A12_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M15-3-3 Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases" name="AUTOSAR-M15_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M11-0-1 Member data in non-POD class types shall be private" name="AUTOSAR-M11_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-2 Variables shall not be implicitly captured in a lambda expression" name="AUTOSAR-A5_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-1 Literal values shall not be used apart from type initialization, otherwise symbolic names shall be used instead" name="AUTOSAR-A5_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A4-10-1 Only nullptr literal shall be used as the null-pointer-constant" name="AUTOSAR-A4_10_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-6 Return type of a non-void return type lambda expression should be explicitly specified" name="AUTOSAR-A5_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-4 A lambda expression object shall not outlive any of its reference-captured objects" name="AUTOSAR-A5_1_4" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-3 Parameter list (possibly empty) shall be included in every lambda expression" name="AUTOSAR-A5_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-3-4 Catch-all (ellipsis and std::exception) handlers shall be used only in (a) main, (b) task main functions, (c) in functions that are supposed to isolate independent components and (d) when calling third-party code that uses exceptions not according to AUTOSAR C++14 guidelines" name="AUTOSAR-A15_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-3-5 A class type exception shall be caught by reference or const reference" name="AUTOSAR-A15_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-3-2 If a function throws an exception, it shall be handled when meaningful actions can be taken, otherwise it shall be propagated" name="AUTOSAR-A15_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M2-13-2 Octal constants (other than zero) and octal escape sequences (other than &quot;\0&quot; ) shall not be used" name="AUTOSAR-M2_13_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-3-3 Main function and a task main function shall catch at least: base class exceptions from all third-party libraries used, std::exception and all otherwise unhandled exceptions" name="AUTOSAR-A15_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-6-1 Functions declared with the [[noreturn]] attribute shall not return" name="AUTOSAR-A7_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M2-13-4 Literal suffixes shall be upper case" name="AUTOSAR-M2_13_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M2-13-3 A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" name="AUTOSAR-M2_13_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-19-1 Evaluation of constant unsigned integer expressions shall not lead to wrap-around" name="AUTOSAR-M5_19_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A14-5-1 A template constructor shall not participate in overload resolution for a single argument of the enclosing class type" name="AUTOSAR-A14_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-2-1 Non-virtual member functions shall not be redefined in derived classes" name="AUTOSAR-A10_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-2-1 When declaring function templates, the trailing return type syntax shall be used if the return type depends on the type of parameters" name="AUTOSAR-A8_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A14-5-3 A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations." name="AUTOSAR-A14_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-6 &quot;forward&quot; parameters declared as T &amp;&amp; shall always be forwarded" name="AUTOSAR-A8_4_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-5 Arguments to a function-like macro shall not contain tokens that look like pre-processing directives" name="AUTOSAR-M16_0_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-5 &quot;consume&quot; parameters declared as X &amp;&amp; shall always be moved from" name="AUTOSAR-A8_4_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-8 Output parameters shall not be used" name="AUTOSAR-A8_4_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-4-1 All usage of assembler shall be documented" name="AUTOSAR-M7_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-7 &quot;in&quot; parameters for &quot;cheap to copy&quot; types shall be passed by value" name="AUTOSAR-A8_4_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-2 Macros shall only be #define'd or #undef'd in the global namespace" name="AUTOSAR-M16_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-6 Copy and move constructors and copy assignment and move assignment operators shall be declared protected or defined &quot;=delete&quot; in base class" name="AUTOSAR-A12_8_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-3-2 Static and thread-local objects shall be constant-initialized" name="AUTOSAR-A3_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-2 All exit paths from a function with non-void return type shall have an explicit return statement with an expression" name="AUTOSAR-A8_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-1 #include directives in a file shall only be preceded by other pre-processor directives or comments" name="AUTOSAR-M16_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-4-3 Assembly language shall be encapsulated and isolated" name="AUTOSAR-M7_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-7 Assignment operators should be declared with the ref-qualifier &amp;" name="AUTOSAR-A12_8_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A3-3-1 Objects or functions with external linkage (including members of named namespaces) shall be declared in a header file" name="AUTOSAR-A3_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-1 Functions shall not be defined using the ellipsis notation" name="AUTOSAR-A8_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M7-4-2 Assembler instructions shall only be introduced using the asm declaration" name="AUTOSAR-M7_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-4 Multiple output values from a function should be returned as a struct or tuple" name="AUTOSAR-A8_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-3 Common ways of passing parameters should be used" name="AUTOSAR-A8_4_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-4-1 The asm declaration shall not be used" name="AUTOSAR-A7_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-5-1 Trigraphs shall not be used" name="AUTOSAR-A2_5_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A2-5-2 Digraphs shall not be used" name="AUTOSAR-A2_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A8-4-9 &quot;in-out&quot; parameters declared as T &amp; shall be modified" name="AUTOSAR-A8_4_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-8 If the # token appears as the first token on a line, then it shall be immediately followed by a pre-processing token" name="AUTOSAR-M16_0_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-7 Undefined macro identifiers shall not be used in #if or #elif pre-processor directives, except as operands to the defined operator" name="AUTOSAR-M16_0_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M16-0-6 In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##" name="AUTOSAR-M16_0_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-0-2 Bitwise operations and operations that assume data representation in memory shall not be performed on objects" name="AUTOSAR-A12_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M10-3-3 A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" name="AUTOSAR-M10_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-6-3 The continue statement shall only be used within a well-formed for loop" name="AUTOSAR-M6_6_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M3-3-2 If a function has internal linkage then all re-declarations shall include the static storage class specifier" name="AUTOSAR-M3_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-6-2 The goto statement shall jump to a label declared later in the same function body" name="AUTOSAR-M6_6_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-0-1 If a class declares a copy or move operation, or a destructor, either via &quot;=default&quot;, &quot;=delete&quot;, or via a user-provided declaration, then all others of these five special member functions shall be declared as well" name="AUTOSAR-A12_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M6-6-1 Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" name="AUTOSAR-M6_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-2 User-defined copy and move assignment operators should use user-defined no-throw swap function" name="AUTOSAR-A12_8_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-3 Moved-from object shall not be read-accessed" name="AUTOSAR-A12_8_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-4 Move constructor shall not initialize its class members and base classes using copy semantics" name="AUTOSAR-A12_8_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-8 Lambda expressions should not be defined inside another lambda expression" name="AUTOSAR-A5_1_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-5 A copy assignment and a move assignment operators shall handle self-assignment" name="AUTOSAR-A12_8_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-1-7 A lambda shall not be an operand to decltype or typeid" name="AUTOSAR-A5_1_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M19-3-1 The error indicator errno shall not be used" name="AUTOSAR-M19_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A12-8-1 Move and copy constructors shall move and respectively copy base classes and data members of a class, without any side effects" name="AUTOSAR-A12_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-0-3 The declaration of objects shall contain no more than two levels of pointer indirection" name="AUTOSAR-A5_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-9 An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression" name="AUTOSAR-M5_0_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-8-1 The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand" name="AUTOSAR-M5_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-1 A project shall not contain instances of non-volatile variables being given values that are not subsequently used" name="AUTOSAR-A0_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-0-2 The condition of an if-statement and the condition of an iteration statement shall have type bool" name="AUTOSAR-A5_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-8 An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" name="AUTOSAR-M5_0_8" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-2 The value returned by a function having a non-void return type that is not an overloaded operator shall be used" name="AUTOSAR-A0_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-0-1 The value of an expression shall be the same under any order of evaluation that the standard permits" name="AUTOSAR-A5_0_1" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-4 A project shall not contain non-volatile POD variables having only one use" name="AUTOSAR-M0_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-3 Every function defined in an anonymous namespace, or static function with internal linkage, or private member function shall be used" name="AUTOSAR-A0_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-2 A project shall not contain infeasible paths" name="AUTOSAR-M0_1_2" total="29">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-5 There shall be no implicit floating-integral conversions" name="AUTOSAR-M5_0_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A27-0-4 C-style strings shall not be used" name="AUTOSAR-A27_0_4" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-3 A project shall not contain unused variables" name="AUTOSAR-M0_1_3" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-4 An implicit integral conversion shall not change the signedness of the underlying type" name="AUTOSAR-M5_0_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-2 Non-placement new or delete expressions shall not be used" name="AUTOSAR-A18_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A27-0-3 Alternate input and output operations on a file stream shall not be used without an intervening flush or positioning call" name="AUTOSAR-A27_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-7 There shall be no explicit floating-integral conversions of a cvalue expression" name="AUTOSAR-M5_0_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-1 Functions malloc, calloc, realloc and free shall not be used" name="AUTOSAR-A18_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A27-0-2 A C-style string shall guarantee sufficient space for data and the null terminator" name="AUTOSAR-A27_0_2" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A5-0-4 Pointer arithmetic shall not be used with pointers to non-final classes" name="AUTOSAR-A5_0_4" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-1 A project shall not contain unreachable code" name="AUTOSAR-M0_1_1" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-6 An implicit integral or floating-point conversion shall not reduce the size of the underlying type" name="AUTOSAR-M5_0_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A13-6-1 Digit sequences separators ' shall only be used as follows: (1) for decimal, every 3 digits, (2) for hexadecimal, every 2 digits, (3) for binary, every 4 digits" name="AUTOSAR-A13_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A27-0-1 Inputs from independent components shall be validated" name="AUTOSAR-A27_0_1" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-4 There shall be no unused named parameters in non-virtual functions" name="AUTOSAR-A0_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-5 There shall be no unused named parameters in the set of parameters for a virtual function and all the functions that override it" name="AUTOSAR-A0_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A0-1-6 There should be no unused type declarations" name="AUTOSAR-A0_1_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-3-5 A user-defined assignment operator shall not be virtual" name="AUTOSAR-A10_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A15-2-1 Constructors that are not noexcept shall not be invoked before program startup" name="AUTOSAR-A15_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-5-2 Functions shall not call themselves, either directly or indirectly" name="AUTOSAR-A7_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-18-1 The comma operator shall not be used" name="AUTOSAR-M5_18_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A7-5-1 A function shall not return a reference or a pointer to a parameter that is passed by reference to const" name="AUTOSAR-A7_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-4 If a project has sized or unsized version of operator &quot;delete&quot; globally defined, then both sized and unsized versions shall be defined" name="AUTOSAR-A18_5_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-3 The form of the delete expression shall match the form of the new expression used to allocate the memory" name="AUTOSAR-A18_5_3" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-3 A cvalue expression shall not be implicitly converted to a different underlying type" name="AUTOSAR-M5_0_3" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-5 Memory management functions shall ensure the following: (a) deterministic behavior resulting with the existence of worst-case execution time, (b) avoiding memory fragmentation, (c) avoid running out of memory, (d) avoiding mismatched allocations or deallocations, (e) no dependence on non-deterministic calls to kernel" name="AUTOSAR-A18_5_5" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M5-0-2 Limited dependence should be placed on C++ operator precedence rules in expressions" name="AUTOSAR-M5_0_2" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-3-1 Virtual function declaration shall contain exactly one of the three specifiers:" name="AUTOSAR-A10_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-8 Objects that do not outlive a function shall have automatic storage duration" name="AUTOSAR-A18_5_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-3-2 Each overriding virtual function shall be declared with the override or final specifier" name="AUTOSAR-A10_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A10-3-3 Virtual functions shall not be introduced in a final class" name="AUTOSAR-A10_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-8 All functions with void return type shall have external side effect(s)" name="AUTOSAR-M0_1_8" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR A18-5-9 Custom implementations of dynamic memory allocation and deallocation functions shall meet the semantic requirements specified in the corresponding &quot;Required behaviour&quot; clause from the C++ Standard" name="AUTOSAR-A18_5_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="AUTOSAR M0-1-9 There shall be no dead code" name="AUTOSAR-M0_1_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Flow Analysis" name="BD" total="138">
               <Category desc="Incorrect API usage" name="BD-API" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Miscellaneous" name="BD-MISC" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Possible Bugs" name="BD-PB" total="76">
                  <Stats authTot="13;" total="13"/>
               </Category>
               <Category desc="Resources" name="BD-RES" total="8">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="Security" name="BD-SECURITY" total="19">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="Containers" name="BD-CO" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Threads &amp; Synchronization" name="BD-TRS" total="21">
                  <Stats authTot="12;" total="12"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Code Duplication Detection" name="CDD" total="4">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="SEI CERT C" name="CERT_C" total="367">
               <Category desc="CERT-MSC12_C (REC) Detect and remove code that has no effect or is never executed" name="CERT_C-MSC12" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC11_C (REC) Incorporate diagnostic tests using assertions" name="CERT_C-MSC11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC14_C (REC) Do not introduce unnecessary platform dependencies" name="CERT_C-MSC14" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC13_C (REC) Detect and remove unused values" name="CERT_C-MSC13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC15_C (REC) Do not depend on undefined behavior" name="CERT_C-MSC15" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-WIN00_C (REC) Be specific when dynamically loading libraries" name="CERT_C-WIN00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP03_C (REC) Detect and handle floating-point errors" name="CERT_C-FLP03" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC17_C (REC) Finish every set of statements associated with a case label with a break statement" name="CERT_C-MSC17" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP02_C (REC) Avoid using floating-point numbers when precise computation is needed" name="CERT_C-FLP02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC19_C (REC) For functions that return an array, prefer returning an empty array over a null value" name="CERT_C-MSC19" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP06_C (REC) Convert integers to floating point for floating-point operations" name="CERT_C-FLP06" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT02_C (REC) Understand integer conversion rules" name="CERT_C-INT02" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP00_C (REC) Understand the limitations of floating-point numbers" name="CERT_C-FLP00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-API01_C (REC) Avoid laying out strings in memory directly before sensitive data" name="CERT_C-API01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-API02_C (REC) Functions that read or write to or from an array should take an argument to specify the source or target size" name="CERT_C-API02" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT08_C (REC) Verify that all integer values are in range" name="CERT_C-INT08" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT09_C (REC) Ensure enumeration constants map to unique values" name="CERT_C-INT09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT07_C (REC) Use only explicitly signed or unsigned char type for numeric values" name="CERT_C-INT07" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT04_C (REC) Enforce limits on integer values originating from tainted sources" name="CERT_C-INT04" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT05_C (REC) Do not use input functions to convert character data if they cannot handle all possible inputs" name="CERT_C-INT05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV30_C (RULE) Do not modify the object referenced by the return value of certain functions" name="CERT_C-ENV30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC22_C (REC) Use the setjmp(), longjmp() facility securely" name="CERT_C-MSC22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC24_C (REC) Do not use deprecated or obsolescent functions" name="CERT_C-MSC24" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT13_C (REC) Use bitwise operators only on unsigned operands" name="CERT_C-INT13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT12_C (REC) Do not make assumptions about the type of a plain int bit-field when used in an expression" name="CERT_C-INT12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT10_C (REC) Do not assume a positive remainder when using the % operator" name="CERT_C-INT10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV33_C (RULE) Do not call system()" name="CERT_C-ENV33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV34_C (RULE) Do not store pointers returned by certain functions" name="CERT_C-ENV34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT18_C (REC) Evaluate integer expressions in a larger size before comparing or assigning to that size" name="CERT_C-INT18" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV31_C (RULE) Do not rely on an environment pointer following an operation that may invalidate it" name="CERT_C-ENV31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT15_C (REC) Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" name="CERT_C-INT15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC30_C (RULE) Do not use the rand() function for generating pseudorandom numbers" name="CERT_C-MSC30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV32_C (RULE) All exit handlers must return normally" name="CERT_C-ENV32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT16_C (REC) Do not make assumptions about representation of signed integers" name="CERT_C-INT16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM00_C (REC) Allocate and free memory in the same module, at the same level of abstraction" name="CERT_C-MEM00" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM01_C (REC) Store a new value in pointers immediately after free()" name="CERT_C-MEM01" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG30_C (RULE) Call only asynchronous-safe functions within signal handlers" name="CERT_C-SIG30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM04_C (REC) Beware of zero-length allocations" name="CERT_C-MEM04" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM05_C (REC) Avoid large stack allocations" name="CERT_C-MEM05" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG31_C (RULE) Do not access shared objects in signal handlers" name="CERT_C-SIG31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM02_C (REC) Immediately cast the result of a memory allocation function call into a pointer to the allocated type" name="CERT_C-MEM02" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG34_C (RULE) Do not call signal() from within interruptible signal handlers" name="CERT_C-SIG34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM03_C (REC) Clear sensitive information stored in reusable resources" name="CERT_C-MEM03" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG35_C (RULE) Do not return from a computational exception signal handler" name="CERT_C-SIG35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE31_C (RULE) Avoid side effects in arguments to unsafe macros" name="CERT_C-PRE31" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE32_C (RULE) Do not use preprocessor directives in invocations of function-like macros" name="CERT_C-PRE32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE30_C (RULE) Do not create a universal character name through concatenation" name="CERT_C-PRE30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV02_C (REC) Beware of multiple environment variables with the same effective name" name="CERT_C-ENV02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV01_C (REC) Do not make assumptions about the size of an environment variable" name="CERT_C-ENV01" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC01_C (REC) Strive for logical completeness" name="CERT_C-MSC01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC04_C (REC) Use comments consistently and in a readable fashion" name="CERT_C-MSC04" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC07_C (REC) Detect and remove dead code" name="CERT_C-MSC07" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC06_C (REC) Beware of compiler optimizations" name="CERT_C-MSC06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC09_C (REC) Character encoding: Use subset of ASCII for safety" name="CERT_C-MSC09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT35_C (RULE) Use correct integer precisions" name="CERT_C-INT35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT36_C (RULE) Converting a pointer to integer or integer to pointer" name="CERT_C-INT36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT33_C (RULE) Ensure that division and remainder operations do not result in divide-by-zero errors" name="CERT_C-INT33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT34_C (RULE) Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand" name="CERT_C-INT34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT31_C (RULE) Ensure that integer conversions do not result in lost or misinterpreted data" name="CERT_C-INT31" total="16">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT32_C (RULE) Ensure that operations on signed integers do not result in overflow" name="CERT_C-INT32" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT30_C (RULE) Ensure that unsigned integer operations do not wrap" name="CERT_C-INT30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO34_C (RULE) Distinguish between characters read from a file and EOF or WEOF" name="CERT_C-FIO34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO32_C (RULE) Do not perform operations on devices that are only appropriate for files" name="CERT_C-FIO32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO38_C (RULE) Do not copy a FILE object" name="CERT_C-FIO38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO39_C (RULE) Do not alternately input and output from a stream without an intervening flush or positioning call" name="CERT_C-FIO39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO37_C (RULE) Do not assume that fgets() or fgetws() returns a nonempty string when successful" name="CERT_C-FIO37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP44_C (RULE) Do not rely on side effects in operands to sizeof, _Alignof, or _Generic" name="CERT_C-EXP44" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP45_C (RULE) Do not perform assignments in selection statements" name="CERT_C-EXP45" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP42_C (RULE) Do not compare padding data" name="CERT_C-EXP42" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP43_C (RULE) Avoid undefined behavior when using restrict-qualified pointers" name="CERT_C-EXP43" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO30_C (RULE) Exclude user input from format strings" name="CERT_C-FIO30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP46_C (RULE) Do not use a bitwise operator with a Boolean-like operand" name="CERT_C-EXP46" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP47_C (RULE) Do not call va_arg with an argument of the incorrect type" name="CERT_C-EXP47" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM12_C (REC) Consider using a goto chain when leaving a function on error when using and releasing resources" name="CERT_C-MEM12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR34_C (RULE) Cast characters to unsigned char before converting to larger integer sizes" name="CERT_C-STR34" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR31_C (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator" name="CERT_C-STR31" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR32_C (RULE) Do not pass a non-null-terminated character sequence to a library function that expects a string" name="CERT_C-STR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR30_C (RULE) Do not attempt to modify string literals" name="CERT_C-STR30" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO45_C (RULE) Avoid TOCTOU race conditions while accessing files" name="CERT_C-FIO45" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO46_C (RULE) Do not access a closed file" name="CERT_C-FIO46" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO44_C (RULE) Only use values for fsetpos() that are returned from fgetpos()" name="CERT_C-FIO44" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR37_C (RULE) Arguments to character-handling functions must be representable as an unsigned char" name="CERT_C-STR37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR38_C (RULE) Do not confuse narrow and wide character strings and functions" name="CERT_C-STR38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO47_C (RULE) Use valid format strings" name="CERT_C-FIO47" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO41_C (RULE) Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects" name="CERT_C-FIO41" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO42_C (RULE) Close files when they are no longer needed" name="CERT_C-FIO42" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO40_C (RULE) Reset strings on fgets() or fgetws() failure" name="CERT_C-FIO40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM07_C (REC) Ensure that the arguments to calloc(), when multiplied, do not wrap" name="CERT_C-MEM07" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC32_C (RULE) Properly seed pseudorandom number generators" name="CERT_C-MSC32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC33_C (RULE) Do not pass invalid data to the asctime() function" name="CERT_C-MSC33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC38_C (RULE) Do not treat a predefined identifier as an object if it might only be implemented as a macro" name="CERT_C-MSC38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC37_C (RULE) Ensure that control never reaches the end of a non-void function" name="CERT_C-MSC37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC39_C (RULE) Do not call va_arg() on a va_list that has an indeterminate value" name="CERT_C-MSC39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP30_C (RULE) Do not depend on the order of evaluation for side effects" name="CERT_C-EXP30" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON40_C (RULE) Do not refer to an atomic variable twice in an expression" name="CERT_C-CON40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP20_C (REC) Perform explicit tests to determine success, true and false, and equality" name="CERT_C-EXP20" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON43_C (RULE) Do not allow data races in multithreaded code" name="CERT_C-CON43" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON41_C (RULE) Wrap functions that can fail spuriously in a loop" name="CERT_C-CON41" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC41_C (RULE) Never hard code sensitive information" name="CERT_C-MSC41" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC40_C (RULE) Do not violate constraints" name="CERT_C-MSC40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM33_C (RULE) Allocate and copy structures containing a flexible array member dynamically" name="CERT_C-MEM33" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM34_C (RULE) Only free memory allocated dynamically" name="CERT_C-MEM34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM31_C (RULE) Free dynamically allocated memory when no longer needed" name="CERT_C-MEM31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM35_C (RULE) Allocate sufficient memory for an object" name="CERT_C-MEM35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG01_C (REC) Understand implementation-specific details regarding signal handler persistence" name="CERT_C-SIG01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM36_C (RULE) Do not modify the alignment of objects by calling realloc()" name="CERT_C-MEM36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG00_C (REC) Mask signals handled by noninterruptible signal handlers" name="CERT_C-SIG00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-API00_C (REC) Functions should validate their parameters" name="CERT_C-API00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO24_C (REC) Do not open a file that is already open" name="CERT_C-FIO24" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG02_C (REC) Avoid using signals to implement normal functionality" name="CERT_C-SIG02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO21_C (REC) Do not create temporary files in shared directories" name="CERT_C-FIO21" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO22_C (REC) Close files before spawning processes" name="CERT_C-FIO22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP40_C (RULE) Do not modify constant objects" name="CERT_C-EXP40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM30_C (RULE) Do not access freed memory" name="CERT_C-MEM30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP33_C (RULE) Do not read uninitialized memory" name="CERT_C-EXP33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP34_C (RULE) Do not dereference null pointers" name="CERT_C-EXP34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP32_C (RULE) Do not access a volatile object through a nonvolatile reference" name="CERT_C-EXP32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON32_C (RULE) Prevent data races when accessing bit-fields from multiple threads" name="CERT_C-CON32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP37_C (RULE) Call functions with the correct number and type of arguments" name="CERT_C-EXP37" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON33_C (RULE) Avoid race conditions when using library functions" name="CERT_C-CON33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON30_C (RULE) Clean up thread-specific storage" name="CERT_C-CON30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP35_C (RULE) Do not modify objects with temporary lifetime" name="CERT_C-EXP35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON31_C (RULE) Do not destroy a mutex while it is locked" name="CERT_C-CON31" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP36_C (RULE) Do not cast pointers into more strictly aligned pointer types" name="CERT_C-EXP36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON36_C (RULE) Wrap functions that can spuriously wake up in a loop" name="CERT_C-CON36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON37_C (RULE) Do not call signal() in a multithreaded program" name="CERT_C-CON37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON34_C (RULE) Declare objects shared between threads with appropriate storage durations" name="CERT_C-CON34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP39_C (RULE) Do not access a variable through a pointer of an incompatible type" name="CERT_C-EXP39" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON35_C (RULE) Avoid deadlock by locking in a predefined order" name="CERT_C-CON35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON38_C (RULE) Preserve thread safety and liveness when using condition variables" name="CERT_C-CON38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON39_C (RULE) Do not join or detach a thread that was previously joined or detached" name="CERT_C-CON39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL22_C (REC) Use volatile for data that cannot be cached" name="CERT_C-DCL22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL20_C (REC) Explicitly specify void when a function accepts no arguments" name="CERT_C-DCL20" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP00_C (REC) Use parentheses for precedence of operation" name="CERT_C-EXP00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP05_C (REC) Do not cast away a const qualification" name="CERT_C-EXP05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP02_C (REC) Be aware of the short-circuit behavior of the logical AND and OR operators" name="CERT_C-EXP02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP08_C (REC) Ensure pointer arithmetic is used correctly" name="CERT_C-EXP08" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL19_C (REC) Minimize the scope of variables and functions" name="CERT_C-DCL19" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL18_C (REC) Do not begin integer constants with 0 when specifying a decimal value" name="CERT_C-DCL18" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL12_C (REC) Implement abstract data types using opaque types" name="CERT_C-DCL12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO01_C (REC) Be careful using functions that use file names for identification" name="CERT_C-FIO01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL11_C (REC) Understand the type issues associated with variadic functions" name="CERT_C-DCL11" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL10_C (REC) Maintain the contract between the writer and caller of variadic functions" name="CERT_C-DCL10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL16_C (REC) Use &quot;L,&quot; not &quot;l,&quot; to indicate a long value" name="CERT_C-DCL16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL15_C (REC) Declare file-scope objects or functions that do not need external linkage as static" name="CERT_C-DCL15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL13_C (REC) Declare function parameters that are pointers to values not changed by the function as const" name="CERT_C-DCL13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP12_C (REC) Do not ignore values returned by functions" name="CERT_C-EXP12" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP10_C (REC) Do not depend on the order of evaluation of subexpressions or the order in which side effects take place" name="CERT_C-EXP10" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP15_C (REC) Do not place a semicolon on the same line as an if, for, or while statement" name="CERT_C-EXP15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP16_C (REC) Do not compare function pointers to constant values" name="CERT_C-EXP16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP14_C (REC) Beware of integer promotion when performing bitwise operations on integer types smaller than int" name="CERT_C-EXP14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP19_C (REC) Use braces for the body of an if, for, or while statement" name="CERT_C-EXP19" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR00_C (REC) Represent characters using an appropriate type" name="CERT_C-STR00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR09_C (REC) Don't assume numeric values for expressions with type plain character" name="CERT_C-STR09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR07_C (REC) Use the bounds-checking interfaces for string manipulation" name="CERT_C-STR07" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR04_C (REC) Use plain char for characters in the basic character set" name="CERT_C-STR04" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR05_C (REC) Use pointers to const when referring to string literals" name="CERT_C-STR05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR02_C (REC) Sanitize data passed to complex subsystems" name="CERT_C-STR02" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR03_C (REC) Do not inadvertently truncate a string" name="CERT_C-STR03" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL41_C (RULE) Do not declare variables inside a switch statement before the first case label" name="CERT_C-DCL41" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL40_C (RULE) Do not create incompatible declarations of the same function or object" name="CERT_C-DCL40" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON01_C (REC) Acquire and release synchronization primitives in the same module, at the same level of abstraction" name="CERT_C-CON01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON02_C (REC) Do not use volatile as a synchronization primitive" name="CERT_C-CON02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON05_C (REC) Do not perform operations that can block while holding a lock" name="CERT_C-CON05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR11_C (REC) Do not specify the bound of a character array initialized with a string literal" name="CERT_C-STR11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL39_C (RULE) Avoid information leakage when passing a structure across a trust boundary" name="CERT_C-DCL39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR10_C (REC) Do not concatenate different type of string literals" name="CERT_C-STR10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL31_C (RULE) Declare identifiers before using them" name="CERT_C-DCL31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL38_C (RULE) Use the correct syntax when declaring a flexible array member" name="CERT_C-DCL38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL37_C (RULE) Do not declare or define a reserved identifier" name="CERT_C-DCL37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL36_C (RULE) Do not declare an identifier with conflicting linkage classifications" name="CERT_C-DCL36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL30_C (RULE) Declare objects with appropriate storage durations" name="CERT_C-DCL30" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR01_C (REC) Do not apply the sizeof operator to a pointer when taking the size of an array" name="CERT_C-ARR01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR02_C (REC) Explicitly specify array bounds, even if implicitly defined by an initializer" name="CERT_C-ARR02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE02_C (REC) Macro replacement lists should be parenthesized" name="CERT_C-PRE02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE00_C (REC) Prefer inline or static functions to function-like macros" name="CERT_C-PRE00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE01_C (REC) Use parentheses within macros around parameter names" name="CERT_C-PRE01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE06_C (REC) Enclose header files in an include guard" name="CERT_C-PRE06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE07_C (REC) Avoid using repeated question marks" name="CERT_C-PRE07" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS54_C (RULE) Detect and handle POSIX library errors" name="CERT_C-POS54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR30_C (RULE) Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure" name="CERT_C-ERR30" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR32_C (RULE) Do not rely on indeterminate values of errno" name="CERT_C-ERR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR33_C (RULE) Detect and handle standard library errors" name="CERT_C-ERR33" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR34_C (RULE) Detect errors when converting a string to a number" name="CERT_C-ERR34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS51_C (RULE) Avoid deadlock with POSIX threads by locking in predefined order" name="CERT_C-POS51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS50_C (RULE) Declare objects shared between POSIX threads with appropriate storage durations" name="CERT_C-POS50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS53_C (RULE) Do not use more than one mutex for concurrent waiting operations on a condition variable" name="CERT_C-POS53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS52_C (RULE) Do not perform operations that can block while holding a POSIX lock" name="CERT_C-POS52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR06_C (REC) Understand the termination behavior of assert() and abort()" name="CERT_C-ERR06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR07_C (REC) Prefer functions that support error checking over equivalent functions that don't" name="CERT_C-ERR07" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL06_C (REC) Use meaningful symbolic constants to represent literal values" name="CERT_C-DCL06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL01_C (REC) Do not reuse variable names in subscopes" name="CERT_C-DCL01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL00_C (REC) Const-qualify immutable objects" name="CERT_C-DCL00" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL05_C (REC) Use typedefs of non-pointer types only" name="CERT_C-DCL05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL04_C (REC) Do not declare more than one variable per declaration" name="CERT_C-DCL04" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL02_C (REC) Use visually distinct identifiers" name="CERT_C-DCL02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS44_C (RULE) Do not use signals to terminate threads" name="CERT_C-POS44" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS48_C (RULE) Do not unlock or destroy another POSIX thread's mutex" name="CERT_C-POS48" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS47_C (RULE) Do not use threads that can be canceled asynchronously" name="CERT_C-POS47" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS49_C (RULE) When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed" name="CERT_C-POS49" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-WIN30_C (RULE) Properly pair allocation and deallocation functions" name="CERT_C-WIN30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR01_C (REC) Use ferror() rather than errno to check for FILE stream errors" name="CERT_C-ERR01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR02_C (REC) Avoid in-band error indicators" name="CERT_C-ERR02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR04_C (REC) Choose an appropriate termination strategy" name="CERT_C-ERR04" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR05_C (REC) Application-independent code should provide error detection without dictating error handling" name="CERT_C-ERR05" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP37_C (RULE) Do not use object representations to compare floating-point values" name="CERT_C-FLP37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP36_C (RULE) Preserve precision when converting integral values to floating-point type" name="CERT_C-FLP36" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP34_C (RULE) Ensure that floating-point conversions are within range of the new type" name="CERT_C-FLP34" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS33_C (RULE) Do not use vfork()" name="CERT_C-POS33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR32_C (RULE) Ensure size arguments for variable length arrays are in a valid range" name="CERT_C-ARR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS35_C (RULE) Avoid race conditions while checking for the existence of a symbolic link" name="CERT_C-POS35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS34_C (RULE) Do not call putenv() with a pointer to an automatic variable as the argument" name="CERT_C-POS34" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR30_C (RULE) Do not form or use out-of-bounds pointers or array subscripts" name="CERT_C-ARR30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS37_C (RULE) Ensure that privilege relinquishment is successful" name="CERT_C-POS37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP32_C (RULE) Prevent or detect domain and range errors in math functions" name="CERT_C-FLP32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS36_C (RULE) Observe correct revocation order while relinquishing privileges" name="CERT_C-POS36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS39_C (RULE) Use the correct byte ordering when transferring data between systems" name="CERT_C-POS39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP30_C (RULE) Do not use floating-point variables as loop counters" name="CERT_C-FLP30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS38_C (RULE) Beware of race conditions when using fork and file descriptors" name="CERT_C-POS38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR39_C (RULE) Do not add or subtract a scaled integer to a pointer" name="CERT_C-ARR39" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR38_C (RULE) Guarantee that library functions do not form invalid pointers" name="CERT_C-ARR38" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR37_C (RULE) Do not add or subtract an integer to a pointer to a non-array object" name="CERT_C-ARR37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR36_C (RULE) Do not subtract or compare two pointers that do not refer to the same array" name="CERT_C-ARR36" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS30_C (RULE) Use the readlink() function properly" name="CERT_C-POS30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="SEI CERT C++" name="CERT_CPP" total="143">
               <Category desc="CERT-DCL55_CPP (RULE) Avoid information leakage when passing a class object across a trust boundary" name="CERT_CPP-DCL55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR52_CPP (RULE) Do not use setjmp() or longjmp()" name="CERT_CPP-ERR52" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL56_CPP (RULE) Avoid cycles during initialization of static objects" name="CERT_CPP-DCL56" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR51_CPP (RULE) Handle all exceptions" name="CERT_CPP-ERR51" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON56_CPP (RULE) Do not speculatively lock a non-recursive mutex that is already owned by the calling thread" name="CERT_CPP-CON56" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL53_CPP (RULE) Do not write syntactically ambiguous declarations" name="CERT_CPP-DCL53" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR50_CPP (RULE) Do not abruptly terminate the program" name="CERT_CPP-ERR50" total="14">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL54_CPP (RULE) Overload allocation and deallocation functions as a pair in the same scope" name="CERT_CPP-DCL54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL59_CPP (RULE) Do not define an unnamed namespace in a header file" name="CERT_CPP-DCL59" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM51_CPP (RULE) Properly deallocate dynamically allocated resources" name="CERT_CPP-MEM51" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM52_CPP (RULE) Detect and handle memory allocation errors" name="CERT_CPP-MEM52" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL57_CPP (RULE) Do not let exceptions escape from destructors or deallocation functions" name="CERT_CPP-DCL57" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL58_CPP (RULE) Do not modify the standard namespaces" name="CERT_CPP-DCL58" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM50_CPP (RULE) Do not access freed memory" name="CERT_CPP-MEM50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON50_CPP (RULE) Do not destroy a mutex while it is locked" name="CERT_CPP-CON50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM55_CPP (RULE) Honor replacement dynamic storage management requirements" name="CERT_CPP-MEM55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON51_CPP (RULE) Ensure actively held locks are released on exceptional conditions" name="CERT_CPP-CON51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR59_CPP (RULE) Do not throw an exception across execution boundaries" name="CERT_CPP-ERR59" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM56_CPP (RULE) Do not store an already-owned pointer value in an unrelated smart pointer" name="CERT_CPP-MEM56" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR58_CPP (RULE) Handle all exceptions thrown before main() begins executing" name="CERT_CPP-ERR58" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM53_CPP (RULE) Explicitly construct and destruct objects when manually managing object lifetime" name="CERT_CPP-MEM53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR57_CPP (RULE) Do not leak resources when handling exceptions" name="CERT_CPP-ERR57" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM54_CPP (RULE) Provide placement new with properly aligned pointers to sufficient storage capacity" name="CERT_CPP-MEM54" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON54_CPP (RULE) Wrap functions that can spuriously wake up in a loop" name="CERT_CPP-CON54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR56_CPP (RULE) Guarantee exception safety" name="CERT_CPP-ERR56" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON55_CPP (RULE) Preserve thread safety and liveness when using condition variables" name="CERT_CPP-CON55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR55_CPP (RULE) Honor exception specifications" name="CERT_CPP-ERR55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON52_CPP (RULE) Prevent data races when accessing bit-fields from multiple threads" name="CERT_CPP-CON52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR54_CPP (RULE) Catch handlers should order their parameter types from most derived to least derived" name="CERT_CPP-ERR54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM57_CPP (RULE) Avoid using default operator new for over-aligned types" name="CERT_CPP-MEM57" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON53_CPP (RULE) Avoid deadlock by locking in a predefined order" name="CERT_CPP-CON53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR53_CPP (RULE) Do not reference base classes or class data members in a constructor or destructor function-try-block handler" name="CERT_CPP-ERR53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR53_CPP (RULE) Range check element access" name="CERT_CPP-STR53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL51_CPP (RULE) Do not declare or define a reserved identifier" name="CERT_CPP-DCL51" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR50_CPP (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator" name="CERT_CPP-STR50" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL52_CPP (RULE) Never qualify a reference type with const or volatile" name="CERT_CPP-DCL52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR52_CPP (RULE) Use valid references, pointers, and iterators to reference elements of a basic_string" name="CERT_CPP-STR52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL50_CPP (RULE) Do not define a C-style variadic function" name="CERT_CPP-DCL50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR51_CPP (RULE) Do not attempt to create a std::string from a null pointer" name="CERT_CPP-STR51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP53_CPP (RULE) Write constructor member initializers in the canonical order" name="CERT_CPP-OOP53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP52_CPP (RULE) Do not delete a polymorphic object without a virtual destructor" name="CERT_CPP-OOP52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP51_CPP (RULE) Do not slice derived objects" name="CERT_CPP-OOP51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP50_CPP (RULE) Do not invoke virtual functions from constructors or destructors" name="CERT_CPP-OOP50" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP57_CPP (RULE) Prefer special member functions and overloaded operators to C Standard Library functions" name="CERT_CPP-OOP57" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC50_CPP (RULE) Do not use std::rand() for generating pseudorandom numbers" name="CERT_CPP-MSC50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP56_CPP (RULE) Honor replacement handler requirements" name="CERT_CPP-OOP56" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC51_CPP (RULE) Ensure your random number generator is properly seeded" name="CERT_CPP-MSC51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP55_CPP (RULE) Do not use pointer-to-member operators to access nonexistent members" name="CERT_CPP-OOP55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC52_CPP (RULE) Value-returning functions must return a value from all exit paths" name="CERT_CPP-MSC52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP54_CPP (RULE) Gracefully handle self-copy assignment" name="CERT_CPP-OOP54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-OOP58_CPP (RULE) Copy operations must not mutate the source object" name="CERT_CPP-OOP58" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO51_CPP (RULE) Close files when they are no longer needed" name="CERT_CPP-FIO51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO50_CPP (RULE) Do not alternately input and output from a file stream without an intervening positioning call" name="CERT_CPP-FIO50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL60_CPP (RULE) Obey the one-definition rule" name="CERT_CPP-DCL60" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP55_CPP (RULE) Do not access a cv-qualified object through a cv-unqualified type" name="CERT_CPP-EXP55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP56_CPP (RULE) Do not call a function with a mismatched language linkage" name="CERT_CPP-EXP56" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP53_CPP (RULE) Do not read uninitialized memory" name="CERT_CPP-EXP53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP54_CPP (RULE) Do not access an object outside of its lifetime" name="CERT_CPP-EXP54" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP59_CPP (RULE) Use offsetof() on valid types and members" name="CERT_CPP-EXP59" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP57_CPP (RULE) Do not cast or delete pointers to incomplete classes" name="CERT_CPP-EXP57" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP58_CPP (RULE) Pass an object of the correct type to va_start" name="CERT_CPP-EXP58" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP62_CPP (RULE) Do not access the bits of an object representation that are not part of the object's value representation" name="CERT_CPP-EXP62" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP63_CPP (RULE) Do not rely on the value of a moved-from object" name="CERT_CPP-EXP63" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP60_CPP (RULE) Do not pass a nonstandard-layout type object across execution boundaries" name="CERT_CPP-EXP60" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP61_CPP (RULE) A lambda object must not outlive any of its reference captured objects" name="CERT_CPP-EXP61" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC53_CPP (RULE) Do not return from a function declared [[noreturn]]" name="CERT_CPP-MSC53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC54_CPP (RULE) A signal handler must be a plain old function" name="CERT_CPP-MSC54" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR62_CPP (RULE) Detect errors when converting a string to a number" name="CERT_CPP-ERR62" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR61_CPP (RULE) Catch exceptions by lvalue reference" name="CERT_CPP-ERR61" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR60_CPP (RULE) Exception objects must be nothrow copy constructible" name="CERT_CPP-ERR60" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR57_CPP (RULE) Provide a valid ordering predicate" name="CERT_CPP-CTR57" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR58_CPP (RULE) Predicate function objects should not be mutable" name="CERT_CPP-CTR58" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR53_CPP (RULE) Use valid iterator ranges" name="CERT_CPP-CTR53" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR54_CPP (RULE) Do not subtract iterators that do not refer to the same container" name="CERT_CPP-CTR54" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR55_CPP (RULE) Do not use an additive operator on an iterator if the result would overflow" name="CERT_CPP-CTR55" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR56_CPP (RULE) Do not use pointer arithmetic on polymorphic objects" name="CERT_CPP-CTR56" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR50_CPP (RULE) Guarantee that container indices and iterators are within the valid range" name="CERT_CPP-CTR50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR51_CPP (RULE) Use valid references, pointers, and iterators to reference elements of a container" name="CERT_CPP-CTR51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CTR52_CPP (RULE) Guarantee that library functions do not overflow" name="CERT_CPP-CTR52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT50_CPP (RULE) Do not cast to an out-of-range enumeration value" name="CERT_CPP-INT50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP51_CPP (RULE) Do not delete an array through a pointer of the incorrect type" name="CERT_CPP-EXP51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP52_CPP (RULE) Do not rely on side effects in unevaluated operands" name="CERT_CPP-EXP52" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP50_CPP (RULE) Do not depend on the order of evaluation for side effects" name="CERT_CPP-EXP50" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Coding Conventions" name="CODSTA" total="550">
               <Category desc="Coding Conventions for C++" name="CODSTA-CPP" total="133">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Comments" name="COMMENT" total="17">
               <Stats authTot="181;" total="181"/>
            </Category>
            <Category desc="Common Weakness Enumeration" name="CWE" total="92">
               <Category desc="CWE-312: Cleartext Storage of Sensitive Information" name="CWE-312" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-532 Inclusion of Sensitive Information in Log Files" name="CWE-532" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-772 Missing Release of Resource after Effective Lifetime" name="CWE-772" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-476 NULL Pointer Dereference" name="CWE-476" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-770 Allocation of Resources Without Limits or Throttling" name="CWE-770" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-190 Integer Overflow or Wraparound" name="CWE-190" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')" name="CWE-77" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-78 Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" name="CWE-78" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-617 Reachable Assertion" name="CWE-617" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-835 Loop with Unreachable Exit Condition ('Infinite Loop')" name="CWE-835" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-415 Double Free" name="CWE-415" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer" name="CWE-119" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-416 Use After Free" name="CWE-416" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-59: Improper Link Resolution Before File Access ('Link Following')" name="CWE-59" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-611 Improper Restriction of XML External Entity Reference" name="CWE-611" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-732 Incorrect Permission Assignment for Critical Resource" name="CWE-732" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-798 Use of Hard-coded Credentials" name="CWE-798" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-125 Out-of-bounds Read" name="CWE-125" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-400 Uncontrolled Resource Consumption" name="CWE-400" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-269 Improper Privilege Management" name="CWE-269" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-401: Missing Release of Memory after Effective Lifetime" name="CWE-401" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-863 Incorrect Authorization" name="CWE-863" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-200 Information Exposure" name="CWE-200" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-287 Improper Authentication" name="CWE-287" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-362 Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" name="CWE-362" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-20 Improper Input Validation" name="CWE-20" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-22 Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')" name="CWE-22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-89 Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" name="CWE-89" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-704 Incorrect Type Conversion or Cast" name="CWE-704" total="12">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-426 Untrusted Search Path" name="CWE-426" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-668: Exposure of Resource to Wrong Sphere" name="CWE-668" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-427: Uncontrolled Search Path Element" name="CWE-427" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-787 Out-of-bounds Write" name="CWE-787" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-326 Inadequate Encryption Strength" name="CWE-326" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')" name="CWE-843" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Exceptions" name="EXCEPT" total="27">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Formatting" name="FORMAT" total="52">
               <Stats authTot="274;" total="274"/>
            </Category>
            <Category desc="Global Static Analysis" name="GLOBAL" total="30">
               <Stats authTot="23;" total="23"/>
            </Category>
            <Category desc="High Integrity C++" name="HICPP" total="239">
               <Category desc="HIC++ 7.2.2 Initialize none, the first only or all enumerators in an enumeration" name="HICPP-7_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.1.1 Do not use tab characters in source files" name="HICPP-2_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.5.3 Use nullptr for the null pointer constant" name="HICPP-2_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 15.1.1 Only use instances of std::exception for exceptions" name="HICPP-15_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.5.2 Do not use octal constants (other than zero)" name="HICPP-2_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.5.1 Do not concatenate strings with different encoding prefixes" name="HICPP-2_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.4.4 Write members in an initialization list in the order in which they are declared" name="HICPP-12_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.2.1 Use an explicit enumeration base and ensure that it is large enough to store all enumerators" name="HICPP-7_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.4.5 Use delegating constructors to reduce code duplication" name="HICPP-12_4_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.3.1 Do not use variables with static storage duration" name="HICPP-3_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.5.1 Do not ignore the result of std::remove, std::remove if or std::unique" name="HICPP-17_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.2.5 Implement a minimal set of operators and use them to implement all other related operators" name="HICPP-13_2_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 4.1.1 Ensure that a function argument does not undergo an array-to-pointer conversion" name="HICPP-4_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.4.2 Ensure that a braced aggregate initializer matches the layout of the aggregate object" name="HICPP-8_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.4.1 Do not access an invalid object or an object with indeterminate value" name="HICPP-8_4_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.1.2 If a member of a set of callable functions includes a universal reference parameter, ensure that one appears in the same position for all other members" name="HICPP-13_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.1 Within the scope of a lock, ensure that no static path results in a lock of the same mutex" name="HICPP-18_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.2 Ensure that order of nesting of locks in a project forms a DAG" name="HICPP-18_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.5 Do not access the members of std::mutex directly" name="HICPP-18_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.6 Do not use relaxed atomics" name="HICPP-18_3_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.3.3 Ensure that the form of delete matches the form of new used to allocate the memory" name="HICPP-5_3_3" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.3 Do not use std::recursive mutex" name="HICPP-18_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.7.2 Ensure that a pointer to member that is a virtual function is only compared (==) with nullptr" name="HICPP-5_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.1.1 Ensure that all overloads of a function are visible from where it is called" name="HICPP-13_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.3.4 Only use std::unique lock when std::lock guard cannot be used" name="HICPP-18_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.7.1 Do not write code that expects floating point calculations to yield exact results" name="HICPP-5_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.3.2 Allocate memory using new and release it using delete" name="HICPP-5_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.3.1 Do not apply unary minus to operands of unsigned type" name="HICPP-5_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.2.1 Declare bit-fields with an explicitly unsigned integral or enumeration type" name="HICPP-9_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.3.1 Correctly declare overloads for operator new and delete" name="HICPP-12_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.1.4 Ensure that a switch statement has at least two case labels, distinct from the default label" name="HICPP-6_1_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 11.1.1 Declare all data members private" name="HICPP-11_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.1.3 Ensure that a non-empty case statement block does not fall through to the next label" name="HICPP-6_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.1.2 Explicitly cover all paths through multi-way selection statements" name="HICPP-6_1_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.1.1 Enclose the body of a selection or an iteration statement in a compound statement" name="HICPP-6_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.3.1 Do not use using directives" name="HICPP-7_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 15.2.1 Do not throw an exception from a destructor" name="HICPP-15_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.4.1 Ensure that each identifier is distinct from any other visible identifier" name="HICPP-2_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.7 Declare assignment operators with the ref-qualifier &amp;" name="HICPP-12_5_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 10.3.1 Ensure that a derived class has at most one base class which is not an interface class" name="HICPP-10_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.8 Make the copy assignment operator of an abstract class protected or define it =delete" name="HICPP-12_5_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.6 Use an atomic, non-throwing swap operation to implement the copy and move assignment operators" name="HICPP-12_5_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.3 Ensure that a user defined move/copy constructor only moves/copies base and member objects" name="HICPP-12_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.4 Declare noexcept the move constructor and move assignment operator" name="HICPP-12_5_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.1.1 Do not use multiple levels of pointer indirection" name="HICPP-8_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.2.1 Do not declare functions at block scope" name="HICPP-3_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.4.1 Use const container calls when result is immediately converted to a const iterator" name="HICPP-17_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.4.2 Use API calls that construct objects in place" name="HICPP-17_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 4.4.1 Do not convert floating values to integral types except through use of standard library functions" name="HICPP-4_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.2.1 Do not overload operators with special semantics" name="HICPP-13_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.2.2 Synchronize access to data shared between threads using a single lock" name="HICPP-18_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.2.2 Ensure that the return type of an overloaded binary operator matches the built-in counterparts" name="HICPP-13_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.2.3 Do not share volatile data between threads" name="HICPP-18_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.2.3 Declare binary arithmetic and bitwise operators as non-members" name="HICPP-13_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 13.2.4 When overloading the subscript operator (operator[]) implement both const and non-const versions" name="HICPP-13_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.2.1 Use high integrity::thread in place of std::thread" name="HICPP-18_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.6.1 Do not use bitwise operators with signed operands" name="HICPP-5_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.2.4 Use std::call_once rather than the Double-Checked Locking pattern" name="HICPP-18_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.2.1 Ensure that pointer or array access is demonstrably within bounds of a valid object" name="HICPP-5_2_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.2.2 Ensure that functions do not call themselves, either directly or indirectly" name="HICPP-5_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.4.2 Ensure that a constructor initializes explicitly all base classes and non-static data members" name="HICPP-12_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.4.3 Do not specify both an NSDMI and a member initializer in a constructor for the same non static member" name="HICPP-12_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.4.1 Do not use the dynamic type of an object unless the object is fully constructed" name="HICPP-12_4_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.4.1 Postpone variable definitions as long as possible" name="HICPP-6_4_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 15.3.2 Ensure that a program does not result in a call to std::terminate" name="HICPP-15_3_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 16.1.1 Use the preprocessor only for implementing include guards, and including header files with include guards" name="HICPP-16_1_1" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 16.1.2 Do not include a path specifier in filenames supplied in #include directives" name="HICPP-16_1_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 11.2.1 Do not use friend declarations" name="HICPP-11_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.3.1 Do not use the C comment delimiters /* ... */" name="HICPP-2_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.4.1 Ensure that any objects, functions or types to be used from a single translation unit are defined in an unnamed namespace in the main source file" name="HICPP-7_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.4.3 Ensure that an object or a function used from multiple translation units is declared in a single header file" name="HICPP-7_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.4.2 Ensure that an inline function, a function template, or a type used from multiple translation units is defined in a single header file" name="HICPP-7_4_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 16.1.5 Include directly the minimum number of headers required for compilation" name="HICPP-16_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 16.1.3 Match the filename in a #include directive to the one on the filesystem" name="HICPP-16_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 15.3.1 Do not access non-static members from a catch handler of constructor/destructor function try block" name="HICPP-15_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 16.1.4 Use &lt;> brackets for system and standard library headers. Use quotes for all other headers" name="HICPP-16_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.3.2 Do not comment out code" name="HICPP-2_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 10.2.1 Use the override special identifier when overriding a virtual function" name="HICPP-10_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.3.4 Do not create smart pointers of array type" name="HICPP-17_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.3.5 Do not create an rvalue reference of std::array" name="HICPP-17_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.1.1 Do not hide declarations" name="HICPP-3_1_1" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.3.1 Do not use std::move on objects declared with const or const &amp; type" name="HICPP-17_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 14.1.1 Use variadic templates rather than an ellipsis" name="HICPP-14_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.3.2 Use std::forward to forward universal references" name="HICPP-17_3_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.3.3 Do not subsequently use the argument to std::forward" name="HICPP-17_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.5.1 Do not make any assumptions about the internal representation of a value or object" name="HICPP-3_5_1" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 4.3.1 Do not convert an expression of wider floating point type to a narrower floating point type" name="HICPP-4_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.10 Use static assert for assertions involving compile time constants" name="HICPP-7_1_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.2.4 Do not pass std::unique ptr by const reference" name="HICPP-8_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.2.3 Pass small objects with a trivial copy constructor by value" name="HICPP-8_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.2.2 Do not declare functions with an excessive number of parameters" name="HICPP-8_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.2.1 Make parameter names absent or identical in all declarations" name="HICPP-8_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.1.1 Do not use platform specific multi-threading facilities" name="HICPP-18_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.6 Do not code side effects into the right-hand operands of: &amp;&amp;, ||, sizeof, typeid or a function passed to condition variable::wait" name="HICPP-5_1_6" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.5 Include a (possibly empty) parameter list in every lambda expression" name="HICPP-5_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.5.1 Ensure that the right hand operand of the division or remainder operators is demonstrably non-zero" name="HICPP-5_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.2 Do not rely on the sequence of evaluation within an expression" name="HICPP-5_1_2" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.1 Use symbolic names instead of literal values in code" name="HICPP-5_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.4 Do not capture variables implicitly in a lambda" name="HICPP-5_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.1.3 Use parentheses in expressions to specify the intent of the expression" name="HICPP-5_1_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.1 Define explicitly =default or =delete implicit special member functions of concrete classes" name="HICPP-12_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.5.2 Define special members =default if the behavior is equivalent" name="HICPP-12_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.3.2 Ensure that execution of a function with a non-void return type ends in a return statement with a value" name="HICPP-6_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.1.1 Do not declare implicit user defined conversions" name="HICPP-12_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.2.1 Ensure that all statements are reachable" name="HICPP-1_2_1" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.2.2 Ensure that no expression or sub-expression is redundant" name="HICPP-1_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.3.1 Ensure that the label(s) for a jump statement or a switch condition appear later, in the same or an enclosing block" name="HICPP-6_3_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.4 Place CV-qualifiers on the right hand side of the type they apply to" name="HICPP-7_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 2.2.1 Do not use digraphs or trigraphs" name="HICPP-2_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.3 Do not place type specifiers before non-type specifiers in a declaration" name="HICPP-7_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.6 Use class types or typedefs to abstract scalar quantities and standard integer types" name="HICPP-7_1_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.5 Do not inline large functions" name="HICPP-7_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.5.1 Do not use the asm declaration" name="HICPP-7_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.8 Use auto id = expr when declaring a variable to have the same type as its initializer function call" name="HICPP-7_1_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.7 Use a trailing return type in preference to type disambiguation using typename" name="HICPP-7_1_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.9 Do not explicitly specify the return type of a lambda" name="HICPP-7_1_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 10.1.1 Ensure that access to base class subobjects does not require explicit disambiguation" name="HICPP-10_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.2 Use const whenever possible" name="HICPP-7_1_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 7.1.1 Declare each identifier on a separate line in a separate declaration" name="HICPP-7_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 14.2.2 Do not explicitly specialize a function template that is overloaded with other templates" name="HICPP-14_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.2.1 Wrap use of the C Standard Library" name="HICPP-17_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.4.1 Do not return a reference or a pointer to an automatic variable defined within the function" name="HICPP-3_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 14.2.3 Declare extern an explicitly instantiated template" name="HICPP-14_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.4.3 Use RAII for resources" name="HICPP-3_4_3" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 14.2.1 Declare template specializations in the same file as the primary template they specialize." name="HICPP-14_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 3.4.2 Do not assign the address of a variable to a pointer with a greater lifetime" name="HICPP-3_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 4.2.2 Ensure that data loss does not demonstrably occur in an integral expression" name="HICPP-4_2_2" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 4.2.1 Ensure that the U suffix is applied to a literal used in a context requiring an unsigned integral expression" name="HICPP-4_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.3.4 Define =delete functions with parameters of type rvalue reference to const" name="HICPP-8_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.3.3 Do not use default arguments" name="HICPP-8_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 8.3.1 Do not write functions with an excessive McCabe Cyclomatic Complexity" name="HICPP-8_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 18.4.1 Do not use std::condition variable any on a std::mutex" name="HICPP-18_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.4.3 Do not convert from a base class to a derived class" name="HICPP-5_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.4.2 Do not cast an expression to an enumeration type" name="HICPP-5_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.8.1 Do not use the conditional operator (?:) as a sub-expression" name="HICPP-5_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 5.4.1 Only use casting forms: static cast (excl. void*), dynamic cast or explicit constructor call" name="HICPP-5_4_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.1.5 Do not introduce virtual functions in a final class" name="HICPP-9_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 17.1.1 Do not use std::vector&lt;bool>" name="HICPP-17_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.1.3 Do not return non-const handles to class data from const member functions" name="HICPP-9_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.1.4 Do not write member functions which return non-const handles to data less accessible than the member function" name="HICPP-9_1_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.1.1 Declare static any member function that does not require this. Alternatively, declare const any member function that does not modify the externally visible state of the object" name="HICPP-9_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 9.1.2 Make default arguments the same or absent when overriding a virtual function" name="HICPP-9_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.3.4 Do not use deprecated STL library features" name="HICPP-1_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.3.3 Do not use the C Standard Library .h headers" name="HICPP-1_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.2.4 Only modify a for loop counter in the for expression" name="HICPP-6_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.3.5 Do not use throw exception specifications" name="HICPP-1_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.2.3 Do not alter a control or counter variable more than once in a loop" name="HICPP-6_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 12.2.1 Declare virtual, private or protected the destructor of a type used as a base class" name="HICPP-12_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.3.2 Do not use the register keyword" name="HICPP-1_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 1.3.1 Do not use the increment operator (++) on a variable of type bool" name="HICPP-1_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.2.2 Ensure that a loop has a single loop counter, an optional control variable, and is not degenerate" name="HICPP-6_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="HIC++ 6.2.1 Implement a loop that only uses element values as a range-based loop" name="HICPP-6_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Initialization" name="INIT" total="25">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Joint Strike Fighter" name="JSF" total="278">
               <Stats authTot="484;" total="484"/>
            </Category>
            <Category desc="Metrics" name="METRICS" total="44">
               <Stats authTot="70;" total="70"/>
            </Category>
            <Category desc="MISRA C 1998" name="MISRA" total="62">
               <Stats authTot="59;" total="59"/>
            </Category>
            <Category desc="MISRA C 2004" name="MISRA2004" total="223">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="MISRA C++ 2008" name="MISRA2008" total="342">
               <Stats authTot="242;" total="242"/>
            </Category>
            <Category desc="MISRA C 2012 (Legacy)" name="MISRA2012" total="382">
               <Category desc="MISRA C 2012 Rules" name="MISRA2012-RULE" total="331">
                  <Stats authTot="71;" total="71"/>
               </Category>
               <Category desc="MISRA C 2012 Directives" name="MISRA2012-DIR" total="51">
                  <Stats authTot="52;" total="52"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="MISRA C 2023 (MISRA C 2012)" name="MISRAC2012" total="382">
               <Category desc="Rule 11.3 (Required) A conversion shall not be performed between a pointer to object type and a pointer to a different object type" name="MISRAC2012-RULE_11_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.5 (Required) An external object or function shall be declared once in one and only one file" name="MISRAC2012-RULE_8_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.4 (Advisory) A conversion should not be performed between a pointer to object and an integer type" name="MISRAC2012-RULE_11_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.6 (Required) An identifier with external linkage shall have exactly one external definition" name="MISRAC2012-RULE_8_6" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.5 (Advisory) A conversion should not be performed from pointer to void into pointer to object" name="MISRAC2012-RULE_11_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.3 (Required) All declarations of an object or function shall use the same names and type qualifiers" name="MISRAC2012-RULE_8_3" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.6 (Required) A cast shall not be performed between pointer to void and an arithmetic type" name="MISRAC2012-RULE_11_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.4 (Required) A compatible declaration shall be visible when an object or function with external linkage is defined" name="MISRAC2012-RULE_8_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.7 (Required) A cast shall not be performed between pointer to object and a non-integer arithmetic type" name="MISRAC2012-RULE_11_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.9 (Advisory) An object should be declared at block scope if its identifier only appears in a single function" name="MISRAC2012-RULE_8_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.8 (Required) A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer" name="MISRAC2012-RULE_11_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.9 (Required) The macro NULL shall be the only permitted form of integer null pointer constant" name="MISRAC2012-RULE_11_9" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.1 (Mandatory) An object shall not be assigned or copied to an overlapping object" name="MISRAC2012-RULE_19_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.7 (Advisory) Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" name="MISRAC2012-RULE_8_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.15 (Required) Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs" name="MISRAC2012-DIR_4_15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.2 (Advisory) The union keyword should not be used" name="MISRAC2012-RULE_19_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.8 (Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage" name="MISRAC2012-RULE_8_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.14 (Required) The validity of values received from external sources shall be checked" name="MISRAC2012-DIR_4_14" total="12">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.13 (Advisory) Functions which are designed to provide operations on a resource should be called in an appropriate sequence" name="MISRAC2012-DIR_4_13" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.12 (Required) Dynamic memory allocation shall not be used" name="MISRAC2012-DIR_4_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.11 (Required) The validity of values passed to library functions shall be checked" name="MISRAC2012-DIR_4_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.10 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once" name="MISRAC2012-DIR_4_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 5.3 (Required) There shall be no dynamic thread creation" name="MISRAC2012-DIR_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 5.2 (Required) There shall be no deadlocks between threads" name="MISRAC2012-DIR_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 5.1 (Required) There shall be no data races between threads" name="MISRAC2012-DIR_5_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.10 (Required) The _Atomic qualifier shall not be applied to the incomplete type void" name="MISRAC2012-RULE_11_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.1 (Required) Types shall be explicitly specified" name="MISRAC2012-RULE_8_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2 (Required) Function types shall be in prototype form with named parameters" name="MISRAC2012-RULE_8_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.1 (Required) Conversions shall not be performed between a pointer to a function and any other type" name="MISRAC2012-RULE_11_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.2 (Required) Conversions shall not be performed between a pointer to an incomplete type and any other type" name="MISRAC2012-RULE_11_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.3 (Required) The same file shall not be open for read and write access at the same time on different streams" name="MISRAC2012-RULE_22_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.4 (Mandatory) There shall be no attempt to write to a stream which has been opened as read-only" name="MISRAC2012-RULE_22_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.5 (Mandatory) A pointer to a FILE object shall not be dereferenced" name="MISRAC2012-RULE_22_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.6 (Mandatory) The value of a pointer to a FILE shall not be used after the associated stream has been closed" name="MISRAC2012-RULE_22_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.7 (Required) The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF" name="MISRAC2012-RULE_22_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.8 (Required) The value of errno shall be set to zero prior to a call to an errno-setting-function" name="MISRAC2012-RULE_22_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.9 (Required) The value of errno shall be tested against zero after calling an errno-setting-function" name="MISRAC2012-RULE_22_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.1 (Required) All resources obtained dynamically by means of Standard Library functions shall be explicitly released" name="MISRAC2012-RULE_22_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.2 (Mandatory) A block of memory shall only be freed if it was allocated by means of a" name="MISRAC2012-RULE_22_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.4 (Required) Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" name="MISRAC2012-RULE_10_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.6 (Required) The small integer variants of the minimum-width integer constant macros shall not be used" name="MISRAC2012-RULE_7_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.5 (Advisory) The value of an expression should not be cast to an inappropriate essential type" name="MISRAC2012-RULE_10_5" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.6 (Required) The value of a composite expression shall not be assigned to an object with wider essential type" name="MISRAC2012-RULE_10_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.4 (Required) A string literal shall not be assigned to an object unless the object's type is &quot;pointer to const-qualified char&quot;" name="MISRAC2012-RULE_7_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.7 (Required) If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" name="MISRAC2012-RULE_10_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.5 (Mandatory) The argument of an integer-constant macro shall have an appropriate form" name="MISRAC2012-RULE_7_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.8 (Required) The value of a composite expression shall not be cast to a different essential type category or a wider essential type" name="MISRAC2012-RULE_10_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.1 (Required) A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand" name="MISRAC2012-RULE_18_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.2 (Required) Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="MISRAC2012-RULE_18_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.3 (Required) The relational operators >, >=, &lt; and &lt;= shall not be applied to expressions of pointer type except where they point into the same object" name="MISRAC2012-RULE_18_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.4 (Advisory) The +, -, += and -= operators should not be applied to an expression of pointer type" name="MISRAC2012-RULE_18_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.5 (Advisory) Declarations should contain no more than two levels of pointer nesting" name="MISRAC2012-RULE_18_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.6 (Required) The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist" name="MISRAC2012-RULE_18_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.7 (Required) Flexible array members shall not be declared" name="MISRAC2012-RULE_18_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.8 (Required) Variable-length arrays shall not be used" name="MISRAC2012-RULE_18_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.9 (Required) An object with temporary lifetime shall not undergo array-to-pointer conversion" name="MISRAC2012-RULE_18_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.2 (Required) A &quot;u&quot; or &quot;U&quot; suffix shall be applied to all integer constants that are represented in an unsigned type" name="MISRAC2012-RULE_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.1 (Required) Operands shall not be of an inappropriate essential type" name="MISRAC2012-RULE_10_1" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.3 (Required) The lowercase character &quot;l&quot; shall not be used in a literal suffix" name="MISRAC2012-RULE_7_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.2 (Required) Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" name="MISRAC2012-RULE_10_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.3 (Required) The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category" name="MISRAC2012-RULE_10_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.1 (Required) Octal constants shall not be used" name="MISRAC2012-RULE_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.4 (Required) The standard header file &lt;setjmp.h> shall not be used" name="MISRAC2012-RULE_21_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.5 (Required) The standard header file &lt;signal.h> shall not be used" name="MISRAC2012-RULE_21_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6 (Required) The Standard Library input/output functions shall not be used" name="MISRAC2012-RULE_21_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.7 (Required) The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.8 (Required) The Standard Library termination functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_8" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.9 (Required) The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.1 (Required) #define and #undef shall not be used on a reserved identifier or reserved macro name" name="MISRAC2012-RULE_21_1" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.2 (Required) A reserved identifier or macro name shall not be declared" name="MISRAC2012-RULE_21_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.3 (Required) The memory allocation and deallocation functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.1 (Required) Initializer lists shall not contain persistent side effects" name="MISRAC2012-RULE_13_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.25 (Required) All memory synchronization operations shall be executed in sequentially consistent order" name="MISRAC2012-RULE_21_25" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.2 (Required) The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving" name="MISRAC2012-RULE_13_2" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.24 (Required) The random number generator functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_24" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.3 (Advisory) A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator" name="MISRAC2012-RULE_13_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.23 (Required) All arguments to any multi-argument type-generic macros declared in &lt;tgmath.h> shall have the same standard type" name="MISRAC2012-RULE_21_23" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.4 (Advisory) The result of an assignment operator should not be used" name="MISRAC2012-RULE_13_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.22 (Mandatory) All arguments to any type-generic macros declared in &lt;tgmath.h> shall have appropriate essential type" name="MISRAC2012-RULE_21_22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.5 (Required) The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects" name="MISRAC2012-RULE_13_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.21 (Required) The Standard Library function system of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_21" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.6 (Required) The operand of the sizeof operator shall not contain any expression which has potential side effects" name="MISRAC2012-RULE_13_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.20 (Mandatory) The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function" name="MISRAC2012-RULE_21_20" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.10 (Mandatory) Pointers to variably-modified array types shall not be used" name="MISRAC2012-RULE_18_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.26 (Required) The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type" name="MISRAC2012-RULE_21_26" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.3 (Advisory) A project should not contain unused type declarations" name="MISRAC2012-RULE_2_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.4 (Advisory) A project should not contain unused tag declarations" name="MISRAC2012-RULE_2_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.1 (Required) A project shall not contain unreachable code" name="MISRAC2012-RULE_2_1" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.2 (Required) A project shall not contain dead code" name="MISRAC2012-RULE_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.7 (Advisory) A function should not contain unused parameters" name="MISRAC2012-RULE_2_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.8 (Advisory) A project should not contain unused object definitions" name="MISRAC2012-RULE_2_8" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.5 (Advisory) A project should not contain unused macro definitions" name="MISRAC2012-RULE_2_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 2.6 (Advisory) A function should not contain unused label declarations" name="MISRAC2012-RULE_2_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.2 (Required) The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand" name="MISRAC2012-RULE_12_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.15 (Required) Thread synchronization objects and thread-specific storage pointers shall not be destroyed until after all threads accessing them have terminated" name="MISRAC2012-RULE_22_15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.4 (Required) An element of an object shall not be initialized more than once" name="MISRAC2012-RULE_9_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.3 (Advisory) The comma operator should not be used" name="MISRAC2012-RULE_12_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.14 (Mandatory) Thread synchronization objects shall be initialized before being accessed" name="MISRAC2012-RULE_22_14" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.5 (Required) Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" name="MISRAC2012-RULE_9_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.4 (Advisory) Evaluation of constant expressions should not lead to unsigned integer wrap-around" name="MISRAC2012-RULE_12_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.13 (Required) Thread objects, thread synchronization objects and thread-specific storage pointers shall have appropriate storage duration" name="MISRAC2012-RULE_22_13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.2 (Required) The initializer for an aggregate or union shall be enclosed in braces" name="MISRAC2012-RULE_9_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.5 (Mandatory) The sizeof operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" name="MISRAC2012-RULE_12_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.12 (Mandatory) Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions" name="MISRAC2012-RULE_22_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.3 (Required) Arrays shall not be partially initialized" name="MISRAC2012-RULE_9_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.6 (Required) Structure and union members of atomic objects shall not be directly accessed" name="MISRAC2012-RULE_12_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.11 (Required) A thread that was previously either joined or detached shall not be subsequently joined nor detached" name="MISRAC2012-RULE_22_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.10 (Required) The value of errno shall only be tested when the last function to be called was an errno-setting-function" name="MISRAC2012-RULE_22_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6 (Required) An initializer using chained designators shall not contain initializers without designators" name="MISRAC2012-RULE_9_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.7 (Mandatory) Atomic objects shall be appropriately initialized before being accessed" name="MISRAC2012-RULE_9_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.9 (Advisory) A function should be used in preference to a function-like macro where they are interchangeable" name="MISRAC2012-DIR_4_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.8 (Advisory) If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" name="MISRAC2012-DIR_4_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.5 (Advisory) Identifiers in the same name space with overlapping visibility should be typographically unambiguous" name="MISRAC2012-DIR_4_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.19 (Required) A condition variable shall be associated with at most one mutex object" name="MISRAC2012-RULE_22_19" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.4 (Advisory) Sections of code should not be &quot;commented out&quot;" name="MISRAC2012-DIR_4_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.18 (Required) Non-recursive mutexes shall not be recursively locked" name="MISRAC2012-RULE_22_18" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.7 (Required) If a function returns error information, then that error information shall be tested" name="MISRAC2012-DIR_4_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.17 (Required) No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for a mutex it has not locked before" name="MISRAC2012-RULE_22_17" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.6 (Advisory) typedefs that indicate size and signedness should be used in place of the basic numerical types" name="MISRAC2012-DIR_4_6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.16 (Required) All mutex objects locked by a thread shall be explicitly unlocked by the same thread" name="MISRAC2012-RULE_22_16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.1 (Required) Run-time failures shall be minimized" name="MISRAC2012-DIR_4_1" total="13">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.12 (Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" name="MISRAC2012-RULE_8_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.13 (Advisory) A pointer should point to a const-qualified type whenever possible" name="MISRAC2012-RULE_8_13" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.3 (Required) Assembly language shall be encapsulated and isolated" name="MISRAC2012-DIR_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.14 (Required) The restrict type qualifier shall not be used" name="MISRAC2012-RULE_8_14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 4.2 (Advisory) All usage of assembly language should be documented" name="MISRAC2012-DIR_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.15 (Required) All declarations of an object with an explicit alignment specification shall specify the same alignment" name="MISRAC2012-RULE_8_15" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 1.1 (Required) The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits" name="MISRAC2012-RULE_1_1" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.10 (Required) An inline function shall be declared with the static storage class" name="MISRAC2012-RULE_8_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.11 (Advisory) When an array with external linkage is declared, its size should be explicitly specified" name="MISRAC2012-RULE_8_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 1.4 (Required) Emergent language features shall not be used" name="MISRAC2012-RULE_1_4" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 1.5 (Required) Obsolescent language features shall not be used" name="MISRAC2012-RULE_1_5" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 1.3 (Required) There shall be no occurrence of undefined or critical unspecified behaviour" name="MISRAC2012-RULE_1_3" total="15">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.16 (Advisory) The alignment specification of zero should not appear in an object declaration" name="MISRAC2012-RULE_8_16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.17 (Advisory) At most one explicit alignment specifier should appear in an object declaration" name="MISRAC2012-RULE_8_17" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.1 (Mandatory) The value of an object with automatic storage duration shall not be read before it has been set" name="MISRAC2012-RULE_9_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.1 (Advisory) The precedence of operators within expressions should be made explicit" name="MISRAC2012-RULE_12_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.10 (Required) A function declared with a _Noreturn function specifier shall have void return type" name="MISRAC2012-RULE_17_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.2 (Required) A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression" name="MISRAC2012-RULE_23_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.11 (Advisory) A function that never returns should be declared with a _Noreturn function specifier" name="MISRAC2012-RULE_17_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.3 (Advisory) A generic selection should contain at least one non-default association" name="MISRAC2012-RULE_23_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.12 (Advisory) A function identifier should only be used with either a preceding &amp;, or with a parenthesised parameter list" name="MISRAC2012-RULE_17_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.4 (Required) A generic association shall list an appropriate type" name="MISRAC2012-RULE_23_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.13 (Required) A function type shall not be type qualified" name="MISRAC2012-RULE_17_13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.5 (Advisory) A generic selection should not depend on implicit pointer type conversion" name="MISRAC2012-RULE_23_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.6 (Required) The controlling expression of a generic selection shall have an essential type that matches its standard type" name="MISRAC2012-RULE_23_6" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.7 (Advisory) A generic selection that is expanded from a macro should evaluate its argument only once" name="MISRAC2012-RULE_23_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.20 (Mandatory) Thread-specific storage pointers shall be created before being accessed" name="MISRAC2012-RULE_22_20" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.8 (Required) A default association shall appear as either the first or the last association of a generic selection" name="MISRAC2012-RULE_23_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.1 (Advisory) A generic selection should only be expanded from a macro" name="MISRAC2012-RULE_23_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.13 (Required) A line whose first token is # shall be a valid preprocessing directive" name="MISRAC2012-RULE_20_13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.12 (Required) A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" name="MISRAC2012-RULE_20_12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1 (Advisory) The goto statement should not be used" name="MISRAC2012-RULE_15_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.11 (Required) A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" name="MISRAC2012-RULE_20_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.2 (Required) The goto statement shall jump to a label declared later in the same function" name="MISRAC2012-RULE_15_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.10 (Advisory) The # and ## preprocessor operators should not be used" name="MISRAC2012-RULE_20_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.3 (Required) Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement" name="MISRAC2012-RULE_15_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.4 (Advisory) There should be no more than one break or goto statement used to terminate any iteration statement" name="MISRAC2012-RULE_15_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.5 (Advisory) A function should have a single point of exit at the end" name="MISRAC2012-RULE_15_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.6 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement" name="MISRAC2012-RULE_15_6" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.7 (Required) All if ... else if constructs shall be terminated with an else statement" name="MISRAC2012-RULE_15_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.14 (Required) All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" name="MISRAC2012-RULE_20_14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 4.1 (Required) Octal and hexadecimal escape sequences shall be terminated" name="MISRAC2012-RULE_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 4.2 (Advisory) Trigraphs should not be used" name="MISRAC2012-RULE_4_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 14.1 (Required) A loop counter shall not have essentially floating type" name="MISRAC2012-RULE_14_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 14.2 (Required) A for loop shall be well-formed" name="MISRAC2012-RULE_14_2" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 14.3 (Required) Controlling expressions shall not be invariant" name="MISRAC2012-RULE_14_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 14.4 (Required) The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" name="MISRAC2012-RULE_14_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 3.2 (Required) Line-splicing shall not be used in // comments" name="MISRAC2012-RULE_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 3.1 (Required) The character sequences /* and // shall not be used within a comment" name="MISRAC2012-RULE_3_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.14 (Required) The Standard Library function memcmp shall not be used to compare null terminated strings" name="MISRAC2012-RULE_21_14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.13 (Mandatory) Any value passed to a function in &lt;ctype.h> shall be representable as an unsigned char or be the value EOF" name="MISRAC2012-RULE_21_13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.12 (Required) The standard header file &lt;fenv.h> shall not be used" name="MISRAC2012-RULE_21_12" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.11 (Required) The standard header file &lt;tgmath.h> shall not be used" name="MISRAC2012-RULE_21_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.10 (Required) The Standard Library time and date functions shall not be used" name="MISRAC2012-RULE_21_10" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.19 (Mandatory) The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type" name="MISRAC2012-RULE_21_19" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.18 (Mandatory) The size_t argument passed to any function in &lt;string.h> shall have an appropriate value" name="MISRAC2012-RULE_21_18" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.17 (Mandatory) Use of the string handling functions from &lt;string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters" name="MISRAC2012-RULE_21_17" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.16 (Required) The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" name="MISRAC2012-RULE_21_16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.15 (Required) The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types" name="MISRAC2012-RULE_21_15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.1 (Required) The features of &lt;stdarg.h> shall not be used" name="MISRAC2012-RULE_17_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.2 (Required) Functions shall not call themselves, either directly or indirectly" name="MISRAC2012-RULE_17_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.3 (Mandatory) A function shall not be declared implicitly" name="MISRAC2012-RULE_17_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.4 (Mandatory) All exit paths from a function with non-void return type shall have an explicit return statement with an expression" name="MISRAC2012-RULE_17_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.5 (Required) The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" name="MISRAC2012-RULE_17_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.6 (Mandatory) The declaration of an array parameter shall not contain the static keyword between the [ ]" name="MISRAC2012-RULE_17_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.7 (Required) The value returned by a function having non-void return type shall be used" name="MISRAC2012-RULE_17_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.8 (Advisory) A function parameter should not be modified" name="MISRAC2012-RULE_17_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.9 (Mandatory) A function declared with a _Noreturn function specifier shall not return to its caller" name="MISRAC2012-RULE_17_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.3 (Required) A bit field shall not be declared as a member of a union" name="MISRAC2012-RULE_6_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.1 (Required) Bit-fields shall only be declared with an appropriate type" name="MISRAC2012-RULE_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.2 (Required) Single-bit named bit fields shall not be of a signed type" name="MISRAC2012-RULE_6_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.5 (Advisory) #undef should not be used" name="MISRAC2012-RULE_20_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.6 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument" name="MISRAC2012-RULE_20_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.7 (Required) Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses" name="MISRAC2012-RULE_20_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.8 (Required) The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" name="MISRAC2012-RULE_20_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.9 (Required) All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" name="MISRAC2012-RULE_20_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.1 (Advisory) #include directives should only be preceded by preprocessor directives or comments" name="MISRAC2012-RULE_20_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.2 (Required) The ', &quot; or \ characters and the /* or // character sequences shall not occur in a header file name" name="MISRAC2012-RULE_20_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.3 (Required) The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" name="MISRAC2012-RULE_20_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 20.4 (Required) A macro shall not be defined with the same name as a keyword" name="MISRAC2012-RULE_20_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.8 (Required) Identifiers that define objects or functions with external linkage shall be unique" name="MISRAC2012-RULE_5_8" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.9 (Advisory) Identifiers that define objects or functions with internal linkage should be unique" name="MISRAC2012-RULE_5_9" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.6 (Required) A typedef name shall be a unique identifier" name="MISRAC2012-RULE_5_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.1 (Required) All switch statements shall be well-formed" name="MISRAC2012-RULE_16_1" total="8">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.7 (Required) A tag name shall be a unique identifier" name="MISRAC2012-RULE_5_7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.2 (Required) A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" name="MISRAC2012-RULE_16_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.3 (Required) An unconditional break statement shall terminate every switch-clause" name="MISRAC2012-RULE_16_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.4 (Required) Every switch statement shall have a default label" name="MISRAC2012-RULE_16_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.5 (Required) A default label shall appear as either the first or the last switch label of a switch statement" name="MISRAC2012-RULE_16_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.6 (Required) Every switch statement shall have at least two switch-clauses" name="MISRAC2012-RULE_16_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.7 (Required) A switch-expression shall not have essentially Boolean type" name="MISRAC2012-RULE_16_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.1 (Required) External identifiers shall be distinct" name="MISRAC2012-RULE_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.4 (Required) Macro identifiers shall be distinct" name="MISRAC2012-RULE_5_4" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.5 (Required) Identifiers shall be distinct from macro names" name="MISRAC2012-RULE_5_5" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.2 (Required) Identifiers declared in the same scope and name space shall be distinct" name="MISRAC2012-RULE_5_2" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.3 (Required) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" name="MISRAC2012-RULE_5_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="MISRA C++ 2023" name="MISRACPP2023" total="274">
               <Category desc="Rule 4.1.3 (Required) There shall be no occurrence of undefined or critical unspecified behaviour" name="MISRACPP2023-4_1_3" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 4.1.2 (Advisory) Deprecated features should not be used" name="MISRACPP2023-4_1_2" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6.1 (Advisory) The goto statement should not be used" name="MISRACPP2023-9_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6.3 (Required) The goto statement shall jump to a label declared later in the function body" name="MISRACPP2023-9_6_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 28.3.1 (Required) Predicates shall not have persistent side effects" name="MISRACPP2023-28_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6.2 (Required) A goto statement shall reference a label in a surrounding block" name="MISRACPP2023-9_6_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6.5 (Required) A function with non-void return type shall return a value on all paths" name="MISRACPP2023-9_6_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.10.1 (Required) User-defined identifiers shall have an appropriate form" name="MISRACPP2023-5_10_1" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.6.4 (Required) A function declared with the [[noreturn]] attribute shall not return" name="MISRACPP2023-9_6_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.2.3 (Advisory) Types with limited visibility should be used at least once" name="MISRACPP2023-0_2_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.2.4 (Advisory) Functions with limited visibility should be used at least once" name="MISRACPP2023-0_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.4.1 (Required) The literal value zero shall be the only value assigned to errno" name="MISRACPP2023-22_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.2.1 (Required) An explicit type conversion shall not be an expression statement" name="MISRACPP2023-9_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.3.2 (Advisory) The declaration of an object should contain no more than two levels of pointer indirection" name="MISRACPP2023-11_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.3.1 (Advisory) Variables of array type should not be declared" name="MISRACPP2023-11_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.2.1 (Advisory) Variables with limited visibility should be used at least once" name="MISRACPP2023-0_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.3.2 (Required) An exception of class type shall be caught by const reference or reference" name="MISRACPP2023-18_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.2.2 (Required) A named function parameter shall be used at least once" name="MISRACPP2023-0_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.3.1 (Advisory) There should be at least one exception handler to catch all otherwise unhandled exceptions" name="MISRACPP2023-18_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.3.3 (Required) Handlers for a function-try-block of a constructor or destructor shall not refer to non-static members from their class or its bases" name="MISRACPP2023-18_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.1.2 (Required) The volatile qualifier shall be used appropriately" name="MISRACPP2023-10_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.1.3 (Required) All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be defined prior to evaluation" name="MISRACPP2023-19_1_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.20.1 (Advisory) An unsigned arithmetic operation with constant operands should not wrap" name="MISRACPP2023-8_20_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.1.1 (Advisory) The target type of a pointer or lvalue reference parameter should be const-qualified appropriately" name="MISRACPP2023-10_1_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.1.2 (Required) All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" name="MISRACPP2023-19_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.1.1 (Required) The defined preprocessor operator shall be used appropriately" name="MISRACPP2023-19_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.0.1 (Advisory) Parentheses should be used to make the meaning of an expression appropriately explicit" name="MISRACPP2023-8_0_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 30.0.2 (Required) Reads and writes on the same file stream shall be separated by a positioning operation" name="MISRACPP2023-30_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.9.2 (Advisory) The names of the standard signed integer types and standard unsigned integer types should not be used" name="MISRACPP2023-6_9_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.9.1 (Required) The same type aliases shall be used in all declarations of the same entity" name="MISRACPP2023-6_9_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.5.2 (Advisory) Internal linkage should be specified appropriately" name="MISRACPP2023-6_5_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 5.7.2 (Advisory) Sections of code should not be &quot;commented out&quot;" name="MISRACPP2023-5_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.5.1 (Advisory) A function or object with external linkage should be introduced in a header file" name="MISRACPP2023-6_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.7.1 (Required) The character sequence /* shall not be used within a C-style comment" name="MISRACPP2023-5_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.7.3 (Required) Line-splicing shall not be used in // comments" name="MISRACPP2023-5_7_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 30.0.1 (Required) The C Library input/output functions shall not be used" name="MISRACPP2023-30_0_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.11 (Required) An argument passed via ellipsis shall have an appropriate type" name="MISRACPP2023-8_2_11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.10 (Required) Functions shall not call themselves, either directly or indirectly" name="MISRACPP2023-8_2_10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.10.1 (Required) The features of &lt;cstdarg> shall not be used" name="MISRACPP2023-21_10_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 28.6.1 (Required) The argument to std::move shall be a non-const lvalue" name="MISRACPP2023-28_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.10.2 (Required) The standard header file &lt;csetjmp> shall not be used" name="MISRACPP2023-21_10_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 28.6.2 (Required) Forwarding references and std::forward shall be used together" name="MISRACPP2023-28_6_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.5.2 (Required) A for-range-initializer shall contain at most one function call" name="MISRACPP2023-9_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.18.1 (Mandatory) An object or subobject must not be copied to an overlapping object" name="MISRACPP2023-8_18_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.5.1 (Advisory) Legacy for statements should be simple" name="MISRACPP2023-9_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1.5 (Required) A class shall only define an initializer-list constructor when it is the only constructor" name="MISRACPP2023-15_1_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1.4 (Advisory) All direct, non-static data members of a class should be initialized before the class object is accessible" name="MISRACPP2023-15_1_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 4.6.1 (Required) Operations on a memory location shall be sequenced appropriately" name="MISRACPP2023-4_6_1" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1.3 (Required) Conversion operators and constructors that are callable with a single argument shall be explicit" name="MISRACPP2023-15_1_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.10.3 (Required) The facilities provided by the standard header file &lt;csignal> shall not be used" name="MISRACPP2023-21_10_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1.2 (Advisory) All constructors of a class should explicitly initialize all of its virtual base classes and immediate base classes" name="MISRACPP2023-15_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.14.1 (Advisory) The right-hand operand of a logical &amp;&amp; or || operator should not contain persistent side effects" name="MISRACPP2023-8_14_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 24.5.2 (Required) The C++ Standard Library functions memcpy, memmove and memcmp from &lt;cstring> shall not be used" name="MISRACPP2023-24_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.18.2 (Advisory) The result of an assignment operator should not be used" name="MISRACPP2023-8_18_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 28.6.3 (Required) An object shall not be used while in a potentially moved-from state" name="MISRACPP2023-28_6_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 24.5.1 (Required) The character handling functions from &lt;cctype> and &lt;cwctype> shall not be used" name="MISRACPP2023-24_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 28.6.4 (Required) The result of std::remove, std::remove_if, std::unique and empty shall be used" name="MISRACPP2023-28_6_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.7.1 (Required) Pointer arithmetic shall not form an invalid pointer" name="MISRACPP2023-8_7_1" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.3.2 (Advisory) The built-in unary + operator should not be used" name="MISRACPP2023-8_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.1.2 (Required) The value returned by a function shall be used" name="MISRACPP2023-0_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.4.1 (Required) Exception-unfriendly functions shall be noexcept" name="MISRACPP2023-18_4_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.1.1 (Advisory) A value should not be unnecessarily written to a local object" name="MISRACPP2023-0_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.6.1 (Advisory) The #pragma directive and the _Pragma operator should not be used" name="MISRACPP2023-19_6_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.7.2 (Required) Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="MISRACPP2023-8_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.1.1 (Required) An object's dynamic type shall not be used from within its constructor or destructor" name="MISRACPP2023-15_1_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.2.3 (Required) The ' or &quot; or \ characters and the /* or // character sequences shall not occur in a header file name" name="MISRACPP2023-19_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.2.1 (Required) An enumeration shall be defined with an explicit underlying type" name="MISRACPP2023-10_2_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.2.2 (Required) The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" name="MISRACPP2023-19_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.2.1 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once" name="MISRACPP2023-19_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.2.3 (Required) The numeric value of an unscoped enumeration with no fixed underlying type shall not be used" name="MISRACPP2023-10_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.3.1 (Advisory) The built-in unary - operator should not be applied to an expression of unsigned type" name="MISRACPP2023-8_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.2.2 (Advisory) Unscoped enumerations should not be declared" name="MISRACPP2023-10_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.3.1 (Required) The union keyword shall not be used" name="MISRACPP2023-12_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6.2 (Required) Dynamic memory shall be managed automatically" name="MISRACPP2023-21_6_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6.3 (Required) Advanced memory management shall not be used" name="MISRACPP2023-21_6_3" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.6 (Required) Assignment between numeric types shall be appropriate" name="MISRACPP2023-7_0_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6.4 (Required) If a project defines either a sized or unsized version of a global operator delete, then both shall be defined" name="MISRACPP2023-21_6_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6.5 (Required) A pointer to an incomplete class type shall not be deleted" name="MISRACPP2023-21_6_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.3 (Required) The numerical value of a character shall not be used" name="MISRACPP2023-7_0_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.2 (Required) There shall be no conversion to type bool" name="MISRACPP2023-7_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.5 (Required) Integral promotion and the usual arithmetic conversions shall not change the signedness or the type category of an operand" name="MISRACPP2023-7_0_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.4 (Required) The operands of bitwise operators and shift operators shall be appropriate" name="MISRACPP2023-7_0_4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.0.1 (Required) There shall be no conversion from type bool" name="MISRACPP2023-7_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.0.1 (Advisory) Trigraph-like sequences should not be used" name="MISRACPP2023-5_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.1.2 (Required) An accessible base class shall not be both virtual and non-virtual in the same hierarchy" name="MISRACPP2023-13_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.1.1 (Advisory) Classes should not be inherited virtually" name="MISRACPP2023-13_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.2.1 (Required) The library functions atof, atoi, atol and atoll from &lt;cstdlib> shall not be used" name="MISRACPP2023-21_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.2.4 (Required) A header file shall not contain definitions of functions or objects that are non-inline and have external linkage" name="MISRACPP2023-6_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.2.3 (Required) The source code used to implement an entity shall appear only once" name="MISRACPP2023-6_2_3" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.2.2 (Required) All declarations of a variable or function shall have the same type" name="MISRACPP2023-6_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.6.1 (Advisory) Dynamic memory should not be used" name="MISRACPP2023-21_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.2.1 (Required) The one-definition rule shall not be violated" name="MISRACPP2023-6_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.2.4 (Required) The macro offsetof shall not be used" name="MISRACPP2023-21_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 21.2.3 (Required) The library function system from &lt;cstdlib> shall not be used" name="MISRACPP2023-21_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.4.1 (Required) All if ... else if constructs shall be terminated with an else statement" name="MISRACPP2023-9_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 15.8.1 (Required) User-provided copy assignment operators and move assignment operators shall handle self-assignment" name="MISRACPP2023-15_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.4.2 (Required) The structure of a switch statement shall be appropriate" name="MISRACPP2023-9_4_2" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.19.1 (Advisory) The comma operator should not be used" name="MISRACPP2023-8_19_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.6 (Required) An object with integral, enumerated, or pointer to void type shall not be cast to a pointer type" name="MISRACPP2023-8_2_6" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.5 (Required) reinterpret_cast shall not be used" name="MISRACPP2023-8_2_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.1.2 (Required) An empty throw shall only occur within the compound-statement of a catch handler" name="MISRACPP2023-18_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.4 (Required) Casts shall not be performed between a pointer to function and any other type" name="MISRACPP2023-8_2_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.1.1 (Required) An exception object shall not have pointer type" name="MISRACPP2023-18_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.3 (Required) A cast shall not remove any const or volatile qualification from the type accessed via a pointer or by reference" name="MISRACPP2023-8_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.9 (Required) The operand to typeid shall not be an expression of polymorphic class type" name="MISRACPP2023-8_2_9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.0.1 (Required) A function shall not contain unreachable statements" name="MISRACPP2023-0_0_1" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.5.2 (Advisory) Program-terminating functions should not be used" name="MISRACPP2023-18_5_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.3.5 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument" name="MISRACPP2023-19_3_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.8 (Required) An object pointer type shall not be cast to an integral type other than std::uintptr_t or std::intptr_t" name="MISRACPP2023-8_2_8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 0.0.2 (Advisory) Controlling expressions should not be invariant" name="MISRACPP2023-0_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.5.1 (Advisory) A noexcept function should not attempt to propagate an exception to the calling function" name="MISRACPP2023-18_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.3.4 (Required) Parentheses shall be used to ensure macro arguments are expanded appropriately" name="MISRACPP2023-19_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.7 (Advisory) A cast should not convert a pointer type to an integral type" name="MISRACPP2023-8_2_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.0.2 (Advisory) User-provided copy and move member functions of a class should have appropriate signatures" name="MISRACPP2023-15_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.3.3 (Required) The argument to a mixed-use macro parameter shall not be subject to further expansion" name="MISRACPP2023-19_3_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 15.0.1 (Required) Special member functions shall be provided appropriately" name="MISRACPP2023-15_0_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.3.2 (Required) A macro parameter immediately following a # operator shall not be immediately followed by a ## operator" name="MISRACPP2023-19_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.3.1 (Advisory) The # and ## preprocessor operators should not be used" name="MISRACPP2023-19_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.2 (Required) C-style casts and functional notation casts shall not be used" name="MISRACPP2023-8_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.3.1 (Advisory) There should be no unnamed namespaces in header files" name="MISRACPP2023-10_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.2.1 (Required) A virtual base class shall only be cast to a derived class by means of dynamic_cast" name="MISRACPP2023-8_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.2.1 (Advisory) Bit-fields should not be declared" name="MISRACPP2023-12_2_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.2.3 (Required) A named bit-field with signed integer type shall not have a length of one bit" name="MISRACPP2023-12_2_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 12.2.2 (Required) A bit-field shall have an appropriate type" name="MISRACPP2023-12_2_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.5.2 (Required) The address-of operator shall not be overloaded" name="MISRACPP2023-16_5_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.5.1 (Required) The logical AND and logical OR operators shall not be overloaded" name="MISRACPP2023-16_5_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.7.2 (Required) Global variables shall not be used" name="MISRACPP2023-6_7_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.7.1 (Required) Local variables shall not have static storage duration" name="MISRACPP2023-6_7_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 23.11.1 (Advisory) The raw pointer constructors of std::shared_ptr and std::unique_ptr should not be used" name="MISRACPP2023-23_11_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.1 (Required) Within character literals and non raw-string literals, \ shall only be used to form a defined escape sequence or universal character name" name="MISRACPP2023-5_13_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 9.3.1 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement" name="MISRACPP2023-9_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.3 (Required) Octal constants shall not be used" name="MISRACPP2023-5_13_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.2 (Required) Octal escape sequences, hexadecimal escape sequences and universal character names shall be terminated" name="MISRACPP2023-5_13_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 14.1.1 (Advisory) Non-static data members should be either all private or all public" name="MISRACPP2023-14_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 0.3.2 (Required) A function call shall not violate the function's preconditions" name="MISRACPP2023-0_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.5 (Required) The lowercase form of &quot;L&quot; shall not be used as the first character in a literal suffix" name="MISRACPP2023-5_13_5" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.6.3 (Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" name="MISRACPP2023-11_6_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.4 (Required) Unsigned integer literals shall be appropriately suffixed" name="MISRACPP2023-5_13_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.6.2 (Mandatory) The value of an object must not be read before it has been set" name="MISRACPP2023-11_6_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.7 (Required) String literals with different encoding prefixes shall not be concatenated" name="MISRACPP2023-5_13_7" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 11.6.1 (Advisory) All variables should be initialized" name="MISRACPP2023-11_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 22.3.1 (Required) The assert macro shall not be used with a constant-expression" name="MISRACPP2023-22_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 5.13.6 (Required) An integer-literal of type long long shall not use a single L or l in any suffix" name="MISRACPP2023-5_13_6" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Dir 0.3.1 (Advisory) Floating-point arithmetic should be used appropriately" name="MISRACPP2023-0_3_1" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 18.2.2 (Required) The string handling functions from &lt;cstring>, &lt;cstdlib>, &lt;cwchar> and &lt;cinttypes> shall not be used" name="MISRACPP2023-18_2_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.9.1 (Required) The built-in relational operators >, >=, &lt; and &lt;= shall not be applied to objects of pointer type, except where they point to elements of the same array" name="MISRACPP2023-8_9_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.0.1 (Advisory) A declaration should not declare more than one variable or member variable" name="MISRACPP2023-10_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.0.4 (Advisory) #undef should only be used for macros defined previously in the same file" name="MISRACPP2023-19_0_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.0.3 (Advisory) #include directives should only be preceded by preprocessor directives or comments" name="MISRACPP2023-19_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 10.4.1 (Required) The asm declaration shall not be used" name="MISRACPP2023-10_4_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.0.2 (Required) Function-like macros shall not be defined" name="MISRACPP2023-19_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 19.0.1 (Required) A line whose first token is # shall be a valid preprocessing directive" name="MISRACPP2023-19_0_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.1.2 (Advisory) Variables should be captured explicitly in a non-transient lambda" name="MISRACPP2023-8_1_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 8.1.1 (Required) A non-transient lambda shall not implicitly capture this" name="MISRACPP2023-8_1_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.3.4 (Required) A comparison of a potentially virtual pointer to member function shall only be with nullptr" name="MISRACPP2023-13_3_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.3.3 (Required) The parameters in all declarations or overrides of a function shall either be unnamed or have identical names" name="MISRACPP2023-13_3_3" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.3.2 (Required) Parameters in an overriding virtual function shall not specify different default arguments" name="MISRACPP2023-13_3_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 17.8.1 (Required) Function templates shall not be explicitly specialized" name="MISRACPP2023-17_8_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 26.3.1 (Advisory) std::vector should not be specialized with bool" name="MISRACPP2023-26_3_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.11.3 (Required) A conversion from function type to pointer-to-function type shall only occur in appropriate contexts" name="MISRACPP2023-7_11_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.11.2 (Required) An array passed as a function argument shall not decay to a pointer" name="MISRACPP2023-7_11_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 7.11.1 (Required) nullptr shall be the only form of the null-pointer-constant" name="MISRACPP2023-7_11_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 16.6.1 (Advisory) Symmetrical operators should only be implemented as non-member functions" name="MISRACPP2023-16_6_1" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.8.4 (Advisory) Member functions returning references to their object should be ref-qualified appropriately" name="MISRACPP2023-6_8_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.8.3 (Required) An assignment operator shall not assign the address of an object with automatic storage duration to an object with a greater lifetime" name="MISRACPP2023-6_8_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 13.3.1 (Required) User-declared member functions shall use the virtual, override and final specifiers appropriately" name="MISRACPP2023-13_3_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.8.2 (Mandatory) A function must not return a reference or a pointer to a local variable with automatic storage duration" name="MISRACPP2023-6_8_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.8.1 (Required) An object shall not be accessed outside of its lifetime" name="MISRACPP2023-6_8_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.4.3 (Required) A name that is present in a dependent base shall not be resolved by unqualified lookup" name="MISRACPP2023-6_4_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 25.5.3 (Mandatory) The pointer returned by the C++ Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror must not be used following a subsequent call to the same function" name="MISRACPP2023-25_5_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.4.2 (Required) Derived classes shall not conceal functions that are inherited from their bases" name="MISRACPP2023-6_4_2" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.4.1 (Required) A variable declared in an inner scope shall not hide a variable declared in an outer scope" name="MISRACPP2023-6_4_1" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.0.4 (Required) The identifier main shall not be used for a function other than the global function main" name="MISRACPP2023-6_0_4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.0.3 (Advisory) The only declarations in the global namespace should be main, namespace declarations and extern &quot;C&quot; declarations" name="MISRACPP2023-6_0_3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.0.2 (Advisory) When an array with external linkage is declared, its size should be explicitly specified" name="MISRACPP2023-6_0_2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 6.0.1 (Required) Block scope declarations shall not be visually ambiguous" name="MISRACPP2023-6_0_1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 25.5.1 (Required) The setlocale and std::locale::global functions shall not be called" name="MISRACPP2023-25_5_1" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="Rule 25.5.2 (Mandatory) The pointers returned by the C++ Standard Library functions localeconv, getenv, setlocale or strerror must only be used as if they have pointer to const-qualified type" name="MISRACPP2023-25_5_2" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Memory and Resource Management" name="MRM" total="67">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Naming Conventions" name="NAMING" total="103">
               <Category desc="Hungarian Notation" name="NAMING-HN" total="44">
                  <Stats authTot="53;" total="53"/>
               </Category>
               <Stats authTot="123;" total="123"/>
            </Category>
            <Category desc="Object Oriented" name="OOP" total="62">
               <Stats authTot="4;" total="4"/>
            </Category>
            <Category desc="Optimization" name="OPT" total="49">
               <Stats authTot="5;" total="5"/>
            </Category>
            <Category desc="OWASP Top 10 Most Critical Web Application Security Risks (2017)" name="OWASP2017" total="16">
               <Category desc="OWASP A3 Sensitive Data Exposure" name="OWASP2017-A3" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A2 Broken Authentication" name="OWASP2017-A2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A1 Injection" name="OWASP2017-A1" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A10 Insufficient Logging&amp;Monitoring" name="OWASP2017-A10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A6 Security Misconfiguration" name="OWASP2017-A6" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A5 Broken Access Control" name="OWASP2017-A5" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A4 XML External Entities (XXE)" name="OWASP2017-A4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="OWASP API Security Top 10 (2019)" name="OWASP2019" total="42">
               <Category desc="OWASP API2 Broken User Authentication" name="OWASP2019-API2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API4 Lack of Resources &amp; Rate Limiting" name="OWASP2019-API4" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API3 Excessive Data Exposure" name="OWASP2019-API3" total="17">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API10 Insufficient Logging &amp; Monitoring" name="OWASP2019-API10" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API9 Improper Assets Management" name="OWASP2019-API9" total="7">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API8 Injection" name="OWASP2019-API8" total="10">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP API7 Security Misconfiguration" name="OWASP2019-API7" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="OWASP Top 10 Most Critical Web Application Security Risks (2021)" name="OWASP2021" total="18">
               <Category desc="OWASP A8 Software and Data Integrity Failures" name="OWASP2021-A8" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A7 Identification and Authentication Failures" name="OWASP2021-A7" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A5 Security Misconfiguration" name="OWASP2021-A5" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A9 Security Logging and Monitoring Failures" name="OWASP2021-A9" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A4 Insecure Design" name="OWASP2021-A4" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A3 Injection" name="OWASP2021-A3" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A2 Cryptographic Failures" name="OWASP2021-A2" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="OWASP A1 Broken Access Control" name="OWASP2021-A1" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Parser diagnostics" name="PARSER" total="2">
               <Stats authTot="9;" total="9"/>
            </Category>
            <Category desc="Possible Bugs" name="PB" total="88">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Physical File Organization" name="PFO" total="10">
               <Stats authTot="8;" total="8"/>
            </Category>
            <Category desc="Portability" name="PORT" total="40">
               <Stats authTot="15;" total="15"/>
            </Category>
            <Category desc="Preprocessor" name="PREPROC" total="33">
               <Stats authTot="74;" total="74"/>
            </Category>
            <Category desc="Qt Best Practices" name="QT" total="18">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="Security" name="SECURITY" total="56">
               <Stats authTot="0;" total="0"/>
            </Category>
            <Category desc="STL Best Practices" name="STL" total="42">
               <Stats authTot="3;" total="3"/>
            </Category>
            <Category desc="Template" name="TEMPL" total="19">
               <Stats authTot="0;" total="0"/>
            </Category>
         </CategoriesList>
         <SeverityList>
            <Severity id="1">
               <Stats authTot="6;" total="6"/>
            </Severity>
            <Severity id="2">
               <Stats authTot="364;" total="364"/>
            </Severity>
            <Severity id="3">
               <Stats authTot="851;" total="851"/>
            </Severity>
            <Severity id="4">
               <Stats authTot="338;" total="338"/>
            </Severity>
            <Severity id="5">
               <Stats authTot="222;" total="222"/>
            </Severity>
         </SeverityList>
      </Rules>
      
	<StdViols>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'DeadLock.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'DeadLock.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'DeadLock.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'DeadLock.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Shapes.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="PREPROC-09" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Shapes.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="JSF-033" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implementation file 'DeadLock.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" sev="5" auth="liwbo" rule="PFO-04" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implementation file 'DeadLock.cpp' should have the file name extension &quot;.cc&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-38" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Shapes.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="JSF-032" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Shapes.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="PREPROC-08" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The filename 'DeadLock.cpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="3" sev="3" auth="liwbo" rule="PREPROC-10_c" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="3" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_e" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #if preprocessor directive is used" ln="3" sev="3" auth="liwbo" rule="PREPROC-11_b" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #if preprocessor directive is used" ln="3" sev="2" auth="liwbo" rule="JSF-026_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD'" ln="7" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD'" ln="7" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="7" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="7" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="7" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD' is enclosed in braces" ln="7" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD_RETURN_TYPE'" ln="8" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD_RETURN_TYPE'" ln="8" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="8" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="8" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="8" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD_RETURN_TYPE' is enclosed in braces" ln="8" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'THREAD_CREATE' is defined without parentheses" ln="9" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="9" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="9" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="9" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="9" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="9" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: THREAD_CREATE" ln="9" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="9" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="9" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="9" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'func' should be enclosed in parentheses" ln="9" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="64" locEndLn="9" locEndPos="65" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'func' should be enclosed in parentheses" ln="9" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="64" locEndLn="9" locEndPos="65" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'thread' should be enclosed in parentheses" ln="9" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="36" locEndLn="9" locEndPos="37" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'thread' should be enclosed in parentheses" ln="9" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="36" locEndLn="9" locEndPos="37" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD_CREATE' is enclosed in braces" ln="9" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'LOCK'" ln="11" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'LOCK'" ln="11" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="11" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="11" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="11" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK' is enclosed in braces" ln="11" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'LOCK_ACQUIRE' is defined without parentheses" ln="12" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="12" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="12" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="12" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="12" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="12" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: LOCK_ACQUIRE" ln="12" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="12" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="12" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="12" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="12" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="49" locEndLn="12" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="12" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="49" locEndLn="12" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK_ACQUIRE' is enclosed in braces" ln="12" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'LOCK_RELEASE' is defined without parentheses" ln="13" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="13" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="13" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="13" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="13" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="13" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: LOCK_RELEASE" ln="13" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="13" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="13" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="13" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="13" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="49" locEndLn="13" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="13" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="49" locEndLn="13" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK_RELEASE' is enclosed in braces" ln="13" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'SLEEP' is defined without parentheses" ln="15" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="15" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="15" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="15" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="15" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="15" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: SLEEP" ln="15" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="15" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="15" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="15" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'SLEEP' is enclosed in braces" ln="15" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="17" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_c" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="17" locStartPos="0" locEndLn="17" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="17" sev="2" auth="liwbo" rule="JSF-026" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="17" locStartPos="0" locEndLn="17" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="17" sev="3" auth="liwbo" rule="PREPROC-11" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="17" locStartPos="0" locEndLn="17" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="19" sev="3" auth="liwbo" rule="PREPROC-10_c" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="19" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_e" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Line contains more than 120 characters: 302" ln="19" sev="3" auth="liwbo" rule="JSF-041" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Line contains more than 120 characters: 302" ln="19" sev="3" auth="liwbo" rule="METRICS-26" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Line has over 79 characters" ln="19" sev="3" auth="liwbo" rule="FORMAT-04" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #if preprocessor directive is used" ln="19" sev="3" auth="liwbo" rule="PREPROC-11_b" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #if preprocessor directive is used" ln="19" sev="2" auth="liwbo" rule="JSF-026_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#else pre-processor directive should not be used" ln="24" sev="3" auth="liwbo" rule="PREPROC-26" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="24" locStartPos="0" locEndLn="24" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="24" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_c" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="24" locStartPos="0" locEndLn="24" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="24" sev="2" auth="liwbo" rule="JSF-026" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="24" locStartPos="0" locEndLn="24" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The #else preprocessor directive is used" ln="24" sev="3" auth="liwbo" rule="PREPROC-11" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="24" locStartPos="0" locEndLn="24" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="30" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="30" locStartPos="0" locEndLn="30" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="30" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="30" locStartPos="0" locEndLn="30" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="30" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="30" locStartPos="0" locEndLn="30" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="30" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="30" locStartPos="0" locEndLn="30" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="35" locStartPos="0" locEndLn="35" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="35" locStartPos="0" locEndLn="35" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="35" locStartPos="0" locEndLn="35" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="35" locStartPos="0" locEndLn="35" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="37" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="37" locStartPos="0" locEndLn="37" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="37" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="37" locStartPos="0" locEndLn="37" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="37" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="37" locStartPos="0" locEndLn="37" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="37" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="37" locStartPos="0" locEndLn="37" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="39" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="39" locStartPos="11" locEndLn="39" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="39" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="39" locStartPos="11" locEndLn="39" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="39" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="39" locStartPos="11" locEndLn="39" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="39" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="39" locStartPos="11" locEndLn="39" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="41" sev="3" auth="liwbo" rule="PREPROC-10_b" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="41" locStartPos="0" locEndLn="41" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="41" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_d" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="41" locStartPos="0" locEndLn="41" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="41" sev="3" auth="liwbo" rule="JSF-028_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="41" locStartPos="0" locEndLn="41" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="41" sev="3" auth="liwbo" rule="PREPROC-26" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="41" locStartPos="0" locEndLn="41" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD'" ln="43" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD'" ln="43" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="43" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="43" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD'" ln="43" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD' is enclosed in braces" ln="43" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="43" locStartPos="0" locEndLn="43" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'THREAD_RETURN_TYPE' part of statement" ln="44" sev="4" auth="liwbo" rule="PREPROC-04" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD_RETURN_TYPE'" ln="44" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'THREAD_RETURN_TYPE'" ln="44" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="44" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="44" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_RETURN_TYPE'" ln="44" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD_RETURN_TYPE' is enclosed in braces" ln="44" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="44" locStartPos="0" locEndLn="44" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'THREAD_CREATE' is defined without parentheses" ln="45" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="45" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="45" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="45" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="45" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: THREAD_CREATE" ln="45" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: THREAD_CREATE" ln="45" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="45" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="45" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'THREAD_CREATE'" ln="45" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'func' should be enclosed in parentheses" ln="45" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="64" locEndLn="45" locEndPos="65" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'func' should be enclosed in parentheses" ln="45" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="64" locEndLn="45" locEndPos="65" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'thread' should be enclosed in parentheses" ln="45" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="52" locEndLn="45" locEndPos="53" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'thread' should be enclosed in parentheses" ln="45" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="52" locEndLn="45" locEndPos="53" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'THREAD_CREATE' is enclosed in braces" ln="45" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="45" locStartPos="0" locEndLn="45" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'LOCK'" ln="47" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'LOCK'" ln="47" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="47" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="47" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK'" ln="47" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK' is enclosed in braces" ln="47" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="47" locStartPos="0" locEndLn="47" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'LOCK_ACQUIRE' is defined without parentheses" ln="48" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="48" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="48" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="48" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="48" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_ACQUIRE" ln="48" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: LOCK_ACQUIRE" ln="48" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="48" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="48" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_ACQUIRE'" ln="48" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="48" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="47" locEndLn="48" locEndPos="48" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="48" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="47" locEndLn="48" locEndPos="48" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK_ACQUIRE' is enclosed in braces" ln="48" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="48" locStartPos="0" locEndLn="48" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'LOCK_RELEASE' is defined without parentheses" ln="49" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="49" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="49" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="49" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="49" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: LOCK_RELEASE" ln="49" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: LOCK_RELEASE" ln="49" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="49" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="49" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'LOCK_RELEASE'" ln="49" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="49" sev="2" auth="liwbo" rule="MISRA2008-16_0_6" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="49" locEndLn="49" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Each instance of parameter: 'lock' should be enclosed in parentheses" ln="49" sev="2" auth="liwbo" rule="MISRA2012-RULE-20_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="49" locEndLn="49" locEndPos="50" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'LOCK_RELEASE' is enclosed in braces" ln="49" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="49" locStartPos="0" locEndLn="49" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Body of macro 'SLEEP' is defined without parentheses" ln="51" sev="3" auth="liwbo" rule="MISRA-096" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="51" sev="2" auth="liwbo" rule="MISRA2008-16_0_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="51" sev="2" auth="liwbo" rule="JSF-029" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="51" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_9" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="51" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define function-like macro: SLEEP" ln="51" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not define the function-like macro: SLEEP" ln="51" sev="3" auth="liwbo" rule="PREPROC-28" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="51" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="51" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'SLEEP'" ln="51" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Not all body of macro 'SLEEP' is enclosed in braces" ln="51" sev="3" auth="liwbo" rule="PREPROC-14" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="51" locStartPos="0" locEndLn="51" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="53" sev="3" auth="liwbo" rule="PREPROC-10_b" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="53" locStartPos="0" locEndLn="53" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="53" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_d" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="53" locStartPos="0" locEndLn="53" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="53" sev="3" auth="liwbo" rule="JSF-028_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="53" locStartPos="0" locEndLn="53" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Define constant 'MAX_OBJECTS' using 'const' or 'enum' instead of '#define'" ln="55" sev="2" auth="liwbo" rule="JSF-030" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'MAX_OBJECTS'" ln="55" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'MAX_OBJECTS'" ln="55" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'MAX_OBJECTS'" ln="55" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'MAX_OBJECTS'" ln="55" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'MAX_OBJECTS'" ln="55" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="55" locStartPos="0" locEndLn="55" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Define constant 'STEP' using 'const' or 'enum' instead of '#define'" ln="56" sev="2" auth="liwbo" rule="JSF-030" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'STEP'" ln="56" sev="2" auth="liwbo" rule="MISRA2008-16_2_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use #define to define constant: 'STEP'" ln="56" sev="3" auth="liwbo" rule="PREPROC-12" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'STEP'" ln="56" sev="3" auth="liwbo" rule="JSF-031" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'STEP'" ln="56" sev="2" auth="liwbo" rule="MISRA2008-16_2_1_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Do not use the macro definition 'STEP'" ln="56" sev="3" auth="liwbo" rule="PREPROC-01" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="56" locStartPos="0" locEndLn="56" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'condition' shall be declared as unsigned int or signed int" ln="58" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="19" locEndLn="58" locEndPos="20" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare parameter 'condition' as const" ln="58" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="19" locEndLn="58" locEndPos="20" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare parameter 'message' as const" ln="58" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="42" locEndLn="58" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'assertion' has Cyclomatic Complexity value: 2" ln="58" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'assertion' has Essential Complexity value: 1" ln="58" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'assertion' has external linkage and is not declared in the header" ln="58" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'assertion' has external linkage and is not declared in the header" ln="58" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'assertion' has external linkage and is not declared in the header" ln="58" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'assertion' is declared in global namespace" ln="58" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'assertion' is declared in global namespace" ln="58" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: assertion" ln="58" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'assertion'" ln="58" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'assertion' function should be preceded by a comment that contains the '@brief' tag" ln="58" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'assertion' function should be preceded by a comment that contains the '@brief' tag" ln="58" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'condition' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="19" locEndLn="58" locEndPos="20" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'condition' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="19" locEndLn="58" locEndPos="20" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'condition' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="19" locEndLn="58" locEndPos="20" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'condition' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="58" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'condition' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="58" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="58" sev="3" auth="liwbo" rule="FORMAT-47_a" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="30" locEndLn="58" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-05" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="42" locEndLn="58" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-09" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="42" locEndLn="58" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-10" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="42" locEndLn="58" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' identifier should have the 'p' prefix" ln="58" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="42" locEndLn="58" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="58" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'message' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="58" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="58" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="36" locEndLn="58" locEndPos="37" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="58" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="36" locEndLn="58" locEndPos="37" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="58" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="15" locEndLn="58" locEndPos="16" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="58" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="15" locEndLn="58" locEndPos="16" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="58" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="15" locEndLn="58" locEndPos="16" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="58" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="15" locEndLn="58" locEndPos="16" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'assertion' function is not preceded by a comment" ln="58" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'assertion' function is not preceded by a comment" ln="58" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="59" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="59" locStartPos="0" locEndLn="59" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="60" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="60" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="60" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="60" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="60" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="60" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="60" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="60" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="0" locEndLn="60" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operand of logical operator '!' has 'int' type instead of 'bool' type" ln="60" sev="2" auth="liwbo" rule="MISRA2008-5_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="60" locStartPos="5" locEndLn="60" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Exception of type 'const char *' is thrown by pointer; throw by value instead" ln="61" sev="4" auth="liwbo" rule="MISRA2008-15_0_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="2" locEndLn="61" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="61" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="0" locEndLn="61" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="61" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="0" locEndLn="61" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="61" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="1" locEndLn="61" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="61" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="1" locEndLn="61" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="c++ exception handling structure is used in function 'assertion'" ln="61" sev="2" auth="liwbo" rule="JSF-208" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="61" locStartPos="2" locEndLn="61" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="62" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="62" locStartPos="0" locEndLn="62" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="62" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="62" locStartPos="0" locEndLn="62" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'changePositionMutex'" ln="65" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'changePositionMutex' is declared" ln="65" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'changePositionMutex' is declared in global namespace" ln="65" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'changePositionMutex' is declared in global namespace" ln="65" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: changePositionMutex" ln="65" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'changePositionMutex' identifier should have the 's' prefix" ln="65" sev="3" auth="liwbo" rule="NAMING-HN-38" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'changePositionMutex' variable should be commented" ln="65" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'changePositionMutex' variable should be commented" ln="65" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'changePositionMutex' should be composed only of lowercase letters" ln="65" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'changePositionMutex' should be composed only of lowercase letters" ln="65" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="65" locStartPos="24" locEndLn="65" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Argument type conversion from &quot;shorter&quot; type to &quot;longer&quot; type" ln="67" sev="3" auth="liwbo" rule="PORT-16" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'ring'" ln="67" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' has external linkage and is not declared in the header" ln="67" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' has external linkage and is not declared in the header" ln="67" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' has external linkage and is not declared in the header" ln="67" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' is declared" ln="67" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' is declared in global namespace" ln="67" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'ring' is declared in global namespace" ln="67" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion from integral to floating type in function's argument" ln="67" sev="2" auth="liwbo" rule="MISRA2008-5_0_5_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="24" locEndLn="67" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: ring" ln="67" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Point' constructor called during the creation of the 'ring' object should be declared as exception-safe" ln="67" sev="2" auth="liwbo" rule="MISRA2008-15_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Point' constructor called during the creation of the 'ring' object should be declared as exception-safe" ln="67" sev="2" auth="liwbo" rule="MISRA2008-15_5_3_f" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'ring' variable should be commented" ln="67" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'ring' variable should be commented" ln="67" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="67" locStartPos="7" locEndLn="67" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'participants'" ln="68" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' has external linkage and is not declared in the header" ln="68" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' has external linkage and is not declared in the header" ln="68" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' has external linkage and is not declared in the header" ln="68" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' is declared" ln="68" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' is declared in global namespace" ln="68" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participants' is declared in global namespace" ln="68" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: participants" ln="68" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participants' array should not be used" ln="68" sev="3" auth="liwbo" rule="STL-37" tool="c++test" cat="STL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participants' identifier should have the 'rg' prefix" ln="68" sev="3" auth="liwbo" rule="NAMING-HN-01" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participants' variable should be commented" ln="68" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participants' variable should be commented" ln="68" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="7" locEndLn="68" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'participants' declaration, should be directly connected with the type" ln="68" sev="3" auth="liwbo" rule="JSF-062" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="6" locEndLn="68" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'participants' declaration, should be directly connected with the type" ln="68" sev="4" auth="liwbo" rule="FORMAT-32" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="68" locStartPos="6" locEndLn="68" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'participantsCount' shall be declared as unsigned int or signed int" ln="69" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'participantsCount'" ln="69" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' has external linkage and is not declared in the header" ln="69" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' has external linkage and is not declared in the header" ln="69" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' has external linkage and is not declared in the header" ln="69" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' is declared" ln="69" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' is declared in global namespace" ln="69" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'participantsCount' is declared in global namespace" ln="69" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: participantsCount" ln="69" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: participantsCount" ln="69" sev="3" auth="liwbo" rule="NAMING-19" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participantsCount' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="69" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participantsCount' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="69" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participantsCount' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="69" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participantsCount' variable should be commented" ln="69" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'participantsCount' variable should be commented" ln="69" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="69" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="0" locEndLn="69" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="69" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="0" locEndLn="69" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="69" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="0" locEndLn="69" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="69" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="0" locEndLn="69" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'participantsCount' should be composed only of lowercase letters" ln="69" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'participantsCount' should be composed only of lowercase letters" ln="69" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The variable &quot;participantsCount&quot; was not initialized when declared" ln="69" sev="2" auth="liwbo" rule="JSF-142_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="69" locStartPos="4" locEndLn="69" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'exitGame' shall be declared as unsigned int or signed int" ln="70" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'exitGame'" ln="70" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' has external linkage and is not declared in the header" ln="70" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' has external linkage and is not declared in the header" ln="70" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' has external linkage and is not declared in the header" ln="70" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' is declared" ln="70" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' is declared in global namespace" ln="70" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'exitGame' is declared in global namespace" ln="70" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: exitGame" ln="70" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: exitGame" ln="70" sev="3" auth="liwbo" rule="NAMING-19" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'exitGame' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="70" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'exitGame' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="70" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'exitGame' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="70" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'exitGame' variable should be commented" ln="70" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'exitGame' variable should be commented" ln="70" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="70" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="0" locEndLn="70" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="70" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="0" locEndLn="70" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="70" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="0" locEndLn="70" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="70" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="0" locEndLn="70" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'exitGame' should be composed only of lowercase letters" ln="70" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'exitGame' should be composed only of lowercase letters" ln="70" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The variable &quot;exitGame&quot; was not initialized when declared" ln="70" sev="2" auth="liwbo" rule="JSF-142_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="70" locStartPos="4" locEndLn="70" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'GameLogic_Thread' has Cyclomatic Complexity value: 1" ln="72" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'GameLogic_Thread' has Essential Complexity value: 1" ln="72" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'GameLogic_Thread' has external linkage and is not declared in the header" ln="72" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'GameLogic_Thread' has external linkage and is not declared in the header" ln="72" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'GameLogic_Thread' has external linkage and is not declared in the header" ln="72" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'GameLogic_Thread' is declared in global namespace" ln="72" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'GameLogic_Thread' is declared in global namespace" ln="72" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'GameLogic_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="72" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'GameLogic_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="72" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'GameLogic_Thread' function should be preceded by a comment that contains the '@return' tag" ln="72" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'GameLogic_Thread' function should be preceded by a comment that contains the '@return' tag" ln="72" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'GameLogic_Thread' function is not preceded by a comment" ln="72" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'GameLogic_Thread' function is not preceded by a comment" ln="72" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The incorrect global function name GameLogic_Thread was found" ln="72" sev="3" auth="liwbo" rule="NAMING-34" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'GameLogic_Thread' should be composed only of lowercase letters" ln="72" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'GameLogic_Thread' should be composed only of lowercase letters" ln="72" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="72" locStartPos="6" locEndLn="72" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="74" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="74" locStartPos="0" locEndLn="74" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="74" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="74" locStartPos="0" locEndLn="74" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="75" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="1" locEndLn="75" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="C-style cast to 'DWORD' type is used" ln="75" sev="2" auth="liwbo" rule="JSF-185" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="8" locEndLn="75" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="C-style cast to 'DWORD' type is used" ln="75" sev="2" auth="liwbo" rule="MISRA2008-5_2_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="8" locEndLn="75" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Cast to primitive type should not be used if possible" ln="75" sev="4" auth="liwbo" rule="JSF-183" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="8" locEndLn="75" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="75" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="0" locEndLn="75" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="75" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="75" locStartPos="0" locEndLn="75" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Controller_Thread' has Cyclomatic Complexity value: 1" ln="78" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Controller_Thread' has Essential Complexity value: 1" ln="78" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Controller_Thread' has external linkage and is not declared in the header" ln="78" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Controller_Thread' has external linkage and is not declared in the header" ln="78" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Controller_Thread' has external linkage and is not declared in the header" ln="78" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'Controller_Thread' is declared in global namespace" ln="78" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'Controller_Thread' is declared in global namespace" ln="78" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Controller_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="78" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Controller_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="78" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Controller_Thread' function should be preceded by a comment that contains the '@return' tag" ln="78" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Controller_Thread' function should be preceded by a comment that contains the '@return' tag" ln="78" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Controller_Thread' function is not preceded by a comment" ln="78" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Controller_Thread' function is not preceded by a comment" ln="78" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The incorrect global function name Controller_Thread was found" ln="78" sev="3" auth="liwbo" rule="NAMING-34" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Controller_Thread' should be composed only of lowercase letters" ln="78" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Controller_Thread' should be composed only of lowercase letters" ln="78" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="78" locStartPos="6" locEndLn="78" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="80" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="80" locStartPos="0" locEndLn="80" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="80" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="80" locStartPos="0" locEndLn="80" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="81" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="1" locEndLn="81" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="C-style cast to 'DWORD' type is used" ln="81" sev="2" auth="liwbo" rule="JSF-185" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="8" locEndLn="81" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="C-style cast to 'DWORD' type is used" ln="81" sev="2" auth="liwbo" rule="MISRA2008-5_2_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="8" locEndLn="81" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Cast to primitive type should not be used if possible" ln="81" sev="4" auth="liwbo" rule="JSF-183" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="8" locEndLn="81" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="81" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="0" locEndLn="81" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="81" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="81" locStartPos="0" locEndLn="81" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Consider encapsulating 'velocityArray'" ln="86" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'velocityArray' has external linkage and is not declared in the header" ln="86" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'velocityArray' has external linkage and is not declared in the header" ln="86" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'velocityArray' has external linkage and is not declared in the header" ln="86" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'velocityArray' is declared" ln="86" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: velocityArray" ln="86" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="86" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="0" locEndLn="86" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="86" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="0" locEndLn="86" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' array should not be used" ln="86" sev="3" auth="liwbo" rule="STL-37" tool="c++test" cat="STL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' identifier should have the 'rg' prefix" ln="86" sev="3" auth="liwbo" rule="NAMING-HN-01" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' variable has only one use" ln="86" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' variable has only one use" ln="86" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' variable should be commented" ln="86" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'velocityArray' variable should be commented" ln="86" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'velocityArray' should be composed only of lowercase letters" ln="86" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'velocityArray' should be composed only of lowercase letters" ln="86" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="8" locEndLn="86" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'velocityArray' declaration, should be directly connected with the type" ln="86" sev="3" auth="liwbo" rule="JSF-062" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="7" locEndLn="86" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'velocityArray' declaration, should be directly connected with the type" ln="86" sev="4" auth="liwbo" rule="FORMAT-32" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="86" locStartPos="7" locEndLn="86" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Physics_Thread' has Cyclomatic Complexity value: 3" ln="88" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Physics_Thread' has Essential Complexity value: 1" ln="88" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Physics_Thread' has external linkage and is not declared in the header" ln="88" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Physics_Thread' has external linkage and is not declared in the header" ln="88" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Physics_Thread' has external linkage and is not declared in the header" ln="88" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="88" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="0" locEndLn="88" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="88" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="0" locEndLn="88" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Physics_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="88" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Physics_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="88" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Physics_Thread' function should be preceded by a comment that contains the '@return' tag" ln="88" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Physics_Thread' function should be preceded by a comment that contains the '@return' tag" ln="88" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Physics_Thread' function is not preceded by a comment" ln="88" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Physics_Thread' function is not preceded by a comment" ln="88" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The incorrect global function name Physics_Thread was found" ln="88" sev="3" auth="liwbo" rule="NAMING-34" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Physics_Thread' should be composed only of lowercase letters" ln="88" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Physics_Thread' should be composed only of lowercase letters" ln="88" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="88" locStartPos="7" locEndLn="88" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="89" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="89" locStartPos="0" locEndLn="89" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="89" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="89" locStartPos="0" locEndLn="89" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 13" ln="89" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="89" locStartPos="0" locEndLn="89" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="90" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="90" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="90" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="1" locEndLn="90" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="90" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="1" locEndLn="90" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="90" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="90" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="90" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="90" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="90" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="90" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="90" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="The global variable &quot;exitGame&quot; is used without holding a lock" ln="90" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="3" rule="BD-TRS-THRDR" ruleSCSCMsg="The point where the new thread is started" pkg="Physics" tool="c++test" id="832658629" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="91" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType=".C" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <ElDescList>
            <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType=".P" desc="while (!exitGame) {" rngLn="90">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;exitGame&quot; is used without holding a lock" ln="90" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_c" ruleSCSCMsg="The point where the new thread is started" pkg="Physics" tool="c++test" id="1447986063" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="0" locEndLn="91" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType=".C" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <ElDescList>
            <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType=".P" desc="while (!exitGame) {" rngLn="90">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The operand of logical operator '!' has 'int' type instead of 'bool' type" ln="90" sev="2" auth="liwbo" rule="MISRA2008-5_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="90" locStartPos="9" locEndLn="90" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'i' shall be declared as unsigned int or signed int" ln="91" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="11" locEndLn="91" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Between conditional statement 'for' and its opening parenthesis '(' should be exactly one space" ln="91" sev="3" auth="liwbo" rule="FORMAT-12" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="3" locEndLn="91" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="1" locEndLn="91" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="1" locEndLn="91" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="2" locEndLn="91" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="91" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="2" locEndLn="91" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="91" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="91" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="91" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="91" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="91" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="91" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="91" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="91" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="11" locEndLn="91" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="91" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="11" locEndLn="91" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="91" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="7" locEndLn="91" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="91" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="7" locEndLn="91" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="91" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="7" locEndLn="91" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="91" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="7" locEndLn="91" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="The global variable &quot;participantsCount&quot; is used without holding a lock" ln="91" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="3" rule="BD-TRS-THRDR" ruleSCSCMsg="The point where the new thread is started" pkg="Physics" tool="c++test" id="918588768" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="92" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType=".C" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <ElDescList>
            <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType=".P" desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;participantsCount&quot; is used without holding a lock" ln="91" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_c" ruleSCSCMsg="The point where the new thread is started" pkg="Physics" tool="c++test" id="1362055722" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="91" locStartPos="0" locEndLn="92" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType=".C" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <ElDescList>
            <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType=".P" desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="92" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="0" locEndLn="92" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="0" locEndLn="92" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="1" locEndLn="92" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="1" locEndLn="92" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="2" locEndLn="92" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="2" locEndLn="92" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="3" locEndLn="92" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="92" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="92" locStartPos="3" locEndLn="92" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="&quot;participants&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="93" ruleSAFMsg="Usage of &quot;participants&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;participants&quot; in first critical section" pkg="Physics" tool="c++test" id="1204301482" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="0" locEndLn="94" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="93" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="94" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType=".C" desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType=".P" desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;participants&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="93" ruleSAFMsg="Usage of &quot;participants&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;participants&quot; in first critical section" pkg="Physics" tool="c++test" id="591699974" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="0" locEndLn="94" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="93" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="94" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType=".C" desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType=".P" desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="93" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="0" locEndLn="93" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="0" locEndLn="93" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="1" locEndLn="93" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="1" locEndLn="93" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="2" locEndLn="93" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="2" locEndLn="93" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="3" locEndLn="93" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="93" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="3" locEndLn="93" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'position' variable should be commented" ln="93" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="11" locEndLn="93" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'position' variable should be commented" ln="93" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="93" locStartPos="11" locEndLn="93" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="&quot;velocityArray&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="94" ruleSAFMsg="Usage of &quot;velocityArray&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;velocityArray&quot; in first critical section" pkg="Physics" tool="c++test" id="407642474" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="0" locEndLn="95" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="94" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="95" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType=".C" desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;velocityArray&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType=".P" desc="position.translate(*velocityArray[i]);" rngLn="94">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;velocityArray&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;velocityArray&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="94" ruleSAFMsg="Usage of &quot;velocityArray&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;velocityArray&quot; in first critical section" pkg="Physics" tool="c++test" id="2093002694" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="0" locEndLn="95" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="94" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="95" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType=".C" desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;velocityArray&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType=".P" desc="position.translate(*velocityArray[i]);" rngLn="94">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;velocityArray&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="94" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="0" locEndLn="94" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="0" locEndLn="94" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="1" locEndLn="94" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="1" locEndLn="94" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="2" locEndLn="94" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="2" locEndLn="94" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="3" locEndLn="94" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="94" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="94" locStartPos="3" locEndLn="94" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="&quot;ring&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="95" ruleSAFMsg="Usage of &quot;ring&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;ring&quot; in first critical section" pkg="Physics" tool="c++test" id="-905541933" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="0" locEndLn="96" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="95" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="96" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType=".C" desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType=".P" desc="ring.contains(...)" rngLn="95">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;ring&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="95" ruleSAFMsg="Usage of &quot;ring&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;ring&quot; in first critical section" pkg="Physics" tool="c++test" id="-1366685569" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="0" locEndLn="96" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="95" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="96" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType=".C" desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="98" srcRngStartPos="0" srcRngEndLn="99" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="98" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="98">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType=".P" desc="ring.contains(...)" rngLn="95">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="95" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="0" locEndLn="95" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="0" locEndLn="95" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="1" locEndLn="95" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="1" locEndLn="95" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="2" locEndLn="95" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="2" locEndLn="95" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="3" locEndLn="95" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="95" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="95" locStartPos="3" locEndLn="95" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="0" locEndLn="96" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="0" locEndLn="96" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="1" locEndLn="96" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="1" locEndLn="96" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="2" locEndLn="96" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="2" locEndLn="96" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="3" locEndLn="96" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="3" locEndLn="96" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="4" locEndLn="96" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="4" locEndLn="96" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="5" locEndLn="96" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="5" locEndLn="96" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="6" locEndLn="96" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="6" locEndLn="96" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="7" locEndLn="96" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="7" locEndLn="96" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="8" locEndLn="96" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="8" locEndLn="96" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="9" locEndLn="96" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="9" locEndLn="96" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="10" locEndLn="96" locEndPos="11" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="10" locEndLn="96" locEndPos="11" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="11" locEndLn="96" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="96" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="96" locStartPos="11" locEndLn="96" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="0" locEndLn="97" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="0" locEndLn="97" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="1" locEndLn="97" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="1" locEndLn="97" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="2" locEndLn="97" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="2" locEndLn="97" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="3" locEndLn="97" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="3" locEndLn="97" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="4" locEndLn="97" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="4" locEndLn="97" locEndPos="5" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="5" locEndLn="97" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="5" locEndLn="97" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="6" locEndLn="97" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="6" locEndLn="97" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="7" locEndLn="97" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="7" locEndLn="97" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="8" locEndLn="97" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="8" locEndLn="97" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="9" locEndLn="97" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="9" locEndLn="97" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="10" locEndLn="97" locEndPos="11" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="10" locEndLn="97" locEndPos="11" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="11" locEndLn="97" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="97" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="97" locStartPos="11" locEndLn="97" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="0" locEndLn="98" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="0" locEndLn="98" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="1" locEndLn="98" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="1" locEndLn="98" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="2" locEndLn="98" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="2" locEndLn="98" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="3" locEndLn="98" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="98" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="98" locStartPos="3" locEndLn="98" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="0" locEndLn="99" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="0" locEndLn="99" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="1" locEndLn="99" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="1" locEndLn="99" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="2" locEndLn="99" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="99" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="99" locStartPos="2" locEndLn="99" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="100" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="9" locEndLn="100" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="1" locEndLn="100" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="1" locEndLn="100" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="2" locEndLn="100" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="100" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="100" locStartPos="2" locEndLn="100" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="101" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="101" locStartPos="0" locEndLn="101" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="101" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="101" locStartPos="0" locEndLn="101" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="101" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="101" locStartPos="1" locEndLn="101" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="101" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="101" locStartPos="1" locEndLn="101" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="102" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="2" locEndLn="102" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="A 'U' suffix shall be applied to constant: 0" ln="102" sev="2" auth="liwbo" rule="MISRA2008-2_13_3" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="9" locEndLn="102" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function return statement shall not be used" ln="102" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="2" locEndLn="102" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="102" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="0" locEndLn="102" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="102" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="0" locEndLn="102" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="102" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="1" locEndLn="102" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="102" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="102" locStartPos="1" locEndLn="102" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="103" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="103" locStartPos="0" locEndLn="103" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="103" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="103" locStartPos="0" locEndLn="103" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Unreleased lock: changePositionMutex" ln="103" ruleSAFMsg="Point prior to which the lock is to be released" auth="liwbo" sev="1" rule="BD-TRS-LOCK" ruleSCSCMsg="Point where the lock is acquired" pkg="Physics" tool="c++test" id="-751414771" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="103" locStartPos="0" locEndLn="104" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="92" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="93" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType=".C" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Point where the lock is acquired" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="!E" desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95" thrownTypes="const char *" throwingMethod="assertion">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="61" srcRngStartPos="0" srcRngEndLn="62" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="61" ElType="!E" desc="throw message;" rngLn="61" thrownTypes="throwStatement" throwingMethod="">
              <Props/>
              <Anns>
                <Ann msg="Throws an exception" kind="except"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="assertion() throws const char *" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="103" srcRngStartPos="0" srcRngEndLn="104" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="103" ElType=".P" desc="}" rngLn="103">
          <Props/>
          <Anns>
            <Ann msg="Point prior to which the lock is to be released" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreleased lock: changePositionMutex" ln="103" ruleSAFMsg="Point prior to which the lock is to be released" auth="liwbo" sev="4" rule="MISRA2012-DIR-4_13_d" ruleSCSCMsg="Point where the lock is acquired" pkg="Physics" tool="c++test" id="1112525785" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="103" locStartPos="0" locEndLn="104" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="92" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="93" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType=".C" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Point where the lock is acquired" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="!E" desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95" thrownTypes="const char *" throwingMethod="assertion">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="61" srcRngStartPos="0" srcRngEndLn="62" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="61" ElType="!E" desc="throw message;" rngLn="61" thrownTypes="throwStatement" throwingMethod="">
              <Props/>
              <Anns>
                <Ann msg="Throws an exception" kind="except"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="assertion() throws const char *" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="103" srcRngStartPos="0" srcRngEndLn="104" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="103" ElType=".P" desc="}" rngLn="103">
          <Props/>
          <Anns>
            <Ann msg="Point prior to which the lock is to be released" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreleased lock: changePositionMutex" ln="103" ruleSAFMsg="Point prior to which the lock is to be released" auth="liwbo" sev="2" rule="MISRA2012-RULE-22_16" ruleSCSCMsg="Point where the lock is acquired" pkg="Physics" tool="c++test" id="2070082872" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="103" locStartPos="0" locEndLn="104" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="92" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="93" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="90" srcRngStartPos="0" srcRngEndLn="91" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="90" ElType="." desc="while (!exitGame) {" rngLn="90">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="91" srcRngStartPos="0" srcRngEndLn="92" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="91" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="91">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="92" srcRngStartPos="0" srcRngEndLn="93" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="92" ElType=".C" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="92">
          <Props/>
          <Anns>
            <Ann msg="Point where the lock is acquired" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="93" ElType="." desc="Point&amp; position = participants[i]->getPosition();" rngLn="93">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="94" ElType="." desc="position.translate(*velocityArray[i]);" rngLn="94">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="." desc="ring.contains(...)" rngLn="95">
          <ElDescList>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="getPosition()" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="point.squareDistanceTo(...)" rngLn="29">
              <ElDescList>
                <ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="21" ElType="." desc="return ((_x - point._x) * (_x - point._x)) + ((_y - point._y) * (_y - point._y));" rngLn="21">
                  <Props/>
                </ElDesc>
              </ElDescList>
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="29" srcRngStartPos="0" srcRngEndLn="30" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="29" ElType="." desc="return point.squareDistanceTo(getPosition()) &lt;= (_radius * _radius);" rngLn="29">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="95" srcRngStartPos="0" srcRngEndLn="96" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="95" ElType="!E" desc="assertion(ring.contains(position), &quot;Participant is out of ring&quot;);" rngLn="95" thrownTypes="const char *" throwingMethod="assertion">
          <ElDescList>
            <ElDesc srcRngStartln="60" srcRngStartPos="0" srcRngEndLn="61" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="60" ElType="." desc="if (!condition) {" rngLn="60">
              <Props/>
              <Anns>
                <Ann msg="Condition evaluation: !condition (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="61" srcRngStartPos="0" srcRngEndLn="62" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="61" ElType="!E" desc="throw message;" rngLn="61" thrownTypes="throwStatement" throwingMethod="">
              <Props/>
              <Anns>
                <Ann msg="Throws an exception" kind="except"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="assertion() throws const char *" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="103" srcRngStartPos="0" srcRngEndLn="104" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="103" ElType=".P" desc="}" rngLn="103">
          <Props/>
          <Anns>
            <Ann msg="Point prior to which the lock is to be released" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Consider encapsulating 'currentCameraVelocity'" ln="108" sev="3" auth="liwbo" rule="JSF-207" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'currentCameraVelocity' has external linkage and is not declared in the header" ln="108" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'currentCameraVelocity' has external linkage and is not declared in the header" ln="108" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'currentCameraVelocity' has external linkage and is not declared in the header" ln="108" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global variable 'currentCameraVelocity' is declared" ln="108" sev="5" auth="liwbo" rule="MISRA-022" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: currentCameraVelocity" ln="108" sev="3" auth="liwbo" rule="NAMING-18" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: currentCameraVelocity" ln="108" sev="3" auth="liwbo" rule="NAMING-22" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="108" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="0" locEndLn="108" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="108" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="0" locEndLn="108" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'currentCameraVelocity' identifier should have the 'p' prefix" ln="108" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'currentCameraVelocity' variable should be commented" ln="108" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'currentCameraVelocity' variable should be commented" ln="108" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'currentCameraVelocity' should be composed only of lowercase letters" ln="108" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'currentCameraVelocity' should be composed only of lowercase letters" ln="108" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="8" locEndLn="108" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'currentCameraVelocity' declaration, should be directly connected with the type" ln="108" sev="3" auth="liwbo" rule="JSF-062" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="7" locEndLn="108" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'currentCameraVelocity' declaration, should be directly connected with the type" ln="108" sev="4" auth="liwbo" rule="FORMAT-32" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="108" locStartPos="7" locEndLn="108" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare parameter 'object' as const" ln="110" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="24" locEndLn="110" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' has Cyclomatic Complexity value: 1" ln="110" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' has Essential Complexity value: 1" ln="110" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' has external linkage and is not declared in the header" ln="110" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' has external linkage and is not declared in the header" ln="110" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' has external linkage and is not declared in the header" ln="110" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'draw' is empty" ln="110" sev="2" auth="liwbo" rule="MISRA2008-0_1_8_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: draw" ln="110" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="110" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="0" locEndLn="110" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="110" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="0" locEndLn="110" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Parameter 'object' is not used" ln="110" sev="2" auth="liwbo" rule="MISRA2008-0_1_11" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="24" locEndLn="110" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="R-828: parameter &quot;object&quot; was never referenced" ln="110" sev="5" auth="liwbo" rule="PARSER-REMARK" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="24" locEndLn="110" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'draw'" ln="110" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="110" sev="3" auth="liwbo" rule="FORMAT-47_a" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="11" locEndLn="110" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'draw' function should be preceded by a comment that contains the '@brief' tag" ln="110" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'draw' function should be preceded by a comment that contains the '@brief' tag" ln="110" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'object' identifier should have the 'p' prefix" ln="110" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="24" locEndLn="110" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'object' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="110" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'object' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="110" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'draw' function is not preceded by a comment" ln="110" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'draw' function is not preceded by a comment" ln="110" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="6" locEndLn="110" locEndPos="7" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'object' declaration, should be directly connected with the type" ln="110" sev="3" auth="liwbo" rule="JSF-062" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="23" locEndLn="110" locEndPos="24" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The operator '*', used for 'object' declaration, should be directly connected with the type" ln="110" sev="4" auth="liwbo" rule="FORMAT-32" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="110" locStartPos="23" locEndLn="110" locEndPos="24" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="111" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="111" locStartPos="0" locEndLn="111" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="111" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="111" locStartPos="0" locEndLn="111" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="112" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="112" locStartPos="0" locEndLn="112" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="112" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="112" locStartPos="0" locEndLn="112" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="112" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="112" locStartPos="1" locEndLn="112" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="112" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="112" locStartPos="1" locEndLn="112" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="113" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="113" locStartPos="0" locEndLn="113" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="113" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="113" locStartPos="0" locEndLn="113" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Render_Thread' has Cyclomatic Complexity value: 3" ln="115" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Render_Thread' has Essential Complexity value: 1" ln="115" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Render_Thread' has external linkage and is not declared in the header" ln="115" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Render_Thread' has external linkage and is not declared in the header" ln="115" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'Render_Thread' has external linkage and is not declared in the header" ln="115" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="115" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="0" locEndLn="115" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="115" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="0" locEndLn="115" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Render_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="115" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Render_Thread' function should be preceded by a comment that contains the '@brief' tag" ln="115" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Render_Thread' function should be preceded by a comment that contains the '@return' tag" ln="115" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'Render_Thread' function should be preceded by a comment that contains the '@return' tag" ln="115" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Render_Thread' function is not preceded by a comment" ln="115" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'Render_Thread' function is not preceded by a comment" ln="115" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The incorrect global function name Render_Thread was found" ln="115" sev="3" auth="liwbo" rule="NAMING-34" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Render_Thread' should be composed only of lowercase letters" ln="115" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'Render_Thread' should be composed only of lowercase letters" ln="115" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="115" locStartPos="7" locEndLn="115" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="116" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="116" locStartPos="0" locEndLn="116" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="116" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="116" locStartPos="0" locEndLn="116" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="116" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="116" locStartPos="0" locEndLn="116" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="117" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="117" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="117" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="1" locEndLn="117" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="117" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="1" locEndLn="117" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="117" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="117" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="117" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="117" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="117" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="117" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="117" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="The global variable &quot;exitGame&quot; is used without holding a lock" ln="117" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="3" rule="BD-TRS-THRDR" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="832658629" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="118" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType=".P" desc="while (!exitGame) {" rngLn="117">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;exitGame&quot; is used without holding a lock" ln="117" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_c" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="1447986063" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="0" locEndLn="118" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType=".P" desc="while (!exitGame) {" rngLn="117">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The operand of logical operator '!' has 'int' type instead of 'bool' type" ln="117" sev="2" auth="liwbo" rule="MISRA2008-5_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="117" locStartPos="9" locEndLn="117" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="1" locEndLn="118" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="1" locEndLn="118" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="2" locEndLn="118" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="118" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="118" locStartPos="2" locEndLn="118" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="&quot;ring&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="119" ruleSAFMsg="Usage of &quot;ring&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;ring&quot; in first critical section" pkg="Render" tool="c++test" id="1035907581" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="0" locEndLn="120" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="119" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="120" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".C" desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="128" srcRngStartPos="0" srcRngEndLn="129" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="128" ElType="." desc="SLEEP(STEP);" rngLn="128">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".P" desc="ring.getPosition()" rngLn="119">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;ring&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="119" ruleSAFMsg="Usage of &quot;ring&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;ring&quot; in first critical section" pkg="Render" tool="c++test" id="1496465233" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="0" locEndLn="120" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="119" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="120" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".C" desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="128" srcRngStartPos="0" srcRngEndLn="129" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="128" ElType="." desc="SLEEP(STEP);" rngLn="128">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".P" desc="ring.getPosition()" rngLn="119">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;ring&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="119" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="0" locEndLn="119" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="119" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="0" locEndLn="119" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="119" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="1" locEndLn="119" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="119" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="1" locEndLn="119" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="119" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="2" locEndLn="119" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="119" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="119" locStartPos="2" locEndLn="119" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="0" locEndLn="120" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="0" locEndLn="120" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="1" locEndLn="120" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="1" locEndLn="120" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="2" locEndLn="120" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="120" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="120" locStartPos="2" locEndLn="120" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'i' shall be declared as unsigned int or signed int" ln="122" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="11" locEndLn="122" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Between conditional statement 'for' and its opening parenthesis '(' should be exactly one space" ln="122" sev="3" auth="liwbo" rule="FORMAT-12" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="3" locEndLn="122" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="1" locEndLn="122" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="1" locEndLn="122" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="2" locEndLn="122" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="122" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="2" locEndLn="122" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="122" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="122" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="122" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="122" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="122" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="122" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="122" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="122" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="11" locEndLn="122" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="122" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="11" locEndLn="122" locEndPos="12" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="122" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="7" locEndLn="122" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="122" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="7" locEndLn="122" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="122" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="7" locEndLn="122" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="122" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="7" locEndLn="122" locEndPos="8" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="The global variable &quot;participantsCount&quot; is used without holding a lock" ln="122" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="3" rule="BD-TRS-THRDR" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="918588768" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="123" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType=".P" desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;participantsCount&quot; is used without holding a lock" ln="122" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_c" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="1362055722" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="122" locStartPos="0" locEndLn="123" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType=".P" desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="123" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="0" locEndLn="123" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="0" locEndLn="123" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="1" locEndLn="123" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="1" locEndLn="123" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="2" locEndLn="123" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="2" locEndLn="123" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="3" locEndLn="123" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="123" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="123" locStartPos="3" locEndLn="123" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="&quot;currentCameraVelocity&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="124" ruleSAFMsg="Usage of &quot;currentCameraVelocity&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;currentCameraVelocity&quot; in first critical section" pkg="Render" tool="c++test" id="320514128" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="125" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="119" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="120" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".C" desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;currentCameraVelocity&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType="." desc="participants[i]->getPosition()" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".P" desc="participants[i]->getPosition().translate(*currentCameraVelocity);" rngLn="124">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;currentCameraVelocity&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;currentCameraVelocity&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="124" ruleSAFMsg="Usage of &quot;currentCameraVelocity&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;currentCameraVelocity&quot; in first critical section" pkg="Render" tool="c++test" id="2006329084" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="125" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="119" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="120" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType=".C" desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;currentCameraVelocity&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType="." desc="participants[i]->getPosition()" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".P" desc="participants[i]->getPosition().translate(*currentCameraVelocity);" rngLn="124">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;currentCameraVelocity&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;participants&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="124" ruleSAFMsg="Usage of &quot;participants&quot; in second critical section" auth="liwbo" sev="2" rule="BD-TRS-DIFCS" ruleSCSCMsg="Usage of &quot;participants&quot; in first critical section" pkg="Render" tool="c++test" id="77138436" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="125" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="124" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="125" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".C" desc="participants[i]->getPosition()" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType="." desc="participants[i]->getPosition().translate(*currentCameraVelocity);" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="125" srcRngStartPos="0" srcRngEndLn="126" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="125" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="125">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="126" ElType="!" desc="draw(participants[i]);" rngLn="126">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".P" desc="participants[i]->getPosition()" rngLn="124">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;participants&quot; is used in two critical sections in context of single method, using one critical section will improve atomicity of operation" ln="124" ruleSAFMsg="Usage of &quot;participants&quot; in second critical section" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_b" ruleSCSCMsg="Usage of &quot;participants&quot; in first critical section" pkg="Render" tool="c++test" id="1612022952" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="125" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="124" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="125" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props>
        <Prop key="Tracked variables" val="Variable used in critical section"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="117" srcRngStartPos="0" srcRngEndLn="118" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="117" ElType="." desc="while (!exitGame) {" rngLn="117">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: !exitGame (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="118" srcRngStartPos="0" srcRngEndLn="119" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="118" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="118">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition()" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="119" srcRngStartPos="0" srcRngEndLn="120" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="119" ElType="." desc="ring.getPosition().translate(*currentCameraVelocity);" rngLn="119">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="120" srcRngStartPos="0" srcRngEndLn="121" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="120" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="120">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".C" desc="participants[i]->getPosition()" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="10" ElType="." desc="Point&amp; getPosition() { return _position; }" rngLn="10">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in first critical section" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType="." desc="participants[i]->getPosition().translate(*currentCameraVelocity);" rngLn="124">
          <ElDescList>
            <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="15" ElType="." desc="_x += vector._x;" rngLn="15">
              <Props/>
            </ElDesc>
            <ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Point.hpp" srcRnghash="1950870755" ln="16" ElType="." desc="_y += vector._y;" rngLn="16">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="125" srcRngStartPos="0" srcRngEndLn="126" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="125" ElType="!" desc="LOCK_RELEASE(changePositionMutex);" rngLn="125">
          <Props/>
          <Anns>
            <Ann msg="Unlocking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="126" ElType="!" desc="draw(participants[i]);" rngLn="126">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="122" ElType="." desc="for(int i = 0; i &lt; participantsCount; i++) {" rngLn="122">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; participantsCount) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="123" srcRngStartPos="0" srcRngEndLn="124" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="123" ElType="!" desc="LOCK_ACQUIRE(changePositionMutex);" rngLn="123">
          <Props/>
          <Anns>
            <Ann msg="Locking: &amp;changePositionMutex" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType=".P" desc="participants[i]->getPosition()" rngLn="124">
          <Props/>
          <Anns>
            <Ann msg="Usage of &quot;participants&quot; in second critical section" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="124" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="124" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="0" locEndLn="124" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="1" locEndLn="124" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="1" locEndLn="124" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="2" locEndLn="124" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="2" locEndLn="124" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="3" locEndLn="124" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="124" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="124" locStartPos="3" locEndLn="124" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="0" locEndLn="125" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="0" locEndLn="125" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="1" locEndLn="125" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="1" locEndLn="125" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="2" locEndLn="125" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="2" locEndLn="125" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="3" locEndLn="125" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="125" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="125" locStartPos="3" locEndLn="125" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="0" locEndLn="126" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="0" locEndLn="126" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="1" locEndLn="126" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="1" locEndLn="126" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="2" locEndLn="126" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="2" locEndLn="126" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="3" locEndLn="126" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="126" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="3" locEndLn="126" locEndPos="4" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="The &quot;participants[i]&quot; variable is used when locks are not held on &quot;changePositionMutex&quot;" ln="126" ruleSAFMsg="Place where the variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1" ruleSCSCMsg="Place where the variable is used" pkg="Render" tool="c++test" id="256398847" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="0" locEndLn="127" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="126" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="127" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="126" ElType="CP" desc="draw(participants[i]);" rngLn="126">
          <Props/>
          <Anns>
            <Ann msg="Place where the variable is used" kind="cause"/>
            <Ann msg="Incorrect synchronization" kind="comment"/>
            <Ann msg="Place where the variable is used" kind="point"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="124" srcRngStartPos="0" srcRngEndLn="125" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="124" ElType="!" desc="participants[i]->getPosition()" rngLn="124">
          <Props/>
          <Anns>
            <Ann msg="Example of correct usage" kind="comment"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;participants&quot; is used without holding a lock" ln="126" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="3" rule="BD-TRS-THRDR" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="814475608" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="0" locEndLn="127" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="126" ElType=".P" desc="draw(participants[i]);" rngLn="126">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The global variable &quot;participants&quot; is used without holding a lock" ln="126" ruleSAFMsg="The point where the global variable is used" auth="liwbo" sev="2" rule="MISRA2012-DIR-5_1_c" ruleSCSCMsg="The point where the new thread is started" pkg="Render" tool="c++test" id="1466185234" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="126" locStartPos="0" locEndLn="127" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType=".C" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <ElDescList>
            <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="126" ElType=".P" desc="draw(participants[i]);" rngLn="126">
              <Props/>
              <Anns>
                <Ann msg="The point where the global variable is used" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="The point where the new thread is started" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="127" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="0" locEndLn="127" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="127" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="0" locEndLn="127" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="127" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="1" locEndLn="127" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="127" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="1" locEndLn="127" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="127" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="2" locEndLn="127" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="127" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="127" locStartPos="2" locEndLn="127" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="128" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="9" locEndLn="128" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="0" locEndLn="128" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="0" locEndLn="128" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="1" locEndLn="128" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="1" locEndLn="128" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="2" locEndLn="128" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="128" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="128" locStartPos="2" locEndLn="128" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="129" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="129" locStartPos="0" locEndLn="129" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="129" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="129" locStartPos="0" locEndLn="129" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="129" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="129" locStartPos="1" locEndLn="129" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="129" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="129" locStartPos="1" locEndLn="129" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="130" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="2" locEndLn="130" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="A 'U' suffix shall be applied to constant: 0" ln="130" sev="2" auth="liwbo" rule="MISRA2008-2_13_3" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="9" locEndLn="130" locEndPos="10" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function return statement shall not be used" ln="130" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="2" locEndLn="130" locEndPos="3" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="130" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="0" locEndLn="130" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="130" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="0" locEndLn="130" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="130" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="1" locEndLn="130" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="130" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="130" locStartPos="1" locEndLn="130" locEndPos="2" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="131" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="131" locStartPos="0" locEndLn="131" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="131" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="131" locStartPos="0" locEndLn="131" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads' has Cyclomatic Complexity value: 1" ln="134" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads' has Essential Complexity value: 1" ln="134" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads' has external linkage and is not declared in the header" ln="134" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads' has external linkage and is not declared in the header" ln="134" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads' has external linkage and is not declared in the header" ln="134" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'runGameThreads' is declared in global namespace" ln="134" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'runGameThreads' is declared in global namespace" ln="134" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: runGameThreads" ln="134" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'runGameThreads'" ln="134" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads' function is not used in the testing scope" ln="134" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDFUNC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads' function is not used in the testing scope" ln="134" sev="2" auth="liwbo" rule="MISRA2008-0_1_10_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads' function should be preceded by a comment that contains the '@brief' tag" ln="134" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads' function should be preceded by a comment that contains the '@brief' tag" ln="134" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'runGameThreads' function is not preceded by a comment" ln="134" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'runGameThreads' function is not preceded by a comment" ln="134" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'runGameThreads' should be composed only of lowercase letters" ln="134" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'runGameThreads' should be composed only of lowercase letters" ln="134" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="134" locStartPos="5" locEndLn="134" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="135" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="135" locStartPos="0" locEndLn="135" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="136" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="136" locStartPos="0" locEndLn="136" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="136" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="136" locStartPos="0" locEndLn="136" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate declaration statement" ln="137" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate declaration statement" ln="137" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate line" ln="137" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate line" ln="137" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate declaration statement" ln="137" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate declaration statement" ln="137" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate line" ln="137" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate line" ln="137" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate declaration statement" ln="137" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate declaration statement" ln="137" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate line" ln="137" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate line" ln="137" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="137" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="0" locEndLn="137" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="137" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="0" locEndLn="137" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable has only one use" ln="137" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="8" locEndLn="137" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable has only one use" ln="137" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="8" locEndLn="137" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable should be commented" ln="137" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="8" locEndLn="137" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable should be commented" ln="137" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="8" locEndLn="137" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable has only one use" ln="137" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable has only one use" ln="137" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable should be commented" ln="137" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable should be commented" ln="137" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable has only one use" ln="137" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable has only one use" ln="137" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable should be commented" ln="137" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable should be commented" ln="137" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable has only one use" ln="137" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable has only one use" ln="137" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable should be commented" ln="137" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable should be commented" ln="137" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread1&quot; was set but never used" ln="137" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="8" locEndLn="137" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread2&quot; was set but never used" ln="137" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="17" locEndLn="137" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread3&quot; was set but never used" ln="137" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="26" locEndLn="137" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread4&quot; was set but never used" ln="137" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="137" locStartPos="35" locEndLn="137" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="138" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="27" locEndLn="138" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="138" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="41" locEndLn="138" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="138" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="0" locEndLn="138" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="138" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="0" locEndLn="138" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'GameLogic_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="138" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="30" locEndLn="138" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'GameLogic_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="138" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="30" locEndLn="138" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="138" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="24" locEndLn="138" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="138" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="41" locEndLn="138" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="138" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="41" locEndLn="138" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="138" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="0" locEndLn="139" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="138" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="139" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="138" srcRngStartPos="0" srcRngEndLn="139" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="138" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="138">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="138" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="0" locEndLn="139" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="138" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="139" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="138" srcRngStartPos="0" srcRngEndLn="139" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="138" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="138">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="138" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="138" locStartPos="0" locEndLn="139" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="138" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="139" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="138" srcRngStartPos="0" srcRngEndLn="139" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="138" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="138">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="139" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="27" locEndLn="139" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="139" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="42" locEndLn="139" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="139" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="0" locEndLn="139" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="139" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="0" locEndLn="139" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Controller_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="139" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="30" locEndLn="139" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Controller_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="139" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="30" locEndLn="139" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="139" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="24" locEndLn="139" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="139" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="42" locEndLn="139" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="139" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="42" locEndLn="139" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="139" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="0" locEndLn="140" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="139" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="140" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="139" srcRngStartPos="0" srcRngEndLn="140" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="139" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="139">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="139" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="0" locEndLn="140" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="139" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="140" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="139" srcRngStartPos="0" srcRngEndLn="140" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="139" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="139">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="139" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="139" locStartPos="0" locEndLn="140" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="139" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="140" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="139" srcRngStartPos="0" srcRngEndLn="140" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="139" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="139">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="140" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="27" locEndLn="140" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="140" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="48" locEndLn="140" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="140" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="0" locEndLn="140" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="140" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="0" locEndLn="140" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Physics_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="140" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="30" locEndLn="140" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Physics_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="140" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="30" locEndLn="140" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="140" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="24" locEndLn="140" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="140" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="48" locEndLn="140" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="140" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="48" locEndLn="140" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="140" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="0" locEndLn="141" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="140" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="0" locEndLn="141" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="140" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="140" locStartPos="0" locEndLn="141" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="140" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="141" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="140" srcRngStartPos="0" srcRngEndLn="141" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="140" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="140">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="141" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="27" locEndLn="141" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="141" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="46" locEndLn="141" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="141" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="0" locEndLn="141" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="141" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="0" locEndLn="141" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Render_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="141" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="30" locEndLn="141" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Render_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="141" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="30" locEndLn="141" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="141" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="24" locEndLn="141" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="141" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="46" locEndLn="141" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="141" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="46" locEndLn="141" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="141" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="0" locEndLn="142" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="141" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="0" locEndLn="142" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="141" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="141" locStartPos="0" locEndLn="142" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="141" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="142" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="141" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="141">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Function 'runGameThreads2' has Cyclomatic Complexity value: 1" ln="144" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads2' has Essential Complexity value: 1" ln="144" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads2' has external linkage and is not declared in the header" ln="144" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads2' has external linkage and is not declared in the header" ln="144" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Function 'runGameThreads2' has external linkage and is not declared in the header" ln="144" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'runGameThreads2' is declared in global namespace" ln="144" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Global function 'runGameThreads2' is declared in global namespace" ln="144" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Naming convention not followed: runGameThreads2" ln="144" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'runGameThreads2'" ln="144" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads2' function is not used in the testing scope" ln="144" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDFUNC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads2' function is not used in the testing scope" ln="144" sev="2" auth="liwbo" rule="MISRA2008-0_1_10_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads2' function should be preceded by a comment that contains the '@brief' tag" ln="144" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'runGameThreads2' function should be preceded by a comment that contains the '@brief' tag" ln="144" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'runGameThreads2' function is not preceded by a comment" ln="144" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The definition of the 'runGameThreads2' function is not preceded by a comment" ln="144" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'runGameThreads2' should be composed only of lowercase letters" ln="144" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The name 'runGameThreads2' should be composed only of lowercase letters" ln="144" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="144" locStartPos="5" locEndLn="144" locEndPos="6" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="145" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="145" locStartPos="0" locEndLn="145" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="146" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="146" locStartPos="0" locEndLn="146" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="146" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="146" locStartPos="0" locEndLn="146" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate declaration statement" ln="147" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate declaration statement" ln="147" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate line" ln="147" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread2' in a separate line" ln="147" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate declaration statement" ln="147" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate declaration statement" ln="147" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate line" ln="147" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread3' in a separate line" ln="147" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate declaration statement" ln="147" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate declaration statement" ln="147" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate line" ln="147" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Declare variable 'thread4' in a separate line" ln="147" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="147" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="0" locEndLn="147" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="147" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="0" locEndLn="147" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable has only one use" ln="147" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="8" locEndLn="147" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable has only one use" ln="147" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="8" locEndLn="147" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable should be commented" ln="147" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="8" locEndLn="147" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread1' variable should be commented" ln="147" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="8" locEndLn="147" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable has only one use" ln="147" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable has only one use" ln="147" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable should be commented" ln="147" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread2' variable should be commented" ln="147" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable has only one use" ln="147" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable has only one use" ln="147" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable should be commented" ln="147" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread3' variable should be commented" ln="147" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable has only one use" ln="147" sev="2" auth="liwbo" rule="MISRA2008-0_1_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable has only one use" ln="147" sev="3" auth="liwbo" rule="GLOBAL-ONEUSEVAR" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable should be commented" ln="147" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The 'thread4' variable should be commented" ln="147" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread1&quot; was set but never used" ln="147" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="8" locEndLn="147" locEndPos="9" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread2&quot; was set but never used" ln="147" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="17" locEndLn="147" locEndPos="18" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread3&quot; was set but never used" ln="147" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="26" locEndLn="147" locEndPos="27" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="W-552: variable &quot;thread4&quot; was set but never used" ln="147" sev="4" auth="liwbo" rule="PARSER-WARNING" tool="c++test" cat="PARSER" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="147" locStartPos="35" locEndLn="147" locEndPos="36" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="148" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="27" locEndLn="148" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="148" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="41" locEndLn="148" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="148" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="0" locEndLn="148" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="148" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="0" locEndLn="148" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'GameLogic_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="148" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="30" locEndLn="148" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'GameLogic_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="148" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="30" locEndLn="148" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="148" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="24" locEndLn="148" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="148" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="41" locEndLn="148" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="148" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="41" locEndLn="148" locEndPos="42" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="148" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="0" locEndLn="149" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="148" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="149" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="148" srcRngStartPos="0" srcRngEndLn="149" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="148" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="148">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="148" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="0" locEndLn="149" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="148" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="149" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="148" srcRngStartPos="0" srcRngEndLn="149" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="148" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="148">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread1&quot; is never used" ln="148" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1776530347" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="148" locStartPos="0" locEndLn="149" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="148" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="149" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="148" srcRngStartPos="0" srcRngEndLn="149" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="148" ElType="CP" desc="THREAD_CREATE(thread1, GameLogic_Thread);" rngLn="148">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="149" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="27" locEndLn="149" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="149" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="42" locEndLn="149" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="149" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="0" locEndLn="149" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="149" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="0" locEndLn="149" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Controller_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="149" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="30" locEndLn="149" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Controller_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="149" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="30" locEndLn="149" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="149" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="24" locEndLn="149" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="149" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="42" locEndLn="149" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="149" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="42" locEndLn="149" locEndPos="43" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="149" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="0" locEndLn="150" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="149" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="150" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="149" srcRngStartPos="0" srcRngEndLn="150" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="149" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="149">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="149" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="0" locEndLn="150" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="149" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="150" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="149" srcRngStartPos="0" srcRngEndLn="150" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="149" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="149">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread2&quot; is never used" ln="149" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="1265996232" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="149" locStartPos="0" locEndLn="150" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="149" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="150" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="149" srcRngStartPos="0" srcRngEndLn="150" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="149" ElType="CP" desc="THREAD_CREATE(thread2, Controller_Thread);" rngLn="149">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="150" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="27" locEndLn="150" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="150" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="48" locEndLn="150" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="150" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="0" locEndLn="150" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="150" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="0" locEndLn="150" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Physics_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="150" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="30" locEndLn="150" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Physics_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="150" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="30" locEndLn="150" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="150" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="24" locEndLn="150" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="150" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="48" locEndLn="150" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="150" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="48" locEndLn="150" locEndPos="49" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="150" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="0" locEndLn="151" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="150" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="151" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="150" srcRngStartPos="0" srcRngEndLn="151" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="150" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="150">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="150" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="0" locEndLn="151" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="150" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="151" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="150" srcRngStartPos="0" srcRngEndLn="151" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="150" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="150">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread3&quot; is never used" ln="150" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="755462121" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="150" locStartPos="0" locEndLn="151" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="150" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="151" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="150" srcRngStartPos="0" srcRngEndLn="151" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="150" ElType="CP" desc="THREAD_CREATE(thread3, Physics::Physics_Thread);" rngLn="150">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '2' shall not be used" ln="151" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="27" locEndLn="151" locEndPos="28" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '5' shall not be used" ln="151" sev="2" auth="liwbo" rule="MISRA2008-5_0_4_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="46" locEndLn="151" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="151" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="0" locEndLn="151" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="151" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="0" locEndLn="151" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Render_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="151" sev="4" auth="liwbo" rule="MISRA2012-RULE-17_12" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="30" locEndLn="151" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="Pointer to function 'Render_Thread' should be preceded by '&amp;' operator or followed by '()'" ln="151" sev="2" auth="liwbo" rule="MISRA2008-8_4_4" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="30" locEndLn="151" locEndPos="31" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '1' argument to function 'CreateThread' " ln="151" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="24" locEndLn="151" locEndPos="25" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '4' argument to function 'CreateThread' " ln="151" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="46" locEndLn="151" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <StdViol msg="The value '0' is passed as '6' argument to function 'CreateThread' " ln="151" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="46" locEndLn="151" locEndPos="47" locFile="/FlowAnalysisCpp/DeadLock.cpp"/>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="151" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="3" rule="BD-PB-VOVR" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="0" locEndLn="152" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="151" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="152" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="151" srcRngStartPos="0" srcRngEndLn="152" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="151" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="151">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="151" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2008-0_1_6" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="0" locEndLn="152" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="151" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="152" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="151" srcRngStartPos="0" srcRngEndLn="152" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="151" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="151">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Value of &quot;thread4&quot; is never used" ln="151" ruleSAFMsg="Point where value is declared" auth="liwbo" sev="2" rule="MISRA2012-RULE-2_2_b" ruleSCSCMsg="Point where value is declared" tool="c++test" id="244927494" lang="cpp" locType="sr" config="1" hash="972801700" locStartln="151" locStartPos="0" locEndLn="152" locEndPos="0" locFile="/FlowAnalysisCpp/DeadLock.cpp" FirstElSrcRngStartln="151" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="152" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="151" srcRngStartPos="0" srcRngEndLn="152" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DeadLock.cpp" srcRnghash="972801700" ln="151" ElType="CP" desc="THREAD_CREATE(thread4, Render::Render_Thread);" rngLn="151">
          <Props/>
          <Anns>
            <Ann msg="Point where value is declared" kind="cause"/>
            <Ann msg="Point where value is declared" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'DivisionByZero.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'DivisionByZero.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'DivisionByZero.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'DivisionByZero.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Shapes.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="PREPROC-09" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Shapes.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="JSF-033" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Implementation file 'DivisionByZero.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" sev="5" auth="liwbo" rule="PFO-04" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Implementation file 'DivisionByZero.cpp' should have the file name extension &quot;.cc&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-38" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Shapes.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="JSF-032" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Shapes.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="PREPROC-08" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The filename 'DivisionByZero.cpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Declare parameter 'shape1' as const" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="28" locEndLn="3" locEndPos="29" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Declare parameter 'shape2' as const" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="43" locEndLn="3" locEndPos="44" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Function 'getShapeRatio' has Cyclomatic Complexity value: 1" ln="3" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Function 'getShapeRatio' has Essential Complexity value: 1" ln="3" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Function 'getShapeRatio' has external linkage and is not declared in the header" ln="3" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Function 'getShapeRatio' has external linkage and is not declared in the header" ln="3" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Function 'getShapeRatio' has external linkage and is not declared in the header" ln="3" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Global function 'getShapeRatio' is declared in global namespace" ln="3" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Global function 'getShapeRatio' is declared in global namespace" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Naming convention not followed: getShapeRatio" ln="3" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape1&quot; with const specifier" ln="3" sev="4" auth="liwbo" rule="MISRA2012-RULE-8_13_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="28" locEndLn="3" locEndPos="29" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape1&quot; with const specifier" ln="3" sev="4" auth="liwbo" rule="JSF-118" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="28" locEndLn="3" locEndPos="29" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape1&quot; with const specifier" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_1_2_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="28" locEndLn="3" locEndPos="29" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape2&quot; with const specifier" ln="3" sev="4" auth="liwbo" rule="MISRA2012-RULE-8_13_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="43" locEndLn="3" locEndPos="44" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape2&quot; with const specifier" ln="3" sev="4" auth="liwbo" rule="JSF-118" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="43" locEndLn="3" locEndPos="44" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Pass parameter &quot;shape2&quot; with const specifier" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_1_2_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="43" locEndLn="3" locEndPos="44" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'getShapeRatio'" ln="3" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <FlowViol msg="The &quot;shape1&quot; parameter of the &quot;getShapeRatio&quot; function cannot be NULL and should be passed by reference" ln="3" ruleSAFMsg="Function header" auth="liwbo" sev="3" rule="BD-PB-REFPARAM" ruleSCSCMsg="Point where the parameter is dereferenced" tool="c++test" id="-938638073" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="4" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="3" srcRngStartPos="0" srcRngEndLn="4" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="3" ElType=".P" desc="double getShapeRatio(Shape* shape1, Shape* shape2)" rngLn="3">
          <Props/>
          <Anns>
            <Ann msg="Function header" kind="point"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape1->getArea()" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point where the parameter is dereferenced" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="The &quot;shape2&quot; parameter of the &quot;getShapeRatio&quot; function cannot be NULL and should be passed by reference" ln="3" ruleSAFMsg="Function header" auth="liwbo" sev="3" rule="BD-PB-REFPARAM" ruleSCSCMsg="Point where the parameter is dereferenced" tool="c++test" id="1613810146" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="4" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="3" srcRngStartPos="0" srcRngEndLn="4" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="3" ElType=".P" desc="double getShapeRatio(Shape* shape1, Shape* shape2)" rngLn="3">
          <Props/>
          <Anns>
            <Ann msg="Function header" kind="point"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point where the parameter is dereferenced" kind="cause"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The 'getShapeRatio' function is not used in the testing scope" ln="3" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDFUNC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'getShapeRatio' function is not used in the testing scope" ln="3" sev="2" auth="liwbo" rule="MISRA2008-0_1_10_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'getShapeRatio' function should be preceded by a comment that contains the '@brief' tag" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'getShapeRatio' function should be preceded by a comment that contains the '@brief' tag" ln="3" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'getShapeRatio' function should be preceded by a comment that contains the '@return' tag" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'getShapeRatio' function should be preceded by a comment that contains the '@return' tag" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape1' identifier should have the 'p' prefix" ln="3" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="28" locEndLn="3" locEndPos="29" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape1' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape1' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape2' identifier should have the 'p' prefix" ln="3" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="43" locEndLn="3" locEndPos="44" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape2' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The 'shape2' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="3" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="3" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="3" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="3" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The definition of the 'getShapeRatio' function is not preceded by a comment" ln="3" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The definition of the 'getShapeRatio' function is not preceded by a comment" ln="3" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The name 'getShapeRatio' should be composed only of lowercase letters" ln="3" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="The name 'getShapeRatio' should be composed only of lowercase letters" ln="3" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="3" locStartPos="7" locEndLn="3" locEndPos="8" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="4" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="5" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="1" locEndLn="5" locEndPos="2" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <FlowViol msg="Division by &quot;shape2.getArea()&quot; which may possibly be zero" ln="5" ruleSAFMsg="Point of division by zero" auth="liwbo" sev="1" rule="BD-PB-ZERO" ruleSCSCMsg="Start of the path" tool="c++test" id="-1887152637" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point of division by zero" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Division by &quot;shape2.getArea()&quot; which may possibly be zero" ln="5" ruleSAFMsg="Point of division by zero" auth="liwbo" sev="5" rule="MISRA2008-0_3_1_c" ruleSCSCMsg="Start of the path" tool="c++test" id="237544834" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point of division by zero" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Division by &quot;shape2.getArea()&quot; which may possibly be zero" ln="5" ruleSAFMsg="Point of division by zero" auth="liwbo" sev="2" rule="MISRA2012-DIR-4_1_c" ruleSCSCMsg="Start of the path" tool="c++test" id="-1398493767" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point of division by zero" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Division by &quot;shape2.getArea()&quot; which may possibly be zero" ln="5" ruleSAFMsg="Point of division by zero" auth="liwbo" sev="2" rule="MISRA2012-RULE-1_3_a" ruleSCSCMsg="Start of the path" tool="c++test" id="1398291301" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="Point of division by zero" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Infinity or NaN may be returned as a result of division by &quot;shape2.getArea()&quot; value which may possibly be zero" ln="5" ruleSAFMsg="The point where potentially unsafe value has been received" auth="liwbo" sev="5" rule="BD-PB-NANINF" ruleSCSCMsg="Start of the path" tool="c++test" id="-894929068" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="The point where potentially unsafe value has been received" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Infinity or NaN may be returned as a result of division by &quot;shape2.getArea()&quot; value which may possibly be zero" ln="5" ruleSAFMsg="The point where potentially unsafe value has been received" auth="liwbo" sev="2" rule="MISRA2012-DIR-4_15" ruleSCSCMsg="Start of the path" tool="c++test" id="1269806517" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="6" locEndPos="0" locFile="/FlowAnalysisCpp/DivisionByZero.cpp" FirstElSrcRngStartln="5" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="6" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Props/>
      <ElDescList>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".C" desc="shape2->getArea()" rngLn="5">
          <ElDescList>
            <ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/Shapes.hpp" srcRnghash="1537905639" ln="19" ElType="!" desc="double getArea() const { return 0; }" rngLn="19">
              <Props/>
            </ElDesc>
          </ElDescList>
          <Props/>
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="5" srcRngStartPos="0" srcRngEndLn="6" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/DivisionByZero.cpp" srcRnghash="-1665970746" ln="5" ElType=".P" desc="return shape1->getArea()/shape2->getArea();" rngLn="5">
          <Props/>
          <Anns>
            <Ann msg="The point where potentially unsafe value has been received" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="5" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="5" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="5" sev="5" auth="liwbo" rule="MISRA2008-0_4_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="5" sev="3" auth="liwbo" rule="COMMENT-10" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1665970746" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/DivisionByZero.cpp"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="1" sev="3" auth="liwbo" rule="PREPROC-18" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="1" sev="2" auth="liwbo" rule="JSF-022" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="1" sev="2" auth="liwbo" rule="MISRA2008-27_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'MemoryLeak.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'MemoryLeak.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'MemoryLeak.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'MemoryLeak.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Implementation file 'MemoryLeak.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" sev="5" auth="liwbo" rule="PFO-04" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Implementation file 'MemoryLeak.cpp' should have the file name extension &quot;.cc&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-38" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="1" sev="2" auth="liwbo" rule="MISRA2008-18_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The filename 'MemoryLeak.cpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="All letters beside the first one in name 'IOException' should be lowercase" ln="3" sev="3" auth="liwbo" rule="NAMING-40" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Class 'IOException' does not define any constructors" ln="3" sev="2" auth="liwbo" rule="CODSTA-CPP-19" tool="c++test" cat="CODSTA-CPP" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'IOException' identifier should have the 'C' prefix" ln="3" sev="3" auth="liwbo" rule="NAMING-HN-19" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The declaration of the 'IOException' type should be preceded by a comment that contains the '@brief' tag" ln="3" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Type 'IOException' is declared in global namespace" ln="3" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Type 'IOException' is declared in global namespace" ln="3" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="3" locStartPos="6" locEndLn="3" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Declare parameter 'file' as const" ln="5" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Function 'readIntegerArray' has Cyclomatic Complexity value: 3" ln="5" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Function 'readIntegerArray' has Essential Complexity value: 1" ln="5" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Function 'readIntegerArray' has external linkage and is not declared in the header" ln="5" sev="4" auth="liwbo" rule="JSF-137" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Function 'readIntegerArray' has external linkage and is not declared in the header" ln="5" sev="4" auth="liwbo" rule="MISRA-023" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Function 'readIntegerArray' has external linkage and is not declared in the header" ln="5" sev="2" auth="liwbo" rule="MISRA2008-3_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Global function 'readIntegerArray' is declared in global namespace" ln="5" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Global function 'readIntegerArray' is declared in global namespace" ln="5" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Identifier name: 'file' differs only by case from its type name: 'FILE'" ln="5" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Identifier name: 'file' differs only by case from its type name: 'FILE'" ln="5" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Naming convention not followed: readIntegerArray" ln="5" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Pass parameter &quot;pSize&quot; with const specifier" ln="5" sev="4" auth="liwbo" rule="MISRA2012-RULE-8_13_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Pass parameter &quot;pSize&quot; with const specifier" ln="5" sev="4" auth="liwbo" rule="JSF-118" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Pass parameter &quot;pSize&quot; with const specifier" ln="5" sev="2" auth="liwbo" rule="MISRA2008-7_1_2_a" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'readIntegerArray'" ln="5" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'file' identifier should have the 'p' prefix" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'file' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'file' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'pSize' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-23" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'pSize' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-44" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'pSize' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-31" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="39" locEndLn="5" locEndPos="40" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'pSize' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'pSize' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function is not used in the testing scope" ln="5" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDFUNC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function is not used in the testing scope" ln="5" sev="2" auth="liwbo" rule="MISRA2008-0_1_10_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function should be preceded by a comment that contains the '@return' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'readIntegerArray' function should be preceded by a comment that contains the '@return' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="34" locEndLn="5" locEndPos="35" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="34" locEndLn="5" locEndPos="35" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="34" locEndLn="5" locEndPos="35" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="34" locEndLn="5" locEndPos="35" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The definition of the 'readIntegerArray' function is not preceded by a comment" ln="5" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The definition of the 'readIntegerArray' function is not preceded by a comment" ln="5" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The identifier 'file' differs only by case from identifier 'FILE' declared in file 'stdio.h'" ln="5" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The identifier 'file' differs only by case from identifier 'FILE' declared in file 'stdio.h'" ln="5" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="28" locEndLn="5" locEndPos="29" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The name 'readIntegerArray' should be composed only of lowercase letters" ln="5" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The name 'readIntegerArray' should be composed only of lowercase letters" ln="5" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="6" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="6" locStartPos="0" locEndLn="6" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Unused function's &quot;fscanf&quot; return value" ln="7" sev="2" auth="liwbo" rule="MISRA2012-RULE-17_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Unused function's &quot;fscanf&quot; return value" ln="7" sev="2" auth="liwbo" rule="MISRA2008-0_3_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Unused function's &quot;fscanf&quot; return value" ln="7" sev="3" auth="liwbo" rule="JSF-115" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Unused function's 'fscanf' return value" ln="7" sev="2" auth="liwbo" rule="MISRA2008-0_1_7" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Unused function's 'fscanf' return value" ln="7" sev="4" auth="liwbo" rule="JSF-115_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Usage of 'fscanf' function is not allowed" ln="7" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_6" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="7" locStartPos="1" locEndLn="7" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="8" sev="2" auth="liwbo" rule="MISRA2012-DIR-4_12" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="13" locEndLn="8" locEndPos="14" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="8" sev="2" auth="liwbo" rule="MISRA2008-18_4_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="13" locEndLn="8" locEndPos="14" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="8" sev="2" auth="liwbo" rule="JSF-206" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="13" locEndLn="8" locEndPos="14" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="8" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_3" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="13" locEndLn="8" locEndPos="14" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <FlowViol msg="Data obtained from a file (&quot;*pSize&quot;) is used to determine the size of memory allocation" ln="8" ruleSAFMsg="Point where the array is allocated" auth="liwbo" sev="2" rule="BD-SECURITY-TDALLOC" ruleSCSCMsg="Tainting point" tool="c++test" id="-862528737" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="0" locEndLn="9" locEndPos="0" locFile="/FlowAnalysisCpp/MemoryLeak.cpp" FirstElSrcRngStartln="7" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="8" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Props>
        <Prop key="Tracked variables" val="Tainted data"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="7" ElType=".C" desc="fscanf(file, &quot;%d&quot;, pSize);" rngLn="7">
          <Props/>
          <Anns>
            <Ann msg="Tainting point" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="8" ElType=".P" desc="int* data = new int[*pSize];" rngLn="8">
          <Props/>
          <Anns>
            <Ann msg="Point where the array is allocated" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Declare local variable 'data' as const" ln="8" sev="2" auth="liwbo" rule="MISRA2008-7_1_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Naming convention not followed: data" ln="8" sev="3" auth="liwbo" rule="NAMING-22" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="8" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="8" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="8" sev="3" auth="liwbo" rule="NAMING-HN-23" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="8" sev="3" auth="liwbo" rule="NAMING-HN-44" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="8" sev="3" auth="liwbo" rule="NAMING-HN-31" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' identifier should have the 'p' prefix" ln="8" sev="3" auth="liwbo" rule="NAMING-HN-34" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' identifier should have the 'prg' prefix" ln="8" sev="3" auth="liwbo" rule="NAMING-HN-16" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' variable should be commented" ln="8" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'data' variable should be commented" ln="8" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="6" locEndLn="8" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="1" locEndLn="8" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="1" locEndLn="8" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="1" locEndLn="8" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="1" locEndLn="8" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="17" locEndLn="8" locEndPos="18" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="17" locEndLn="8" locEndPos="18" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="17" locEndLn="8" locEndPos="18" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="17" locEndLn="8" locEndPos="18" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Use vector or string instead of dynamically allocated array" ln="8" sev="3" auth="liwbo" rule="STL-10" tool="c++test" cat="STL" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="8" locStartPos="13" locEndLn="8" locEndPos="14" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'i' shall be declared as unsigned int or signed int" ln="9" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <FlowViol msg="Data obtained from a file (&quot;*pSize&quot;) is used in a loop condition" ln="9" ruleSAFMsg="Tainted data use in a loop condition" auth="liwbo" sev="1" rule="BD-SECURITY-TDLOOP" ruleSCSCMsg="Tainting point" tool="c++test" id="2054996746" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="10" locEndPos="0" locFile="/FlowAnalysisCpp/MemoryLeak.cpp" FirstElSrcRngStartln="7" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="8" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Props>
        <Prop key="Tracked variables" val="Tainted data"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="7" ElType=".C" desc="fscanf(file, &quot;%d&quot;, pSize);" rngLn="7">
          <Props>
            <Prop key="Tracked variables" val="pSize[]"/>
          </Props>
          <Anns>
            <Ann msg="Tainting point" kind="cause"/>
            <Ann msg="Tainted data: pSize[]" kind="var"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="8" ElType="." desc="int* data = new int[*pSize];" rngLn="8">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="9" srcRngStartPos="0" srcRngEndLn="10" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="9" ElType=".P" desc="for (int i = 0; i &lt; *pSize; i++) {" rngLn="9">
          <Props>
            <Prop key="Tracked variables" val="pSize[]"/>
          </Props>
          <Anns>
            <Ann msg="Tainted data: pSize[]" kind="var"/>
            <Ann msg="Tainted data use in a loop condition" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="9" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="9" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="9" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="9" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="9" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The 'i' variable should be commented" ln="9" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="6" locEndLn="9" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="6" locEndLn="9" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="6" locEndLn="9" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="9" locStartPos="6" locEndLn="9" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Avoid indexing non-array objects" ln="10" sev="2" auth="liwbo" rule="MISRA2008-5_0_15" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="26" locEndLn="10" locEndPos="27" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="1" locEndLn="10" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="1" locEndLn="10" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="10" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="10" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Usage of 'fscanf' function is not allowed" ln="10" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_6" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="10" locStartPos="6" locEndLn="10" locEndPos="7" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="1" locEndLn="11" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="1" locEndLn="11" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="2" locEndLn="11" locEndPos="3" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="2" locEndLn="11" locEndPos="3" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="c++ exception handling structure is used in function 'readIntegerArray'" ln="11" sev="2" auth="liwbo" rule="JSF-208" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="11" locStartPos="3" locEndLn="11" locEndPos="4" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="12" locStartPos="1" locEndLn="12" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="12" locStartPos="1" locEndLn="12" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="13" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="13" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="14" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="14" locStartPos="1" locEndLn="14" locEndPos="2" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="14" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="14" locStartPos="0" locEndLn="14" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="14" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="14" locStartPos="0" locEndLn="14" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp"/>
    <FlowViol msg="Memory not deallocated: data" ln="15" ruleSAFMsg="Point where allocated memory is lost" auth="liwbo" sev="1" rule="BD-RES-LEAKS" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="-1842545282" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="15" locStartPos="0" locEndLn="16" locEndPos="0" locFile="/FlowAnalysisCpp/MemoryLeak.cpp" FirstElSrcRngStartln="8" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="9" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="7" ElType="." desc="fscanf(file, &quot;%d&quot;, pSize);" rngLn="7">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="8" ElType=".C" desc="int* data = new int[*pSize];" rngLn="8">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause"/>
            <Ann msg="Allocated memory: data" kind="var"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="9" srcRngStartPos="0" srcRngEndLn="10" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="9" ElType="." desc="for (int i = 0; i &lt; *pSize; i++) {" rngLn="9">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; *pSize) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="10" ElType="!" desc="if (fscanf(file, &quot;%d&quot;, &amp;data[i]) == EOF) {" rngLn="10">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (fscanf(...) == -1) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="11" ElType="!E" desc="throw IOException();" rngLn="11" thrownTypes="throwStatement" throwingMethod="">
          <Props/>
          <Anns>
            <Ann msg="Throws an exception" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="15" ElType=".P" desc="}" rngLn="15">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Allocated memory: data" kind="var"/>
            <Ann msg="Point where allocated memory is lost" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Memory not deallocated: data" ln="15" ruleSAFMsg="Point where allocated memory is lost" auth="liwbo" sev="4" rule="MISRA2012-DIR-4_13_a" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="-2082188591" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="15" locStartPos="0" locEndLn="16" locEndPos="0" locFile="/FlowAnalysisCpp/MemoryLeak.cpp" FirstElSrcRngStartln="8" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="9" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="7" ElType="." desc="fscanf(file, &quot;%d&quot;, pSize);" rngLn="7">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="8" ElType=".C" desc="int* data = new int[*pSize];" rngLn="8">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause"/>
            <Ann msg="Allocated memory: data" kind="var"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="9" srcRngStartPos="0" srcRngEndLn="10" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="9" ElType="." desc="for (int i = 0; i &lt; *pSize; i++) {" rngLn="9">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; *pSize) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="10" ElType="!" desc="if (fscanf(file, &quot;%d&quot;, &amp;data[i]) == EOF) {" rngLn="10">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (fscanf(...) == -1) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="11" ElType="!E" desc="throw IOException();" rngLn="11" thrownTypes="throwStatement" throwingMethod="">
          <Props/>
          <Anns>
            <Ann msg="Throws an exception" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="15" ElType=".P" desc="}" rngLn="15">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Allocated memory: data" kind="var"/>
            <Ann msg="Point where allocated memory is lost" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Memory not deallocated: data" ln="15" ruleSAFMsg="Point where allocated memory is lost" auth="liwbo" sev="2" rule="MISRA2012-RULE-22_1" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="-1842545282" lang="cpp" locType="sr" config="1" hash="1013754779" locStartln="15" locStartPos="0" locEndLn="16" locEndPos="0" locFile="/FlowAnalysisCpp/MemoryLeak.cpp" FirstElSrcRngStartln="8" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="9" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="7" ElType="." desc="fscanf(file, &quot;%d&quot;, pSize);" rngLn="7">
          <Props/>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="8" ElType=".C" desc="int* data = new int[*pSize];" rngLn="8">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause"/>
            <Ann msg="Allocated memory: data" kind="var"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="9" srcRngStartPos="0" srcRngEndLn="10" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="9" ElType="." desc="for (int i = 0; i &lt; *pSize; i++) {" rngLn="9">
          <Props/>
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; *pSize) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="10" srcRngStartPos="0" srcRngEndLn="11" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="10" ElType="!" desc="if (fscanf(file, &quot;%d&quot;, &amp;data[i]) == EOF) {" rngLn="10">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (fscanf(...) == -1) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="11" ElType="!E" desc="throw IOException();" rngLn="11" thrownTypes="throwStatement" throwingMethod="">
          <Props/>
          <Anns>
            <Ann msg="Throws an exception" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/MemoryLeak.cpp" srcRnghash="1013754779" ln="15" ElType=".P" desc="}" rngLn="15">
          <Props>
            <Prop key="Tracked variables" val="data"/>
          </Props>
          <Anns>
            <Ann msg="Allocated memory: data" kind="var"/>
            <Ann msg="Point where allocated memory is lost" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'NullPointer.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'NullPointer.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'NullPointer.cpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'NullPointer.cpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Point.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="PREPROC-09" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Point.hpp&quot;" ln="1" sev="2" auth="liwbo" rule="JSF-033" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Implementation file 'NullPointer.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" sev="5" auth="liwbo" rule="PFO-04" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Implementation file 'NullPointer.cpp' should have the file name extension &quot;.cc&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-38" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Point.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="JSF-032" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Point.hpp&quot;" ln="1" sev="3" auth="liwbo" rule="PREPROC-08" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The filename 'NullPointer.cpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Instead of C library header '&lt;stdlib.h>' the corresponding C++ library header should be used" ln="3" sev="2" auth="liwbo" rule="MISRA2008-18_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="3" locStartPos="0" locEndLn="3" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'argc' shall be declared as unsigned int or signed int" ln="5" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="13" locEndLn="5" locEndPos="14" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'main' shall be declared as unsigned int or signed int" ln="5" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Declare parameter 'argc' as const" ln="5" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="13" locEndLn="5" locEndPos="14" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Function 'main' has Cyclomatic Complexity value: 2" ln="5" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Function 'main' has Essential Complexity value: 1" ln="5" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Parameter 'argv' with array type was found in 'main' function declaration" ln="5" sev="2" auth="liwbo" rule="JSF-097_c" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="25" locEndLn="5" locEndPos="26" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Return type is not placed in line before function 'main'" ln="5" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="13" locEndLn="5" locEndPos="14" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="13" locEndLn="5" locEndPos="14" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argc' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="13" locEndLn="5" locEndPos="14" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="5" sev="4" auth="liwbo" rule="MISRA2008-15_3_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="5" sev="2" auth="liwbo" rule="MISRA2008-15_5_3_d" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="19" locEndLn="5" locEndPos="20" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="5" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="19" locEndLn="5" locEndPos="20" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="9" locEndLn="5" locEndPos="10" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="9" locEndLn="5" locEndPos="10" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="5" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="5" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="6" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="6" locStartPos="0" locEndLn="6" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="7" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="7" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'point' variable should be commented" ln="7" sev="3" auth="liwbo" rule="JSF-132_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The 'point' variable should be commented" ln="7" sev="3" auth="liwbo" rule="COMMENT-05" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="8" locEndLn="7" locEndPos="9" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Variable 'point' of pointer type is initialized with '0'" ln="7" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="16" locEndLn="7" locEndPos="17" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Variable 'point' of pointer type is initialized with '0'" ln="7" sev="2" auth="liwbo" rule="MISRA2008-4_10_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="16" locEndLn="7" locEndPos="17" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Variable 'point' of pointer type is initialized with '0'" ln="7" sev="2" auth="liwbo" rule="MISRA2012-RULE-11_9_b" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="7" locStartPos="16" locEndLn="7" locEndPos="17" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Literal constant '3' is used" ln="8" sev="3" auth="liwbo" rule="JSF-151" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="12" locEndLn="8" locEndPos="13" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="8" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="8" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="8" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="8" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="8" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="8" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="8" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="8" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="9" sev="2" auth="liwbo" rule="MISRA2012-DIR-4_12" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="9" sev="2" auth="liwbo" rule="MISRA2008-18_4_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="9" sev="2" auth="liwbo" rule="JSF-206" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'new' operator should not be used" ln="9" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_3" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="10" locEndLn="9" locEndPos="11" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Literal constant '2' is used" ln="9" sev="3" auth="liwbo" rule="JSF-151" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="45" locEndLn="9" locEndPos="46" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="9" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="9" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="9" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="1" locEndLn="9" locEndPos="2" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="9" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="1" locEndLn="9" locEndPos="2" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="MISRA2008-18_0_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="20" locEndLn="9" locEndPos="21" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="20" locEndLn="9" locEndPos="21" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="JSF-023" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="20" locEndLn="9" locEndPos="21" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="MISRA2008-18_0_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="35" locEndLn="9" locEndPos="36" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="MISRA2012-RULE-21_7" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="35" locEndLn="9" locEndPos="36" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="9" sev="2" auth="liwbo" rule="JSF-023" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="9" locStartPos="35" locEndLn="9" locEndPos="36" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="10" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <FlowViol msg="&quot;point&quot; may possibly be null" ln="11" ruleSAFMsg="Null pointer dereferencing point" auth="liwbo" sev="1" rule="BD-PB-NP" ruleSCSCMsg="Source of null value" tool="c++test" id="1390236584" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="11" locStartPos="0" locEndLn="12" locEndPos="0" locFile="/FlowAnalysisCpp/NullPointer.cpp" FirstElSrcRngStartln="7" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="8" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/NullPointer.cpp">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="7" ElType=".C" desc="Point* point = 0;" rngLn="7">
          <Props/>
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: point" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="8" ElType="." desc="if (argc > 3) {" rngLn="8">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (argc > 3) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="11" ElType=".P" desc="point->reflectAcrossX();" rngLn="11">
          <Props/>
          <Anns>
            <Ann msg="Null value carrier: point" kind="comment"/>
            <Ann msg="Null pointer dereferencing point" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;point&quot; may possibly be null" ln="11" ruleSAFMsg="Null pointer dereferencing point" auth="liwbo" sev="5" rule="MISRA2008-0_3_1_b" ruleSCSCMsg="Source of null value" tool="c++test" id="1863528706" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="11" locStartPos="0" locEndLn="12" locEndPos="0" locFile="/FlowAnalysisCpp/NullPointer.cpp" FirstElSrcRngStartln="7" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="8" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/NullPointer.cpp">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="7" ElType=".C" desc="Point* point = 0;" rngLn="7">
          <Props/>
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: point" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="8" ElType="." desc="if (argc > 3) {" rngLn="8">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (argc > 3) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="11" ElType=".P" desc="point->reflectAcrossX();" rngLn="11">
          <Props/>
          <Anns>
            <Ann msg="Null value carrier: point" kind="comment"/>
            <Ann msg="Null pointer dereferencing point" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;point&quot; may possibly be null" ln="11" ruleSAFMsg="Null pointer dereferencing point" auth="liwbo" sev="2" rule="MISRA2012-DIR-4_1_b" ruleSCSCMsg="Source of null value" tool="c++test" id="-845203141" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="11" locStartPos="0" locEndLn="12" locEndPos="0" locFile="/FlowAnalysisCpp/NullPointer.cpp" FirstElSrcRngStartln="7" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="8" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/FlowAnalysisCpp/NullPointer.cpp">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier"/>
      </Props>
      <ElDescList>
        <ElDesc srcRngStartln="7" srcRngStartPos="0" srcRngEndLn="8" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="7" ElType=".C" desc="Point* point = 0;" rngLn="7">
          <Props/>
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: point" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="8" srcRngStartPos="0" srcRngEndLn="9" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="8" ElType="." desc="if (argc > 3) {" rngLn="8">
          <Props/>
          <Anns>
            <Ann msg="Condition evaluation: (argc > 3) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="11" srcRngStartPos="0" srcRngEndLn="12" srcRngEndPos="0" srcRngFile="/FlowAnalysisCpp/NullPointer.cpp" srcRnghash="-1257393797" ln="11" ElType=".P" desc="point->reflectAcrossX();" rngLn="11">
          <Props/>
          <Anns>
            <Ann msg="Null value carrier: point" kind="comment"/>
            <Ann msg="Null pointer dereferencing point" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Non-ascii tab found" ln="11" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="11" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="11" locStartPos="0" locEndLn="11" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="12" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="13" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="13" locStartPos="1" locEndLn="13" locEndPos="2" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="13" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="Non-ascii tab found" ln="13" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="-1257393797" locStartln="13" locStartPos="0" locEndLn="13" locEndPos="1" locFile="/FlowAnalysisCpp/NullPointer.cpp"/>
    <StdViol msg="'Point.hpp' filename extension does not adhere to naming conventions" ln="1" sev="3" auth="liwbo" rule="NAMING-43" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'Point.hpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'Point.hpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'Point.hpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'Point.hpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="File 'Point.hpp'  should have the &quot;.icc&quot; file name extension" ln="1" sev="3" auth="liwbo" rule="NAMING-39" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Header file 'Point.hpp' should have the file name extension &quot;.h&quot;" ln="1" sev="3" auth="liwbo" rule="JSF-053" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Header file 'Point.hpp' should have the file name extension &quot;.h&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-41" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Header file 'Point.hpp' should have the file name extension &quot;.hh&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-37" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="POINT_HPP macro name should appear as first #ifndef or #if preprocessor directive" ln="1" sev="3" auth="liwbo" rule="PFO-07" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The filename 'Point.hpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="4" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Public section must be before protected and private sections" ln="4" sev="3" auth="liwbo" rule="JSF-057_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="4" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'Point' identifier should have the 'C' prefix" ln="4" sev="3" auth="liwbo" rule="NAMING-HN-19" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The declaration of the 'Point' type should be preceded by a comment that contains the '@brief' tag" ln="4" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="4" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="4" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'NullPointer.cpp'" ln="4" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'NullPointer.cpp'" ln="4" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Point.hpp'" ln="4" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Point.hpp'" ln="4" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Shapes.hpp'" ln="4" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Shapes.hpp'" ln="4" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The type name 'Point' is not a unique identifier in the testing scope" ln="4" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The type name 'Point' is not a unique identifier in the testing scope" ln="4" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Type 'Point' is declared in global namespace" ln="4" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Type 'Point' is declared in global namespace" ln="4" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="4" locStartPos="6" locEndLn="4" locEndPos="7" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'_x' shall be declared as unsigned int or signed int" ln="5" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'_y' shall be declared as unsigned int or signed int" ln="5" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare variable '_y' in a separate declaration statement" ln="5" sev="2" auth="liwbo" rule="MISRA2008-8_0_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare variable '_y' in a separate declaration statement" ln="5" sev="3" auth="liwbo" rule="FORMAT-33" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare variable '_y' in a separate line" ln="5" sev="2" auth="liwbo" rule="JSF-152" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare variable '_y' in a separate line" ln="5" sev="3" auth="liwbo" rule="FORMAT-29" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Member variable '_x' shall begin with a lowercase letter" ln="5" sev="3" auth="liwbo" rule="NAMING-07" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Member variable '_y' shall begin with a lowercase letter" ln="5" sev="3" auth="liwbo" rule="NAMING-07" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: _x" ln="5" sev="3" auth="liwbo" rule="NAMING-14" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: _x" ln="5" sev="3" auth="liwbo" rule="NAMING-19" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: _y" ln="5" sev="3" auth="liwbo" rule="NAMING-14" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: _y" ln="5" sev="3" auth="liwbo" rule="NAMING-19" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_x' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_x' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_x' identifier should have the 'm_' prefix" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-29" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_x' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_x' member variable should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_y' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-22" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_y' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-43" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_y' identifier should have the 'm_' prefix" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-29" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_y' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="5" sev="3" auth="liwbo" rule="NAMING-HN-30" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The '_y' member variable should be preceded by a comment that contains the '@brief' tag" ln="5" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="4" locEndLn="5" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier '_x' differs only by presence/absence of the underscore character from identifier 'x' declared in file 'Point.hpp'" ln="5" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier '_x' differs only by presence/absence of the underscore character from identifier 'x' declared in file 'Point.hpp'" ln="5" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier '_y' differs only by presence/absence of the underscore character from identifier 'y' declared in file 'Point.hpp'" ln="5" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier '_y' differs only by presence/absence of the underscore character from identifier 'y' declared in file 'Point.hpp'" ln="5" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_x' is not allowed" ln="5" sev="3" auth="liwbo" rule="NAMING-33" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_x' is not allowed" ln="5" sev="3" auth="liwbo" rule="JSF-047" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="8" locEndLn="5" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_y' is not allowed" ln="5" sev="3" auth="liwbo" rule="NAMING-33" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_y' is not allowed" ln="5" sev="3" auth="liwbo" rule="JSF-047" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="5" locStartPos="12" locEndLn="5" locEndPos="13" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'x' shall be declared as unsigned int or signed int" ln="7" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'y' shall be declared as unsigned int or signed int" ln="7" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare parameter 'x' as const" ln="7" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Declare parameter 'y' as const" ln="7" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'Point' has Cyclomatic Complexity value: 1" ln="7" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'Point' has Essential Complexity value: 1" ln="7" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'x' differs only by presence/absence of the underscore character from identifier name: '_x' declared in class" ln="7" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'x' differs only by presence/absence of the underscore character from identifier name: '_x' declared in class" ln="7" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'y' differs only by presence/absence of the underscore character from identifier name: '_y' declared in class" ln="7" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'y' differs only by presence/absence of the underscore character from identifier name: '_y' declared in class" ln="7" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="7" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="7" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="7" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="7" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="40" locEndLn="7" locEndPos="41" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="7" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="40" locEndLn="7" locEndPos="41" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="7" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="40" locEndLn="7" locEndPos="41" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'Point' function should be preceded by a comment that contains the '@brief' tag" ln="7" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'Point' function should be preceded by a comment that contains the '@brief' tag" ln="7" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'Point' identifier is the same as the name of a type defined in the testing scope" ln="7" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'Point' identifier is the same as the name of a type defined in the testing scope" ln="7" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'x' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="7" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'x' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="7" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'y' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="7" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'y' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="7" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="10" locEndLn="7" locEndPos="11" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="10" locEndLn="7" locEndPos="11" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="10" locEndLn="7" locEndPos="11" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="10" locEndLn="7" locEndPos="11" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="17" locEndLn="7" locEndPos="18" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="17" locEndLn="7" locEndPos="18" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="17" locEndLn="7" locEndPos="18" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="7" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="17" locEndLn="7" locEndPos="18" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'Point' function is not preceded by a comment" ln="7" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'Point' function is not preceded by a comment" ln="7" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'Point' differs only by case from identifier 'point' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="4" locEndLn="7" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'x' differs only by presence/absence of the underscore character from identifier '_x' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'x' differs only by presence/absence of the underscore character from identifier '_x' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="14" locEndLn="7" locEndPos="15" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'y' differs only by presence/absence of the underscore character from identifier '_y' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'y' differs only by presence/absence of the underscore character from identifier '_y' declared in file 'Point.hpp'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="7" locStartPos="21" locEndLn="7" locEndPos="22" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'reflectAcrossX' has Cyclomatic Complexity value: 1" ln="8" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'reflectAcrossX' has Essential Complexity value: 1" ln="8" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: reflectAcrossX" ln="8" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'reflectAcrossX'" ln="8" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'reflectAcrossX' function should be preceded by a comment that contains the '@brief' tag" ln="8" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'reflectAcrossX' function should be preceded by a comment that contains the '@brief' tag" ln="8" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'reflectAcrossX' function is not preceded by a comment" ln="8" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'reflectAcrossX' function is not preceded by a comment" ln="8" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The name 'reflectAcrossX' should be composed only of lowercase letters" ln="8" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The name 'reflectAcrossX' should be composed only of lowercase letters" ln="8" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="8" locStartPos="9" locEndLn="8" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="9" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="9" locStartPos="0" locEndLn="9" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'translate' has Cyclomatic Complexity value: 1" ln="13" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'translate' has Essential Complexity value: 1" ln="13" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: translate" ln="13" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'translate'" ln="13" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="13" sev="3" auth="liwbo" rule="FORMAT-47_a" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="19" locEndLn="13" locEndPos="20" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'translate' function should be preceded by a comment that contains the '@brief' tag" ln="13" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'translate' function should be preceded by a comment that contains the '@brief' tag" ln="13" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'vector' identifier should have the 'k' prefix" ln="13" sev="3" auth="liwbo" rule="NAMING-HN-11" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="32" locEndLn="13" locEndPos="33" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'vector' identifier should have the 'r' prefix" ln="13" sev="3" auth="liwbo" rule="NAMING-HN-35" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="32" locEndLn="13" locEndPos="33" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'vector' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="13" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'vector' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="13" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'translate' function is not preceded by a comment" ln="13" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'translate' function is not preceded by a comment" ln="13" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="13" locStartPos="9" locEndLn="13" locEndPos="10" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="14" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="14" locStartPos="0" locEndLn="14" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="15" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="15" locStartPos="4" locEndLn="15" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="15" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="15" locStartPos="4" locEndLn="15" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="16" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="16" locStartPos="4" locEndLn="16" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="16" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="16" locStartPos="4" locEndLn="16" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'squareDistanceTo' shall be declared as unsigned int or signed int" ln="19" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'squareDistanceTo' has Cyclomatic Complexity value: 1" ln="19" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Function 'squareDistanceTo' has Essential Complexity value: 1" ln="19" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from identifier name: 'Point' ( line: '4')" ln="19" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from identifier name: 'Point' ( line: '4')" ln="19" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from identifier name: 'Point' declared in class" ln="19" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from identifier name: 'Point' declared in class" ln="19" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="19" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="19" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Member function 'squareDistanceTo' should be declared as const" ln="19" sev="3" auth="liwbo" rule="JSF-069" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Member function 'squareDistanceTo' should be declared as const" ln="19" sev="2" auth="liwbo" rule="MISRA2008-9_3_3" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Naming convention not followed: squareDistanceTo" ln="19" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'squareDistanceTo'" ln="19" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="19" sev="3" auth="liwbo" rule="FORMAT-47_a" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="25" locEndLn="19" locEndPos="26" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'point' identifier should have the 'k' prefix" ln="19" sev="3" auth="liwbo" rule="NAMING-HN-11" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'point' identifier should have the 'r' prefix" ln="19" sev="3" auth="liwbo" rule="NAMING-HN-35" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'point' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'point' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'squareDistanceTo' function should be preceded by a comment that contains the '@brief' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'squareDistanceTo' function should be preceded by a comment that contains the '@brief' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'squareDistanceTo' function should be preceded by a comment that contains the '@return' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The 'squareDistanceTo' function should be preceded by a comment that contains the '@return' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="19" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="19" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="19" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="19" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'squareDistanceTo' function is not preceded by a comment" ln="19" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The definition of the 'squareDistanceTo' function is not preceded by a comment" ln="19" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="19" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="19" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="19" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="19" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="38" locEndLn="19" locEndPos="39" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The name 'squareDistanceTo' should be composed only of lowercase letters" ln="19" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="The name 'squareDistanceTo' should be composed only of lowercase letters" ln="19" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="19" locStartPos="8" locEndLn="19" locEndPos="9" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="20" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="20" locStartPos="0" locEndLn="20" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="21" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="21" locStartPos="5" locEndLn="21" locEndPos="6" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Line has over 79 characters" ln="21" sev="3" auth="liwbo" rule="FORMAT-04" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="21" locStartPos="0" locEndLn="21" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="21" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="21" locStartPos="4" locEndLn="21" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="21" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="21" locStartPos="4" locEndLn="21" locEndPos="5" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Use // comments only" ln="25" sev="2" auth="liwbo" rule="JSF-126" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="25" locStartPos="7" locEndLn="25" locEndPos="8" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="Use // comments only" ln="25" sev="3" auth="liwbo" rule="COMMENT-01" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1950870755" locStartln="25" locStartPos="7" locEndLn="25" locEndPos="8" locFile="/FlowAnalysisCpp/Point.hpp"/>
    <StdViol msg="'Shapes.hpp' filename extension does not adhere to naming conventions" ln="1" sev="3" auth="liwbo" rule="NAMING-43" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'Shapes.hpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-02" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'Shapes.hpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'Shapes.hpp'" ln="1" sev="3" auth="liwbo" rule="COMMENT-03" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'Shapes.hpp'" ln="1" sev="3" auth="liwbo" rule="JSF-133_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="File 'Shapes.hpp'  should have the &quot;.icc&quot; file name extension" ln="1" sev="3" auth="liwbo" rule="NAMING-39" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="File 'Shapes.hpp' contains more than one class definition" ln="1" sev="3" auth="liwbo" rule="PFO-03" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Header file 'Shapes.hpp' contains more than one class declaration: 'Shape, LineSegment, Circle'" ln="1" sev="3" auth="liwbo" rule="PFO-10" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Header file 'Shapes.hpp' should have the file name extension &quot;.h&quot;" ln="1" sev="3" auth="liwbo" rule="JSF-053" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Header file 'Shapes.hpp' should have the file name extension &quot;.h&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-41" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Header file 'Shapes.hpp' should have the file name extension &quot;.hh&quot;" ln="1" sev="3" auth="liwbo" rule="NAMING-37" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="SHAPES_HPP macro name should appear as first #ifndef or #if preprocessor directive" ln="1" sev="3" auth="liwbo" rule="PFO-07" tool="c++test" cat="PFO" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" sev="3" auth="liwbo" rule="METRICS-31" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The filename 'Shapes.hpp' should be in lowercase" ln="1" sev="3" auth="liwbo" rule="NAMING-03" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="1" locStartPos="0" locEndLn="1" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Point.hpp&quot;" ln="4" sev="2" auth="liwbo" rule="PREPROC-09" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;Point.hpp&quot;" ln="4" sev="2" auth="liwbo" rule="JSF-033" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Point.hpp&quot;" ln="4" sev="3" auth="liwbo" rule="JSF-032" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;Point.hpp&quot;" ln="4" sev="3" auth="liwbo" rule="PREPROC-08" tool="c++test" cat="PREPROC" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="4" locStartPos="0" locEndLn="4" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Class 'Shape' has virtual functions without a virtual destructor" ln="6" sev="2" auth="liwbo" rule="OOP-23" tool="c++test" cat="OOP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Class 'Shape' must define a virtual destructor" ln="6" sev="2" auth="liwbo" rule="JSF-078" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="6" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="0" locEndLn="6" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Protected section must be before private section" ln="6" sev="3" auth="liwbo" rule="JSF-057_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Public section must be before protected and private sections" ln="6" sev="3" auth="liwbo" rule="JSF-057_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="6" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="0" locEndLn="6" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Shape' identifier should have the 'C' prefix" ln="6" sev="3" auth="liwbo" rule="NAMING-HN-19" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The declaration of the 'Shape' type should be preceded by a comment that contains the '@brief' tag" ln="6" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'Shape' is not a unique identifier in the testing scope" ln="6" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'Shape' is not a unique identifier in the testing scope" ln="6" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'Shape' is declared in global namespace" ln="6" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'Shape' is declared in global namespace" ln="6" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="6" locStartPos="6" locEndLn="6" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Member variable '_position' shall begin with a lowercase letter" ln="7" sev="3" auth="liwbo" rule="NAMING-07" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: _position" ln="7" sev="3" auth="liwbo" rule="NAMING-14" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="7" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_position' identifier should have the 'm_' prefix" ln="7" sev="3" auth="liwbo" rule="NAMING-HN-29" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_position' member variable should be preceded by a comment that contains the '@brief' tag" ln="7" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_position' differs only by presence/absence of the underscore character from identifier 'position' declared in file 'Shapes.hpp'" ln="7" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_position' differs only by presence/absence of the underscore character from identifier 'position' declared in file 'Shapes.hpp'" ln="7" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_position' is not allowed" ln="7" sev="3" auth="liwbo" rule="NAMING-33" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_position' is not allowed" ln="7" sev="3" auth="liwbo" rule="JSF-047" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="7" locStartPos="7" locEndLn="7" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: getArea" ln="9" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="9" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="9" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="9" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="9" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="9" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="12" locEndLn="9" locEndPos="13" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="9" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="12" locEndLn="9" locEndPos="13" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="9" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="12" locEndLn="9" locEndPos="13" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="9" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="12" locEndLn="9" locEndPos="13" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The declaration of the 'getArea' function is not preceded by a comment" ln="9" sev="4" auth="liwbo" rule="JSF-134_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The declaration of the 'getArea' function is not preceded by a comment" ln="9" sev="3" auth="liwbo" rule="COMMENT-04_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="9" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="9" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="9" locStartPos="19" locEndLn="9" locEndPos="20" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="10" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="27" locEndLn="10" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getPosition' has Cyclomatic Complexity value: 1" ln="10" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getPosition' has Essential Complexity value: 1" ln="10" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Member function 'getPosition' returns handles to member data: '_position'" ln="10" sev="3" auth="liwbo" rule="CODSTA-CPP-06" tool="c++test" cat="CODSTA-CPP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="27" locEndLn="10" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: getPosition" ln="10" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="10" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="10" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="10" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="10" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Public member function 'getPosition' returns non-const handles to member data: '_position'" ln="10" sev="2" auth="liwbo" rule="MISRA2008-9_3_2_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="27" locEndLn="10" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Public member function 'getPosition' returns non-const handles to member data: '_position'" ln="10" sev="3" auth="liwbo" rule="OOP-36" tool="c++test" cat="OOP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="27" locEndLn="10" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="45" locEndLn="10" locEndPos="46" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="45" locEndLn="10" locEndPos="46" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="45" locEndLn="10" locEndPos="46" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-03" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="45" locEndLn="10" locEndPos="46" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="10" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'getPosition'" ln="10" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getPosition' function should be preceded by a comment that contains the '@brief' tag" ln="10" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getPosition' function should be preceded by a comment that contains the '@brief' tag" ln="10" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getPosition' function should be preceded by a comment that contains the '@return' tag" ln="10" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getPosition' function should be preceded by a comment that contains the '@return' tag" ln="10" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getPosition' function is not preceded by a comment" ln="10" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getPosition' function is not preceded by a comment" ln="10" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getPosition' should be composed only of lowercase letters" ln="10" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getPosition' should be composed only of lowercase letters" ln="10" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="10" locStartPos="11" locEndLn="10" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Constructor 'Shape' allowing conversion should be made explicit" ln="12" sev="4" auth="liwbo" rule="JSF-177_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Constructor 'Shape' allowing conversion should be made explicit" ln="12" sev="1" auth="liwbo" rule="CODSTA-CPP-04" tool="c++test" cat="CODSTA-CPP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Declare parameter 'position' as const" ln="12" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'Shape' has Cyclomatic Complexity value: 1" ln="12" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'Shape' has Essential Complexity value: 1" ln="12" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in class" ln="12" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in class" ln="12" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="12" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="12" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="12" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="12" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="49" locEndLn="12" locEndPos="50" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="12" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="49" locEndLn="12" locEndPos="50" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="12" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="49" locEndLn="12" locEndPos="50" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="12" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="12" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="12" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="0" locEndLn="12" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Shape' function should be preceded by a comment that contains the '@brief' tag" ln="12" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Shape' function should be preceded by a comment that contains the '@brief' tag" ln="12" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Shape' identifier is the same as the name of a type defined in the testing scope" ln="12" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Shape' identifier is the same as the name of a type defined in the testing scope" ln="12" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="12" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="12" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'Shape' function is not preceded by a comment" ln="12" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'Shape' function is not preceded by a comment" ln="12" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="4" locEndLn="12" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="12" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="12" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Shape' is passed by value" ln="12" sev="3" auth="liwbo" rule="OPT-14" tool="c++test" cat="OPT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Shape' is passed by value" ln="12" sev="4" auth="liwbo" rule="JSF-125_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Shape' is passed by value" ln="12" sev="4" auth="liwbo" rule="JSF-117" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="12" locStartPos="16" locEndLn="12" locEndPos="17" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="A declaration of the 'LineSegment' type which is not used has been found" ln="15" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDTYPE" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="A declaration of the 'LineSegment' type which is not used has been found" ln="15" sev="2" auth="liwbo" rule="MISRA2008-0_1_5" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="All letters beside the first one in name 'LineSegment' should be lowercase" ln="15" sev="3" auth="liwbo" rule="NAMING-40" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Class 'LineSegment' has virtual functions without a virtual destructor" ln="15" sev="2" auth="liwbo" rule="OOP-23" tool="c++test" cat="OOP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="15" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Public section must be before protected and private sections" ln="15" sev="3" auth="liwbo" rule="JSF-057_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="15" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' identifier should have the 'C' prefix" ln="15" sev="3" auth="liwbo" rule="NAMING-HN-19" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The declaration of the 'LineSegment' type should be preceded by a comment that contains the '@brief' tag" ln="15" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'LineSegment' is not a unique identifier in the testing scope" ln="15" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'LineSegment' is not a unique identifier in the testing scope" ln="15" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'LineSegment' is declared in global namespace" ln="15" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'LineSegment' is declared in global namespace" ln="15" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="15" locStartPos="6" locEndLn="15" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Member variable '_end' shall begin with a lowercase letter" ln="16" sev="3" auth="liwbo" rule="NAMING-07" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: _end" ln="16" sev="3" auth="liwbo" rule="NAMING-14" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="16" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="0" locEndLn="16" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="16" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="0" locEndLn="16" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Private member variable '_end' is declared but not used" ln="16" sev="2" auth="liwbo" rule="MISRA2008-0_1_3_c" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_end' identifier should have the 'm_' prefix" ln="16" sev="3" auth="liwbo" rule="NAMING-HN-29" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_end' member variable should be preceded by a comment that contains the '@brief' tag" ln="16" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_end' differs only by presence/absence of the underscore character from identifier 'end' declared in file 'Shapes.hpp'" ln="16" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_end' differs only by presence/absence of the underscore character from identifier 'end' declared in file 'Shapes.hpp'" ln="16" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_end' is not allowed" ln="16" sev="3" auth="liwbo" rule="NAMING-33" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_end' is not allowed" ln="16" sev="3" auth="liwbo" rule="JSF-047" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="16" locStartPos="7" locEndLn="16" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Declare parameter 'end' as const" ln="18" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Declare parameter 'position' as const" ln="18" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'LineSegment' has Cyclomatic Complexity value: 1" ln="18" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'LineSegment' has Essential Complexity value: 1" ln="18" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'end' differs only by presence/absence of the underscore character from identifier name: '_end' declared in class" ln="18" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'end' differs only by presence/absence of the underscore character from identifier name: '_end' declared in class" ln="18" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in base class" ln="18" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in base class" ln="18" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="18" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="18" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="18" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="18" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="73" locEndLn="18" locEndPos="74" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="18" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="73" locEndLn="18" locEndPos="74" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="18" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="73" locEndLn="18" locEndPos="74" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="18" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="18" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="18" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="0" locEndLn="18" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' function is not used in the testing scope" ln="18" sev="3" auth="liwbo" rule="GLOBAL-UNUSEDFUNC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' function is not used in the testing scope" ln="18" sev="2" auth="liwbo" rule="MISRA2008-0_1_10_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' function should be preceded by a comment that contains the '@brief' tag" ln="18" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' function should be preceded by a comment that contains the '@brief' tag" ln="18" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' identifier is the same as the name of a type defined in the testing scope" ln="18" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'LineSegment' identifier is the same as the name of a type defined in the testing scope" ln="18" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'end' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="18" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'end' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="18" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="18" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="18" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'LineSegment' function is not preceded by a comment" ln="18" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'LineSegment' function is not preceded by a comment" ln="18" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="4" locEndLn="18" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'end' differs only by presence/absence of the underscore character from identifier '_end' declared in file 'Shapes.hpp'" ln="18" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'end' differs only by presence/absence of the underscore character from identifier '_end' declared in file 'Shapes.hpp'" ln="18" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="18" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="18" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'end' of function 'LineSegment' is passed by value" ln="18" sev="3" auth="liwbo" rule="OPT-14" tool="c++test" cat="OPT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'end' of function 'LineSegment' is passed by value" ln="18" sev="4" auth="liwbo" rule="JSF-125_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'end' of function 'LineSegment' is passed by value" ln="18" sev="4" auth="liwbo" rule="JSF-117" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="38" locEndLn="18" locEndPos="39" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'LineSegment' is passed by value" ln="18" sev="3" auth="liwbo" rule="OPT-14" tool="c++test" cat="OPT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'LineSegment' is passed by value" ln="18" sev="4" auth="liwbo" rule="JSF-125_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'LineSegment' is passed by value" ln="18" sev="4" auth="liwbo" rule="JSF-117" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="18" locStartPos="22" locEndLn="18" locEndPos="23" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="19" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="29" locEndLn="19" locEndPos="30" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getArea' has Cyclomatic Complexity value: 1" ln="19" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getArea' has Essential Complexity value: 1" ln="19" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Implicit conversion from integral to floating type in function's return" ln="19" sev="2" auth="liwbo" rule="MISRA2008-5_0_5_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="29" locEndLn="19" locEndPos="30" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: getArea" ln="19" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="19" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="19" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="19" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="19" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="19" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="39" locEndLn="19" locEndPos="40" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="19" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="39" locEndLn="19" locEndPos="40" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="19" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="39" locEndLn="19" locEndPos="40" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="19" sev="3" auth="liwbo" rule="FORMAT-03" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="39" locEndLn="19" locEndPos="40" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="19" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="19" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="19" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="19" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="0" locEndLn="19" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'getArea'" ln="19" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="19" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="19" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="19" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="19" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="19" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="4" locEndLn="19" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getArea' function is not preceded by a comment" ln="19" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getArea' function is not preceded by a comment" ln="19" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="19" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="19" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Use the virtual keyword for 'getArea' function" ln="19" sev="2" auth="liwbo" rule="MISRA2008-10_3_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="19" locStartPos="11" locEndLn="19" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Class 'Circle' has virtual functions without a virtual destructor" ln="22" sev="2" auth="liwbo" rule="OOP-23" tool="c++test" cat="OOP" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="22" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="0" locEndLn="22" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Public section must be before protected and private sections" ln="22" sev="3" auth="liwbo" rule="JSF-057_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="22" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="0" locEndLn="22" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The declaration of the 'Circle' type should be preceded by a comment that contains the '@brief' tag" ln="22" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'Circle' is not a unique identifier in the testing scope" ln="22" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The type name 'Circle' is not a unique identifier in the testing scope" ln="22" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'Circle' is declared in global namespace" ln="22" sev="4" auth="liwbo" rule="JSF-098" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Type 'Circle' is declared in global namespace" ln="22" sev="2" auth="liwbo" rule="MISRA2008-7_3_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="22" locStartPos="6" locEndLn="22" locEndPos="7" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Member variable '_radius' shall begin with a lowercase letter" ln="23" sev="3" auth="liwbo" rule="NAMING-07" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: _radius" ln="23" sev="3" auth="liwbo" rule="NAMING-14" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: _radius" ln="23" sev="3" auth="liwbo" rule="NAMING-15" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="23" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="0" locEndLn="23" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="23" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="0" locEndLn="23" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_radius' identifier should have the 'd' prefix followed by a capital letter or an underscore" ln="23" sev="3" auth="liwbo" rule="NAMING-HN-12" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_radius' identifier should have the 'm_' prefix" ln="23" sev="3" auth="liwbo" rule="NAMING-HN-29" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The '_radius' member variable should be preceded by a comment that contains the '@brief' tag" ln="23" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="23" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="1" locEndLn="23" locEndPos="2" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="23" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="1" locEndLn="23" locEndPos="2" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="23" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="1" locEndLn="23" locEndPos="2" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="23" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="1" locEndLn="23" locEndPos="2" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_radius' differs only by presence/absence of the underscore character from identifier 'radius' declared in file 'Shapes.hpp'" ln="23" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier '_radius' differs only by presence/absence of the underscore character from identifier 'radius' declared in file 'Shapes.hpp'" ln="23" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_radius' is not allowed" ln="23" sev="3" auth="liwbo" rule="NAMING-33" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Using underscore at the beginning of the name '_radius' is not allowed" ln="23" sev="3" auth="liwbo" rule="JSF-047" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="23" locStartPos="8" locEndLn="23" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Declare parameter 'position' as const" ln="25" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Declare parameter 'radius' as const" ln="25" sev="2" auth="liwbo" rule="MISRA2008-7_1_1_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'Circle' has Cyclomatic Complexity value: 1" ln="25" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'Circle' has Essential Complexity value: 1" ln="25" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in base class" ln="25" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'position' differs only by presence/absence of the underscore character from identifier name: '_position' declared in base class" ln="25" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'radius' differs only by presence/absence of the underscore character from identifier name: '_radius' declared in class" ln="25" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'radius' differs only by presence/absence of the underscore character from identifier name: '_radius' declared in class" ln="25" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="25" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="25" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="25" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="25" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="78" locEndLn="25" locEndPos="79" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="25" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="78" locEndLn="25" locEndPos="79" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="25" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="78" locEndLn="25" locEndPos="79" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="25" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="25" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="25" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="0" locEndLn="25" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Circle' function should be preceded by a comment that contains the '@brief' tag" ln="25" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Circle' function should be preceded by a comment that contains the '@brief' tag" ln="25" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Circle' identifier is the same as the name of a type defined in the testing scope" ln="25" sev="2" auth="liwbo" rule="MISRA2012-RULE-5_7_a" tool="c++test" cat="MISRA2012-RULE" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'Circle' identifier is the same as the name of a type defined in the testing scope" ln="25" sev="3" auth="liwbo" rule="GLOBAL-UNIQUETYPEC" tool="c++test" cat="GLOBAL" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="25" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'position' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="25" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'radius' identifier should have the 'd' prefix followed by a capital letter or an underscore" ln="25" sev="3" auth="liwbo" rule="NAMING-HN-12" tool="c++test" cat="NAMING-HN" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'radius' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="25" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'radius' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="25" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="25" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="27" locEndLn="25" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="25" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="27" locEndLn="25" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="25" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="27" locEndLn="25" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="25" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="27" locEndLn="25" locEndPos="28" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'Circle' function is not preceded by a comment" ln="25" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'Circle' function is not preceded by a comment" ln="25" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="4" locEndLn="25" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="25" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'position' differs only by presence/absence of the underscore character from identifier '_position' declared in file 'Shapes.hpp'" ln="25" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'radius' differs only by presence/absence of the underscore character from identifier '_radius' declared in file 'Shapes.hpp'" ln="25" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'radius' differs only by presence/absence of the underscore character from identifier '_radius' declared in file 'Shapes.hpp'" ln="25" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="34" locEndLn="25" locEndPos="35" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Circle' is passed by value" ln="25" sev="3" auth="liwbo" rule="OPT-14" tool="c++test" cat="OPT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Circle' is passed by value" ln="25" sev="4" auth="liwbo" rule="JSF-125_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'position' of function 'Circle' is passed by value" ln="25" sev="4" auth="liwbo" rule="JSF-117" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="25" locStartPos="17" locEndLn="25" locEndPos="18" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="26" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="29" locEndLn="26" locEndPos="30" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getArea' has Cyclomatic Complexity value: 1" ln="26" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'getArea' has Essential Complexity value: 1" ln="26" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Literal constant '3.141592653' is used" ln="26" sev="3" auth="liwbo" rule="JSF-151" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="36" locEndLn="26" locEndPos="37" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: getArea" ln="26" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="26" sev="3" auth="liwbo" rule="FORMAT-43" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="26" sev="3" auth="liwbo" rule="JSF-060_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="26" sev="3" auth="liwbo" rule="FORMAT-34" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="26" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="26" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="69" locEndLn="26" locEndPos="70" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="26" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="69" locEndLn="26" locEndPos="70" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="26" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="69" locEndLn="26" locEndPos="70" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="26" sev="3" auth="liwbo" rule="FORMAT-03" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="69" locEndLn="26" locEndPos="70" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" sev="3" auth="liwbo" rule="JSF-061" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" sev="3" auth="liwbo" rule="FORMAT-42" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" sev="3" auth="liwbo" rule="JSF-060_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" sev="3" auth="liwbo" rule="FORMAT-02" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="0" locEndLn="26" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'getArea'" ln="26" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="26" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@brief' tag" ln="26" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="26" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'getArea' function should be preceded by a comment that contains the '@return' tag" ln="26" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="26" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="4" locEndLn="26" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="26" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="4" locEndLn="26" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="26" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="4" locEndLn="26" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'double' should not be used" ln="26" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="4" locEndLn="26" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getArea' function is not preceded by a comment" ln="26" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'getArea' function is not preceded by a comment" ln="26" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="26" sev="3" auth="liwbo" rule="JSF-051" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The name 'getArea' should be composed only of lowercase letters" ln="26" sev="3" auth="liwbo" rule="NAMING-44" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Use the virtual keyword for 'getArea' function" ln="26" sev="2" auth="liwbo" rule="MISRA2008-10_3_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="11" locEndLn="26" locEndPos="12" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="26" sev="5" auth="liwbo" rule="MISRA2008-0_4_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="36" locEndLn="26" locEndPos="37" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="26" sev="3" auth="liwbo" rule="COMMENT-10" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="26" locStartPos="36" locEndLn="26" locEndPos="37" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="'contains' shall be declared as unsigned int or signed int" ln="27" sev="3" auth="liwbo" rule="PORT-13" tool="c++test" cat="PORT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'contains' has Cyclomatic Complexity value: 1" ln="27" sev="5" auth="liwbo" rule="METRICS-29" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Function 'contains' has Essential Complexity value: 1" ln="27" sev="5" auth="liwbo" rule="METRICS-33" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="27" sev="2" auth="liwbo" rule="MISRA2008-2_10_1" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Identifier name: 'point' differs only by case from its type name: 'Point'" ln="27" sev="3" auth="liwbo" rule="NAMING-47" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Naming convention not followed: contains" ln="27" sev="3" auth="liwbo" rule="NAMING-17" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Return type is not placed in line before function 'contains'" ln="27" sev="3" auth="liwbo" rule="FORMAT-28" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'contains' function should be preceded by a comment that contains the '@brief' tag" ln="27" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'contains' function should be preceded by a comment that contains the '@brief' tag" ln="27" sev="3" auth="liwbo" rule="COMMENT-14" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'contains' function should be preceded by a comment that contains the '@return' tag" ln="27" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'contains' function should be preceded by a comment that contains the '@return' tag" ln="27" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'point' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="27" sev="3" auth="liwbo" rule="COMMENT-14_c" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The 'point' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="27" sev="3" auth="liwbo" rule="COMMENT-14_b" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="27" sev="4" auth="liwbo" rule="MISRA2008-3_9_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="4" locEndLn="27" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="27" sev="3" auth="liwbo" rule="MISRA-013" tool="c++test" cat="MISRA" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="4" locEndLn="27" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="27" sev="2" auth="liwbo" rule="JSF-209_b" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="4" locEndLn="27" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="27" sev="4" auth="liwbo" rule="MISRA2012-DIR-4_6_b" tool="c++test" cat="MISRA2012-DIR" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="4" locEndLn="27" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'contains' function is not preceded by a comment" ln="27" sev="3" auth="liwbo" rule="COMMENT-04" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The definition of the 'contains' function is not preceded by a comment" ln="27" sev="4" auth="liwbo" rule="JSF-134" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="8" locEndLn="27" locEndPos="9" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="27" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'POINT' declared in file 'windef.h'" ln="27" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="27" sev="3" auth="liwbo" rule="NAMING-45" tool="c++test" cat="NAMING" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The identifier 'point' differs only by case from identifier 'Point' declared in file 'Point.hpp'" ln="27" sev="3" auth="liwbo" rule="JSF-048" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'point' of function 'contains' is passed by value" ln="27" sev="3" auth="liwbo" rule="OPT-14" tool="c++test" cat="OPT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'point' of function 'contains' is passed by value" ln="27" sev="4" auth="liwbo" rule="JSF-125_a" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="The parameter 'point' of function 'contains' is passed by value" ln="27" sev="4" auth="liwbo" rule="JSF-117" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="27" locStartPos="23" locEndLn="27" locEndPos="24" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="28" sev="3" auth="liwbo" rule="METRICS-19" tool="c++test" cat="METRICS" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="28" locStartPos="0" locEndLn="28" locEndPos="1" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="29" sev="3" auth="liwbo" rule="FORMAT-25_b" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="5" locEndLn="29" locEndPos="6" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Implicit conversion from integral to floating type in comparison expression" ln="29" sev="2" auth="liwbo" rule="MISRA2008-5_0_5_b" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="12" locEndLn="29" locEndPos="13" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="29" sev="4" auth="liwbo" rule="JSF-043" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="4" locEndLn="29" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Non-ascii tab found" ln="29" sev="5" auth="liwbo" rule="FORMAT-01" tool="c++test" cat="FORMAT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="4" locEndLn="29" locEndPos="5" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="29" sev="5" auth="liwbo" rule="MISRA2008-0_4_2" tool="c++test" cat="MISRA2008" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="54" locEndLn="29" locEndPos="55" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="floating-point arithmetic is not documented" ln="29" sev="3" auth="liwbo" rule="COMMENT-10" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="29" locStartPos="54" locEndLn="29" locEndPos="55" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Use // comments only" ln="33" sev="2" auth="liwbo" rule="JSF-126" tool="c++test" cat="JSF" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="33" locStartPos="7" locEndLn="33" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
    <StdViol msg="Use // comments only" ln="33" sev="3" auth="liwbo" rule="COMMENT-01" tool="c++test" cat="COMMENT" lang="cpp" locType="sr" config="1" hash="1537905639" locStartln="33" locStartPos="7" locEndLn="33" locEndPos="8" locFile="/FlowAnalysisCpp/Shapes.hpp"/>
  </StdViols>

      <Supps/>
      
      <TestedFilesDetails>
         <Total name="Suppressed / Total" supp="0" total="1781">
            <Project name="FlowAnalysisCpp" supp="0" total="1781">
               <Res loc="/FlowAnalysisCpp/DivisionByZero.cpp" locType="sr" name="DivisionByZero.cpp" supp="0" total="63"/>
               <Res loc="/FlowAnalysisCpp/DeadLock.cpp" locType="sr" name="DeadLock.cpp" supp="0" total="975"/>
               <Res loc="/FlowAnalysisCpp/Point.hpp" locType="sr" name="Point.hpp" supp="0" total="178"/>
               <Res loc="/FlowAnalysisCpp/NullPointer.cpp" locType="sr" name="NullPointer.cpp" supp="0" total="87"/>
               <Res loc="/FlowAnalysisCpp/MemoryLeak.cpp" locType="sr" name="MemoryLeak.cpp" supp="0" total="142"/>
               <Res loc="/FlowAnalysisCpp/Shapes.hpp" locType="sr" name="Shapes.hpp" supp="0" total="336"/>
            </Project>
         </Total>
      </TestedFilesDetails>
   
   </CodingStandards>
   <Exec ownerId="com.parasoft.xtest.checkers.api.execution" time="0:00:55">
      
  <ExecViols>
    <ExecViol actVal="" expectVal="" ln="61" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-169768059074021113" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_assertion_6" testCaseId="-6053732949562963176" locStartln="61" locStartPos="0" locEndLn="61" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught exception" detMsg="Exception while executing test case" prnMsg="Exception while executing test case">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="61" fhash="1274881582" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1387" fhash="1435231280" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="42" fhash="1364184810" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="92" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://5917323524961847199" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_2" testCaseId="2334440049772760294" locStartln="92" locStartPos="0" locEndLn="92" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="92" fhash="-251104526" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="334" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="18" fhash="-1888009208" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847168" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_1" testCaseId="2334440049772760200" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="224" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="16" fhash="-1888010169" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://-1895652858647320860" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_10" testCaseId="7300921574446908665" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="279" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="17" fhash="1601233133" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847230" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_3" testCaseId="2334440049772761060" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="389" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="19" fhash="-1888008247" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847261" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_4" testCaseId="2334440049772761154" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="444" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="20" fhash="-1888007286" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847292" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_5" testCaseId="2334440049772761248" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="499" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="21" fhash="-1888006325" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847323" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_6" testCaseId="2334440049772761993" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="554" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="22" fhash="-1888005364" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847354" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_7" testCaseId="2334440049772762087" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="609" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="23" fhash="-1888004403" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847385" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_8" testCaseId="2334440049772762181" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="664" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="24" fhash="-1888003442" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="100" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="14" testId="CPP://5917323524961847416" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Physics_Thread_9" testCaseId="2334440049772762926" locStartln="100" locStartPos="0" locEndLn="100" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Timeout reached" detMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]" prnMsg="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="100" fhash="1234365944" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="719" fhash="1969688109" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="25" fhash="-1888002481" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139333" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_1" testCaseId="2748315626081627354" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="774" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="26" fhash="1445621238" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://2769153150642923465" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_10" testCaseId="-321909979956481199" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="829" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="27" fhash="1864591646" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139302" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_2" testCaseId="2748315626081627260" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="884" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="28" fhash="1445622199" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139240" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_4" testCaseId="2748315626081626421" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="994" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="30" fhash="1445624121" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139209" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_5" testCaseId="2748315626081626306" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1049" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="31" fhash="1445625082" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139147" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_7" testCaseId="2748315626081625467" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1159" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="33" fhash="1445627004" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="118" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139116" lang="cpp" locType="sr" config="1" hash="972801700" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_8" testCaseId="2748315626081625373" locStartln="118" locStartPos="0" locEndLn="118" locEndPos="1" locFile="/FlowAnalysisCpp/DeadLock.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="118" fhash="-2061438629" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1214" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="34" fhash="1445627965" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="5" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DivisionByZero.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3900030495373673724" lang="cpp" locType="sr" config="1" hash="-1665970746" testName="TestSuite_DivisionByZero_cpp_e7ecfacc::test_getShapeRatio_1" testCaseId="-6786627959879454601" locStartln="5" locStartPos="0" locEndLn="5" locEndPos="1" locFile="/FlowAnalysisCpp/DivisionByZero.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DivisionByZero.cpp" ln="5" fhash="2070090220" hash="-1665970746"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DivisionByZero_cpp.cpp" ln="63" fhash="-1819384022" hash="-1569153924"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DivisionByZero_cpp.cpp" ln="14" fhash="-130354301" hash="-1569153924"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DivisionByZero_cpp.cpp" ln="12" fhash="-801083680" hash="-1569153924"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="7" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3483263584330554913" lang="cpp" locType="sr" config="1" hash="1013754779" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_4" testCaseId="1037959698011563203" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/MemoryLeak.cpp" ln="7" fhash="-1844934654" hash="1013754779"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="137" fhash="-1464257273" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="17" fhash="-1332888327" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="12" fhash="-119582105" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="7" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3483263584330554975" lang="cpp" locType="sr" config="1" hash="1013754779" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_2" testCaseId="1037959698011563391" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]" prnMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/MemoryLeak.cpp" ln="7" fhash="-1844934654" hash="1013754779"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="98" fhash="-1464257273" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="15" fhash="-1332890249" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="12" fhash="-119582105" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="7" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3483263584330554851" lang="cpp" locType="sr" config="1" hash="1013754779" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_6" testCaseId="1037959698011562364" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]" prnMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/MemoryLeak.cpp" ln="7" fhash="-1844934654" hash="1013754779"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="176" fhash="-1464257273" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="19" fhash="-1332886405" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="12" fhash="-119582105" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="7" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3483263584330554789" lang="cpp" locType="sr" config="1" hash="1013754779" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_8" testCaseId="1037959698011561504" locStartln="7" locStartPos="0" locEndLn="7" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]" prnMsg="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/MemoryLeak.cpp" ln="7" fhash="-1844934654" hash="1013754779"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="213" fhash="-1464257273" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="21" fhash="-1332884483" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="12" fhash="-119582105" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="8" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3483263584330554820" lang="cpp" locType="sr" config="1" hash="1013754779" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_7" testCaseId="1037959698011562270" locStartln="8" locStartPos="0" locEndLn="8" locEndPos="1" locFile="/FlowAnalysisCpp/MemoryLeak.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/MemoryLeak.cpp" ln="8" fhash="1773312110" hash="1013754779"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="194" fhash="-1464257273" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="20" fhash="-1332885444" hash="-1939902105"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="12" fhash="-119582105" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555267" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_1" testCaseId="-3867579205097265055" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="81" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="14" fhash="-258799490" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://8596611062750787591" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_10" testCaseId="2835598866093744162" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="99" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="15" fhash="567156630" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555236" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_2" testCaseId="-3867579205097265149" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="116" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="16" fhash="-258798529" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555205" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_3" testCaseId="-3867579205097265243" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="133" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="17" fhash="-258797568" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555174" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_4" testCaseId="-3867579205097265988" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="152" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="18" fhash="-258796607" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555143" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_5" testCaseId="-3867579205097266082" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="171" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="19" fhash="-258795646" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555081" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_7" testCaseId="-3867579205097266921" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="209" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="21" fhash="-258793724" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555050" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_8" testCaseId="-3867579205097267015" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="228" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="22" fhash="-258792763" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="10" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-6240397817828555019" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_9" testCaseId="-3867579205097267130" locStartln="10" locStartPos="0" locEndLn="10" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="10" fhash="-796707555" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/NullPointer.cpp" ln="11" fhash="1178067846" hash="-1257393797"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="247" fhash="-572929505" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="23" fhash="-258791802" hash="-1745074582"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="12" fhash="-1286238096" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="15" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139271" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_3" testCaseId="2748315626081626515" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="15" fhash="931387847" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="119" fhash="-1448027104" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="939" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="29" fhash="1445623160" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="15" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139178" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_6" testCaseId="2748315626081625561" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="15" fhash="931387847" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="119" fhash="-1448027104" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1104" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="32" fhash="1445626043" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="15" auth="liwbo" sev="1" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="0" testId="CPP://-3453099028911139085" lang="cpp" locType="sr" config="1" hash="1950870755" testName="TestSuite_DeadLock_cpp_2788e23e::test_Render_Thread_9" testCaseId="2748315626081624628" locStartln="15" locStartPos="0" locEndLn="15" locEndPos="1" locFile="/FlowAnalysisCpp/Point.hpp">
      <Thr lang="cpp">
        <ThrPart clName="Uncaught structured exception" detMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]" prnMsg="Access violation exception [CPPTEST_ACCESS_VIOLATION]">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/Point.hpp" ln="15" fhash="931387847" hash="1950870755"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/DeadLock.cpp" ln="119" fhash="-1448027104" hash="972801700"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1269" fhash="1052132513" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="35" fhash="1445628926" hash="-1447413861"/>
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="12" fhash="374110870" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="167" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-8787606607065969279" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_Controller_Thread_1" testCaseId="-3539189863341549294" locStartln="167" locStartPos="0" locEndLn="167" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::DWORD _return=0" prnMsg="Outcome: ::DWORD _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="167" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="168" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-8787606607065969279" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_Controller_Thread_1" testCaseId="-3539189863341549294" locStartln="168" locStartPos="0" locEndLn="168" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: void * _arg1 =NULL" prnMsg="Outcome: void * _arg1 =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="168" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="182" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://2590983518837012229" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_GameLogic_Thread_1" testCaseId="4447855853524231819" locStartln="182" locStartPos="0" locEndLn="182" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::DWORD _return=0" prnMsg="Outcome: ::DWORD _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="182" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="183" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://2590983518837012229" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_GameLogic_Thread_1" testCaseId="4447855853524231819" locStartln="183" locStartPos="0" locEndLn="183" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: void * _arg1 =NULL" prnMsg="Outcome: void * _arg1 =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="183" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1491" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1491" locStartPos="0" locEndLn="1491" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1491" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1492" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1492" locStartPos="0" locEndLn="1492" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1492" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1493" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1493" locStartPos="0" locEndLn="1493" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1493" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1494" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1494" locStartPos="0" locEndLn="1494" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1494" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1495" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1495" locStartPos="0" locEndLn="1495" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1495" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1496" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1496" locStartPos="0" locEndLn="1496" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1496" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1497" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1497" locStartPos="0" locEndLn="1497" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1497" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1498" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1498" locStartPos="0" locEndLn="1498" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1498" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1499" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1499" locStartPos="0" locEndLn="1499" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1499" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1500" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1500" locStartPos="0" locEndLn="1500" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1500" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1501" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1501" locStartPos="0" locEndLn="1501" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1501" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1502" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973832" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_1" testCaseId="-6833303556452580348" locStartln="1502" locStartPos="0" locEndLn="1502" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1502" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1547" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1547" locStartPos="0" locEndLn="1547" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1547" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1548" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1548" locStartPos="0" locEndLn="1548" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1548" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1549" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1549" locStartPos="0" locEndLn="1549" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1549" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1550" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1550" locStartPos="0" locEndLn="1550" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1550" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1551" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1551" locStartPos="0" locEndLn="1551" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1551" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1552" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1552" locStartPos="0" locEndLn="1552" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1552" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1553" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1553" locStartPos="0" locEndLn="1553" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1553" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1554" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1554" locStartPos="0" locEndLn="1554" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1554" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1555" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1555" locStartPos="0" locEndLn="1555" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1555" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1556" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1556" locStartPos="0" locEndLn="1556" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1556" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1557" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1557" locStartPos="0" locEndLn="1557" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1557" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1558" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-4782954082015981348" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_10" testCaseId="8594005124747791828" locStartln="1558" locStartPos="0" locEndLn="1558" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1558" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1603" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1603" locStartPos="0" locEndLn="1603" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1603" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1604" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1604" locStartPos="0" locEndLn="1604" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=2147483647" prnMsg="Outcome: int ::participantsCount=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1604" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1605" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1605" locStartPos="0" locEndLn="1605" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1605" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1606" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1606" locStartPos="0" locEndLn="1606" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1606" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1607" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1607" locStartPos="0" locEndLn="1607" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1607" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1608" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1608" locStartPos="0" locEndLn="1608" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1608" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1609" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1609" locStartPos="0" locEndLn="1609" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1609" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1610" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1610" locStartPos="0" locEndLn="1610" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1610" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1611" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1611" locStartPos="0" locEndLn="1611" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1611" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1612" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1612" locStartPos="0" locEndLn="1612" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1612" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1613" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1613" locStartPos="0" locEndLn="1613" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1613" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1614" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973863" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_2" testCaseId="-6833303556452580254" locStartln="1614" locStartPos="0" locEndLn="1614" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1614" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1659" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1659" locStartPos="0" locEndLn="1659" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1659" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1660" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1660" locStartPos="0" locEndLn="1660" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1660" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1661" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1661" locStartPos="0" locEndLn="1661" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1661" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1662" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1662" locStartPos="0" locEndLn="1662" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1662" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1663" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1663" locStartPos="0" locEndLn="1663" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1663" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1664" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1664" locStartPos="0" locEndLn="1664" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1664" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1665" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1665" locStartPos="0" locEndLn="1665" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1665" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1666" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1666" locStartPos="0" locEndLn="1666" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1666" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1667" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1667" locStartPos="0" locEndLn="1667" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1667" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1668" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1668" locStartPos="0" locEndLn="1668" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1668" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1669" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1669" locStartPos="0" locEndLn="1669" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1669" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1670" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973894" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_3" testCaseId="-6833303556452580160" locStartln="1670" locStartPos="0" locEndLn="1670" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1670" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1715" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1715" locStartPos="0" locEndLn="1715" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1715" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1716" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1716" locStartPos="0" locEndLn="1716" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1716" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1717" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1717" locStartPos="0" locEndLn="1717" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1717" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1718" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1718" locStartPos="0" locEndLn="1718" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1718" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1719" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1719" locStartPos="0" locEndLn="1719" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1719" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1720" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1720" locStartPos="0" locEndLn="1720" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1720" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1721" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1721" locStartPos="0" locEndLn="1721" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1721" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1722" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1722" locStartPos="0" locEndLn="1722" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1722" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1723" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1723" locStartPos="0" locEndLn="1723" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1723" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1724" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1724" locStartPos="0" locEndLn="1724" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1724" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1725" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1725" locStartPos="0" locEndLn="1725" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1725" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1726" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973925" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_4" testCaseId="-6833303556452579415" locStartln="1726" locStartPos="0" locEndLn="1726" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1726" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1771" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1771" locStartPos="0" locEndLn="1771" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1771" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1772" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1772" locStartPos="0" locEndLn="1772" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1772" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1773" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1773" locStartPos="0" locEndLn="1773" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1773" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1774" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1774" locStartPos="0" locEndLn="1774" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1774" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1775" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1775" locStartPos="0" locEndLn="1775" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1775" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1776" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1776" locStartPos="0" locEndLn="1776" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1776" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1777" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1777" locStartPos="0" locEndLn="1777" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1777" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1778" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1778" locStartPos="0" locEndLn="1778" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1778" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1779" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1779" locStartPos="0" locEndLn="1779" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1779" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1780" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1780" locStartPos="0" locEndLn="1780" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1780" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1781" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1781" locStartPos="0" locEndLn="1781" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1781" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1782" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973956" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_5" testCaseId="-6833303556452579321" locStartln="1782" locStartPos="0" locEndLn="1782" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1782" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1827" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1827" locStartPos="0" locEndLn="1827" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1827" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1828" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1828" locStartPos="0" locEndLn="1828" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1828" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1829" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1829" locStartPos="0" locEndLn="1829" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1829" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1830" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1830" locStartPos="0" locEndLn="1830" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1830" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1831" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1831" locStartPos="0" locEndLn="1831" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1831" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1832" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1832" locStartPos="0" locEndLn="1832" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1832" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1833" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1833" locStartPos="0" locEndLn="1833" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1833" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1834" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1834" locStartPos="0" locEndLn="1834" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1834" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1835" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1835" locStartPos="0" locEndLn="1835" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1835" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1836" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1836" locStartPos="0" locEndLn="1836" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1836" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1837" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1837" locStartPos="0" locEndLn="1837" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1837" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1838" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282973987" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_6" testCaseId="-6833303556452579227" locStartln="1838" locStartPos="0" locEndLn="1838" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1838" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1883" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1883" locStartPos="0" locEndLn="1883" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1883" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1884" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1884" locStartPos="0" locEndLn="1884" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1884" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1885" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1885" locStartPos="0" locEndLn="1885" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1885" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1886" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1886" locStartPos="0" locEndLn="1886" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1886" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1887" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1887" locStartPos="0" locEndLn="1887" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1887" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1888" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1888" locStartPos="0" locEndLn="1888" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1888" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1889" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1889" locStartPos="0" locEndLn="1889" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=2147483647" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1889" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1890" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1890" locStartPos="0" locEndLn="1890" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1890" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1891" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1891" locStartPos="0" locEndLn="1891" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1891" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1892" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1892" locStartPos="0" locEndLn="1892" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1892" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1893" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1893" locStartPos="0" locEndLn="1893" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1893" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1894" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974018" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_7" testCaseId="-6833303556452558301" locStartln="1894" locStartPos="0" locEndLn="1894" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1894" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1939" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1939" locStartPos="0" locEndLn="1939" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1939" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1940" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1940" locStartPos="0" locEndLn="1940" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1940" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1941" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1941" locStartPos="0" locEndLn="1941" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1941" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1942" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1942" locStartPos="0" locEndLn="1942" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1942" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1943" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1943" locStartPos="0" locEndLn="1943" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1943" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1944" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1944" locStartPos="0" locEndLn="1944" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1944" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1945" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1945" locStartPos="0" locEndLn="1945" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1945" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1946" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1946" locStartPos="0" locEndLn="1946" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1946" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1947" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1947" locStartPos="0" locEndLn="1947" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1947" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1948" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1948" locStartPos="0" locEndLn="1948" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1948" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1949" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1949" locStartPos="0" locEndLn="1949" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1949" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1950" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974049" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_8" testCaseId="-6833303556452558207" locStartln="1950" locStartPos="0" locEndLn="1950" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1950" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1995" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="1995" locStartPos="0" locEndLn="1995" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1995" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1996" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="1996" locStartPos="0" locEndLn="1996" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1996" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1997" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="1997" locStartPos="0" locEndLn="1997" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1997" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1998" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="1998" locStartPos="0" locEndLn="1998" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1998" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1999" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="1999" locStartPos="0" locEndLn="1999" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="1999" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2000" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2000" locStartPos="0" locEndLn="2000" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2000" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2001" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2001" locStartPos="0" locEndLn="2001" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2001" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2002" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2002" locStartPos="0" locEndLn="2002" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2002" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2003" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2003" locStartPos="0" locEndLn="2003" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2003" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2004" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2004" locStartPos="0" locEndLn="2004" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2004" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2005" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2005" locStartPos="0" locEndLn="2005" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2005" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2006" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692282974080" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads2_9" testCaseId="-6833303556452558092" locStartln="2006" locStartPos="0" locEndLn="2006" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2006" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2051" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2051" locStartPos="0" locEndLn="2051" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2051" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2052" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2052" locStartPos="0" locEndLn="2052" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2052" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2053" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2053" locStartPos="0" locEndLn="2053" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2053" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2054" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2054" locStartPos="0" locEndLn="2054" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2054" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2055" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2055" locStartPos="0" locEndLn="2055" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2055" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2056" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2056" locStartPos="0" locEndLn="2056" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2056" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2057" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2057" locStartPos="0" locEndLn="2057" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2057" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2058" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2058" locStartPos="0" locEndLn="2058" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2058" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2059" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2059" locStartPos="0" locEndLn="2059" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2059" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2060" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2060" locStartPos="0" locEndLn="2060" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2060" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2061" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2061" locStartPos="0" locEndLn="2061" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2061" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2062" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758326" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_1" testCaseId="-5368203256734779831" locStartln="2062" locStartPos="0" locEndLn="2062" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2062" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2107" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2107" locStartPos="0" locEndLn="2107" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2107" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2108" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2108" locStartPos="0" locEndLn="2108" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2108" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2109" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2109" locStartPos="0" locEndLn="2109" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2109" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2110" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2110" locStartPos="0" locEndLn="2110" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2110" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2111" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2111" locStartPos="0" locEndLn="2111" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2111" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2112" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2112" locStartPos="0" locEndLn="2112" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2112" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2113" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2113" locStartPos="0" locEndLn="2113" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2113" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2114" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2114" locStartPos="0" locEndLn="2114" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2114" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2115" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2115" locStartPos="0" locEndLn="2115" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2115" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2116" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2116" locStartPos="0" locEndLn="2116" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2116" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2117" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2117" locStartPos="0" locEndLn="2117" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2117" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2118" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://1063734692284270190" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_10" testCaseId="-6833303554878072959" locStartln="2118" locStartPos="0" locEndLn="2118" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2118" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2163" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2163" locStartPos="0" locEndLn="2163" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2163" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2164" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2164" locStartPos="0" locEndLn="2164" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=2147483647" prnMsg="Outcome: int ::participantsCount=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2164" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2165" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2165" locStartPos="0" locEndLn="2165" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2165" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2166" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2166" locStartPos="0" locEndLn="2166" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2166" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2167" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2167" locStartPos="0" locEndLn="2167" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2167" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2168" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2168" locStartPos="0" locEndLn="2168" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2168" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2169" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2169" locStartPos="0" locEndLn="2169" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2169" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2170" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2170" locStartPos="0" locEndLn="2170" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2170" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2171" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2171" locStartPos="0" locEndLn="2171" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2171" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2172" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2172" locStartPos="0" locEndLn="2172" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2172" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2173" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2173" locStartPos="0" locEndLn="2173" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2173" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2174" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758357" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_2" testCaseId="-5368203256734779737" locStartln="2174" locStartPos="0" locEndLn="2174" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2174" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2219" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2219" locStartPos="0" locEndLn="2219" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2219" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2220" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2220" locStartPos="0" locEndLn="2220" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2220" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2221" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2221" locStartPos="0" locEndLn="2221" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2221" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2222" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2222" locStartPos="0" locEndLn="2222" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2222" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2223" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2223" locStartPos="0" locEndLn="2223" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2223" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2224" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2224" locStartPos="0" locEndLn="2224" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2224" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2225" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2225" locStartPos="0" locEndLn="2225" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2225" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2226" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2226" locStartPos="0" locEndLn="2226" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2226" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2227" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2227" locStartPos="0" locEndLn="2227" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2227" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2228" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2228" locStartPos="0" locEndLn="2228" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2228" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2229" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2229" locStartPos="0" locEndLn="2229" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2229" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2230" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758388" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_3" testCaseId="-5368203256734779643" locStartln="2230" locStartPos="0" locEndLn="2230" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2230" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2275" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2275" locStartPos="0" locEndLn="2275" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2275" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2276" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2276" locStartPos="0" locEndLn="2276" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2276" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2277" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2277" locStartPos="0" locEndLn="2277" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2277" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2278" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2278" locStartPos="0" locEndLn="2278" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2278" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2279" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2279" locStartPos="0" locEndLn="2279" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2279" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2280" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2280" locStartPos="0" locEndLn="2280" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2280" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2281" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2281" locStartPos="0" locEndLn="2281" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2281" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2282" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2282" locStartPos="0" locEndLn="2282" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2282" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2283" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2283" locStartPos="0" locEndLn="2283" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2283" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2284" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2284" locStartPos="0" locEndLn="2284" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2284" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2285" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2285" locStartPos="0" locEndLn="2285" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2285" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2286" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758419" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_4" testCaseId="-5368203256734778898" locStartln="2286" locStartPos="0" locEndLn="2286" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2286" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2331" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2331" locStartPos="0" locEndLn="2331" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2331" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2332" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2332" locStartPos="0" locEndLn="2332" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2332" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2333" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2333" locStartPos="0" locEndLn="2333" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2333" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2334" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2334" locStartPos="0" locEndLn="2334" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2334" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2335" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2335" locStartPos="0" locEndLn="2335" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2335" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2336" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2336" locStartPos="0" locEndLn="2336" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2336" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2337" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2337" locStartPos="0" locEndLn="2337" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2337" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2338" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2338" locStartPos="0" locEndLn="2338" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2338" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2339" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2339" locStartPos="0" locEndLn="2339" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2339" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2340" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2340" locStartPos="0" locEndLn="2340" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2340" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2341" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2341" locStartPos="0" locEndLn="2341" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2341" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2342" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758450" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_5" testCaseId="-5368203256734778783" locStartln="2342" locStartPos="0" locEndLn="2342" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2342" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2387" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2387" locStartPos="0" locEndLn="2387" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2387" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2388" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2388" locStartPos="0" locEndLn="2388" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2388" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2389" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2389" locStartPos="0" locEndLn="2389" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2389" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2390" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2390" locStartPos="0" locEndLn="2390" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2390" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2391" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2391" locStartPos="0" locEndLn="2391" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2391" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2392" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2392" locStartPos="0" locEndLn="2392" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2392" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2393" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2393" locStartPos="0" locEndLn="2393" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2393" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2394" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2394" locStartPos="0" locEndLn="2394" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2394" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2395" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2395" locStartPos="0" locEndLn="2395" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2395" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2396" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2396" locStartPos="0" locEndLn="2396" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=4294967295">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2396" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2397" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2397" locStartPos="0" locEndLn="2397" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2397" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2398" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758481" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_6" testCaseId="-5368203256734778689" locStartln="2398" locStartPos="0" locEndLn="2398" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2398" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2443" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2443" locStartPos="0" locEndLn="2443" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2443" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2444" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2444" locStartPos="0" locEndLn="2444" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2444" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2445" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2445" locStartPos="0" locEndLn="2445" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2445" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2446" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2446" locStartPos="0" locEndLn="2446" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2446" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2447" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2447" locStartPos="0" locEndLn="2447" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2447" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2448" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2448" locStartPos="0" locEndLn="2448" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2448" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2449" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2449" locStartPos="0" locEndLn="2449" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=2147483647" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2449" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2450" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2450" locStartPos="0" locEndLn="2450" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2450" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2451" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2451" locStartPos="0" locEndLn="2451" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2451" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2452" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2452" locStartPos="0" locEndLn="2452" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2452" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2453" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2453" locStartPos="0" locEndLn="2453" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2453" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2454" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758512" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_7" testCaseId="-5368203256734777944" locStartln="2454" locStartPos="0" locEndLn="2454" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2454" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2499" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2499" locStartPos="0" locEndLn="2499" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2499" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2500" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2500" locStartPos="0" locEndLn="2500" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2500" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2501" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2501" locStartPos="0" locEndLn="2501" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2501" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2502" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2502" locStartPos="0" locEndLn="2502" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2502" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2503" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2503" locStartPos="0" locEndLn="2503" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2503" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2504" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2504" locStartPos="0" locEndLn="2504" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2504" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2505" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2505" locStartPos="0" locEndLn="2505" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2505" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2506" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2506" locStartPos="0" locEndLn="2506" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2506" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2507" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2507" locStartPos="0" locEndLn="2507" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2507" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2508" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2508" locStartPos="0" locEndLn="2508" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2508" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2509" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2509" locStartPos="0" locEndLn="2509" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2509" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2510" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758543" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_8" testCaseId="-5368203256734777850" locStartln="2510" locStartPos="0" locEndLn="2510" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2510" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2555" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2555" locStartPos="0" locEndLn="2555" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL" prnMsg="Outcome: Point * ::Physics::velocityArray[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2555" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2556" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2556" locStartPos="0" locEndLn="2556" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::participantsCount=0" prnMsg="Outcome: int ::participantsCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2556" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2557" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2557" locStartPos="0" locEndLn="2557" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double ::ring._radius=1.797693e+308" prnMsg="Outcome: double ::ring._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2557" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2558" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2558" locStartPos="0" locEndLn="2558" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int ::exitGame=0" prnMsg="Outcome: int ::exitGame=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2558" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2559" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2559" locStartPos="0" locEndLn="2559" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL" prnMsg="Outcome: ::PRTL_CRITICAL_SECTION_DEBUG ::changePositionMutex.DebugInfo=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2559" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2560" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2560" locStartPos="0" locEndLn="2560" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1" prnMsg="Outcome: ::LONG ::changePositionMutex.LockCount=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2560" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2561" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2561" locStartPos="0" locEndLn="2561" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0" prnMsg="Outcome: ::LONG ::changePositionMutex.RecursionCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2561" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2562" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2562" locStartPos="0" locEndLn="2562" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.OwningThread=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2562" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2563" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2563" locStartPos="0" locEndLn="2563" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL" prnMsg="Outcome: ::HANDLE ::changePositionMutex.LockSemaphore=NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2563" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2564" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2564" locStartPos="0" locEndLn="2564" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0" prnMsg="Outcome: ::ULONG_PTR ::changePositionMutex.SpinCount=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2564" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2565" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2565" locStartPos="0" locEndLn="2565" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Shape * ::participants[0] =NULL" prnMsg="Outcome: Shape * ::participants[0] =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2565" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="2566" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/DeadLock.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7797956420834758574" lang="cpp" locType="sr" config="1" hash="-1447413861" testName="TestSuite_DeadLock_cpp_2788e23e::test_runGameThreads_9" testCaseId="-5368203256734777756" locStartln="2566" locStartPos="0" locEndLn="2566" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL" prnMsg="Outcome: Point * ::Render::currentCameraVelocity =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_DeadLock_cpp.cpp" ln="2566" fhash="0" hash="-1447413861"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="80" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330555006" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_1" testCaseId="1037959698011584317" locStartln="80" locStartPos="0" locEndLn="80" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;" prnMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="80" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="81" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330555006" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_1" testCaseId="1037959698011584317" locStartln="81" locStartPos="0" locEndLn="81" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: FILE * _file =NULL" prnMsg="Outcome: FILE * _file =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="81" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="82" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330555006" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_1" testCaseId="1037959698011584317" locStartln="82" locStartPos="0" locEndLn="82" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;" prnMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="82" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="119" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554944" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_3" testCaseId="1037959698011563297" locStartln="119" locStartPos="0" locEndLn="119" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;" prnMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="119" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="120" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554944" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_3" testCaseId="1037959698011563297" locStartln="120" locStartPos="0" locEndLn="120" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: FILE * _file =NULL" prnMsg="Outcome: FILE * _file =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="120" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="121" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554944" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_3" testCaseId="1037959698011563297" locStartln="121" locStartPos="0" locEndLn="121" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;" prnMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="121" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="158" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554882" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_5" testCaseId="1037959698011562458" locStartln="158" locStartPos="0" locEndLn="158" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;" prnMsg="Outcome: int * _return=&quot;\220\044\170\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="158" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="159" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554882" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_5" testCaseId="1037959698011562458" locStartln="159" locStartPos="0" locEndLn="159" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: FILE * _file =NULL" prnMsg="Outcome: FILE * _file =NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="159" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="160" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/MemoryLeak.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-3483263584330554882" lang="cpp" locType="sr" config="1" hash="-1939902105" testName="TestSuite_MemoryLeak_cpp_2b9e8ccf::test_readIntegerArray_5" testCaseId="1037959698011562458" locStartln="160" locStartPos="0" locEndLn="160" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;" prnMsg="Outcome: int * _pSize=&quot;\000\000\000\000&quot;">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_MemoryLeak_cpp.cpp" ln="160" fhash="0" hash="-1939902105"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="192" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-6240397817828555112" lang="cpp" locType="sr" config="1" hash="-1745074582" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_6" testCaseId="-3867579205097266176" locStartln="192" locStartPos="0" locEndLn="192" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="192" fhash="0" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="193" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/NullPointer.cpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-6240397817828555112" lang="cpp" locType="sr" config="1" hash="-1745074582" testName="TestSuite_NullPointer_cpp_d41cc372::test_main_6" testCaseId="-3867579205097266176" locStartln="193" locStartPos="0" locEndLn="193" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: char ** _argv =NOT_NULL" prnMsg="Outcome: char ** _argv =NOT_NULL">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_NullPointer_cpp.cpp" ln="193" fhash="0" hash="-1745074582"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="143" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001910" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_1" testCaseId="-2374254032410617466" locStartln="143" locStartPos="0" locEndLn="143" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=2147483647" prnMsg="Outcome: int _return._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="143" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="144" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001910" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_1" testCaseId="-2374254032410617466" locStartln="144" locStartPos="0" locEndLn="144" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=2147483647" prnMsg="Outcome: int _return._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="144" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="160" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-2133252297076523858" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_10" testCaseId="-4800116358841722786" locStartln="160" locStartPos="0" locEndLn="160" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=-1" prnMsg="Outcome: int _return._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="160" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="161" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-2133252297076523858" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_10" testCaseId="-4800116358841722786" locStartln="161" locStartPos="0" locEndLn="161" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=0" prnMsg="Outcome: int _return._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="161" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="177" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001941" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_2" testCaseId="-2374254032410617372" locStartln="177" locStartPos="0" locEndLn="177" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=-2147483648" prnMsg="Outcome: int _return._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="177" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="178" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001941" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_2" testCaseId="-2374254032410617372" locStartln="178" locStartPos="0" locEndLn="178" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=2147483647" prnMsg="Outcome: int _return._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="178" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="194" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001972" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_3" testCaseId="-2374254032410617278" locStartln="194" locStartPos="0" locEndLn="194" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=1" prnMsg="Outcome: int _return._x=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="194" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="195" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948001972" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_3" testCaseId="-2374254032410617278" locStartln="195" locStartPos="0" locEndLn="195" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=2147483647" prnMsg="Outcome: int _return._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="195" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="211" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002003" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_4" testCaseId="-2374254032410596352" locStartln="211" locStartPos="0" locEndLn="211" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=2147483647" prnMsg="Outcome: int _return._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="211" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="212" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002003" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_4" testCaseId="-2374254032410596352" locStartln="212" locStartPos="0" locEndLn="212" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=-2147483648" prnMsg="Outcome: int _return._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="212" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="228" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002034" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_5" testCaseId="-2374254032410596258" locStartln="228" locStartPos="0" locEndLn="228" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=-1" prnMsg="Outcome: int _return._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="228" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="229" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002034" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_5" testCaseId="-2374254032410596258" locStartln="229" locStartPos="0" locEndLn="229" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=-2147483648" prnMsg="Outcome: int _return._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="229" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="245" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002065" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_6" testCaseId="-2374254032410596164" locStartln="245" locStartPos="0" locEndLn="245" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=2147483647" prnMsg="Outcome: int _return._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="245" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="246" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002065" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_6" testCaseId="-2374254032410596164" locStartln="246" locStartPos="0" locEndLn="246" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=-1" prnMsg="Outcome: int _return._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="246" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="262" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002096" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_7" testCaseId="-2374254032410596070" locStartln="262" locStartPos="0" locEndLn="262" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=1" prnMsg="Outcome: int _return._x=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="262" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="263" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002096" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_7" testCaseId="-2374254032410596070" locStartln="263" locStartPos="0" locEndLn="263" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=-1" prnMsg="Outcome: int _return._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="263" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="279" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002127" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_8" testCaseId="-2374254032410595325" locStartln="279" locStartPos="0" locEndLn="279" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=-2147483648" prnMsg="Outcome: int _return._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="279" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="280" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002127" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_8" testCaseId="-2374254032410595325" locStartln="280" locStartPos="0" locEndLn="280" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=1" prnMsg="Outcome: int _return._y=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="280" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="296" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002158" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_9" testCaseId="-2374254032410595231" locStartln="296" locStartPos="0" locEndLn="296" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._x=0" prnMsg="Outcome: int _return._x=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="296" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="297" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5909659026948002158" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_Point_9" testCaseId="-2374254032410595231" locStartln="297" locStartPos="0" locEndLn="297" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return._y=1" prnMsg="Outcome: int _return._y=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="297" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="316" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128754" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_1" testCaseId="7609065337060893379" locStartln="316" locStartPos="0" locEndLn="316" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="316" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="317" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128754" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_1" testCaseId="7609065337060893379" locStartln="317" locStartPos="0" locEndLn="317" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="317" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="336" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-2081593499300887274" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_10" testCaseId="4161597681292372665" locStartln="336" locStartPos="0" locEndLn="336" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-1" prnMsg="Outcome: int _cpptest_TestObject._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="336" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="337" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-2081593499300887274" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_10" testCaseId="4161597681292372665" locStartln="337" locStartPos="0" locEndLn="337" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=0" prnMsg="Outcome: int _cpptest_TestObject._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="337" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="356" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128723" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_2" testCaseId="7609065337060893285" locStartln="356" locStartPos="0" locEndLn="356" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="356" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="357" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128723" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_2" testCaseId="7609065337060893285" locStartln="357" locStartPos="0" locEndLn="357" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="357" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="376" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128692" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_3" testCaseId="7609065337060892540" locStartln="376" locStartPos="0" locEndLn="376" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=1" prnMsg="Outcome: int _cpptest_TestObject._x=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="376" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="377" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128692" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_3" testCaseId="7609065337060892540" locStartln="377" locStartPos="0" locEndLn="377" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="377" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="396" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128661" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_4" testCaseId="7609065337060892446" locStartln="396" locStartPos="0" locEndLn="396" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="396" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="397" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128661" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_4" testCaseId="7609065337060892446" locStartln="397" locStartPos="0" locEndLn="397" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="397" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="416" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128630" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_5" testCaseId="7609065337060892352" locStartln="416" locStartPos="0" locEndLn="416" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-1" prnMsg="Outcome: int _cpptest_TestObject._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="416" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="417" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128630" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_5" testCaseId="7609065337060892352" locStartln="417" locStartPos="0" locEndLn="417" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="417" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="436" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128599" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_6" testCaseId="7609065337060891586" locStartln="436" locStartPos="0" locEndLn="436" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="436" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="437" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128599" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_6" testCaseId="7609065337060891586" locStartln="437" locStartPos="0" locEndLn="437" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=1" prnMsg="Outcome: int _cpptest_TestObject._y=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="437" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="456" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128568" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_7" testCaseId="7609065337060891492" locStartln="456" locStartPos="0" locEndLn="456" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=1" prnMsg="Outcome: int _cpptest_TestObject._x=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="456" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="457" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128568" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_7" testCaseId="7609065337060891492" locStartln="457" locStartPos="0" locEndLn="457" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=1" prnMsg="Outcome: int _cpptest_TestObject._y=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="457" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="476" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128537" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_8" testCaseId="7609065337060891398" locStartln="476" locStartPos="0" locEndLn="476" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="476" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="477" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128537" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_8" testCaseId="7609065337060891398" locStartln="477" locStartPos="0" locEndLn="477" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-1" prnMsg="Outcome: int _cpptest_TestObject._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="477" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="496" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128506" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_9" testCaseId="7609065337060891304" locStartln="496" locStartPos="0" locEndLn="496" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=0" prnMsg="Outcome: int _cpptest_TestObject._x=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="496" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="497" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-7774968550392128506" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_reflectAcrossX_9" testCaseId="7609065337060891304" locStartln="497" locStartPos="0" locEndLn="497" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-1" prnMsg="Outcome: int _cpptest_TestObject._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="497" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="523" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142045" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_1" testCaseId="-5416577962114084703" locStartln="523" locStartPos="0" locEndLn="523" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="523" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="524" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142045" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_1" testCaseId="-5416577962114084703" locStartln="524" locStartPos="0" locEndLn="524" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="524" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="525" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142045" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_1" testCaseId="-5416577962114084703" locStartln="525" locStartPos="0" locEndLn="525" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="525" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="551" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-6118053482694628057" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_10" testCaseId="5785676194607581903" locStartln="551" locStartPos="0" locEndLn="551" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="551" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="552" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-6118053482694628057" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_10" testCaseId="5785676194607581903" locStartln="552" locStartPos="0" locEndLn="552" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="552" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="553" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://-6118053482694628057" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_10" testCaseId="5785676194607581903" locStartln="553" locStartPos="0" locEndLn="553" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="553" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="579" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142076" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_2" testCaseId="-5416577962114084609" locStartln="579" locStartPos="0" locEndLn="579" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="579" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="580" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142076" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_2" testCaseId="-5416577962114084609" locStartln="580" locStartPos="0" locEndLn="580" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="580" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="581" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142076" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_2" testCaseId="-5416577962114084609" locStartln="581" locStartPos="0" locEndLn="581" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="581" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="607" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142107" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_3" testCaseId="-5416577962114083864" locStartln="607" locStartPos="0" locEndLn="607" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="607" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="608" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142107" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_3" testCaseId="-5416577962114083864" locStartln="608" locStartPos="0" locEndLn="608" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="608" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="609" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142107" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_3" testCaseId="-5416577962114083864" locStartln="609" locStartPos="0" locEndLn="609" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=0" prnMsg="Outcome: int _cpptest_TestObject._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="609" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="635" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142138" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_4" testCaseId="-5416577962114083770" locStartln="635" locStartPos="0" locEndLn="635" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=2" prnMsg="Outcome: int _return=2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="635" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="636" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142138" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_4" testCaseId="-5416577962114083770" locStartln="636" locStartPos="0" locEndLn="636" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=0" prnMsg="Outcome: int _cpptest_TestObject._x=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="636" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="637" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142138" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_4" testCaseId="-5416577962114083770" locStartln="637" locStartPos="0" locEndLn="637" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-1" prnMsg="Outcome: int _cpptest_TestObject._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="637" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="663" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142169" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_5" testCaseId="-5416577962114083676" locStartln="663" locStartPos="0" locEndLn="663" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="663" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="664" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142169" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_5" testCaseId="-5416577962114083676" locStartln="664" locStartPos="0" locEndLn="664" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=1" prnMsg="Outcome: int _cpptest_TestObject._x=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="664" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="665" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142169" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_5" testCaseId="-5416577962114083676" locStartln="665" locStartPos="0" locEndLn="665" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="665" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="691" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142200" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_6" testCaseId="-5416577962114082910" locStartln="691" locStartPos="0" locEndLn="691" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="691" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="692" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142200" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_6" testCaseId="-5416577962114082910" locStartln="692" locStartPos="0" locEndLn="692" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-1" prnMsg="Outcome: int _cpptest_TestObject._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="692" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="693" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142200" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_6" testCaseId="-5416577962114082910" locStartln="693" locStartPos="0" locEndLn="693" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="693" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="719" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142231" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_7" testCaseId="-5416577962114082816" locStartln="719" locStartPos="0" locEndLn="719" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=2" prnMsg="Outcome: int _return=2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="719" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="720" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142231" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_7" testCaseId="-5416577962114082816" locStartln="720" locStartPos="0" locEndLn="720" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._x=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="720" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="721" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142231" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_7" testCaseId="-5416577962114082816" locStartln="721" locStartPos="0" locEndLn="721" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=0" prnMsg="Outcome: int _cpptest_TestObject._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="721" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="747" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142262" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_8" testCaseId="-5416577962114082722" locStartln="747" locStartPos="0" locEndLn="747" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="747" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="748" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142262" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_8" testCaseId="-5416577962114082722" locStartln="748" locStartPos="0" locEndLn="748" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="748" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="749" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142262" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_8" testCaseId="-5416577962114082722" locStartln="749" locStartPos="0" locEndLn="749" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=1" prnMsg="Outcome: int _cpptest_TestObject._y=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="749" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="775" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142293" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_9" testCaseId="-5416577962114082628" locStartln="775" locStartPos="0" locEndLn="775" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=5" prnMsg="Outcome: int _return=5">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="775" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="776" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142293" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_9" testCaseId="-5416577962114082628" locStartln="776" locStartPos="0" locEndLn="776" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="776" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="777" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5186060792776142293" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_squareDistanceTo_9" testCaseId="-5416577962114082628" locStartln="777" locStartPos="0" locEndLn="777" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-1" prnMsg="Outcome: int _cpptest_TestObject._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="777" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="803" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337240" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_1" testCaseId="-7213372369752837172" locStartln="803" locStartPos="0" locEndLn="803" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2" prnMsg="Outcome: int _cpptest_TestObject._x=-2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="803" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="804" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337240" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_1" testCaseId="-7213372369752837172" locStartln="804" locStartPos="0" locEndLn="804" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2" prnMsg="Outcome: int _cpptest_TestObject._y=-2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="804" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="830" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://2011791189691871372" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_10" testCaseId="-7933514467519365518" locStartln="830" locStartPos="0" locEndLn="830" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483646" prnMsg="Outcome: int _cpptest_TestObject._x=2147483646">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="830" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="831" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://2011791189691871372" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_10" testCaseId="-7933514467519365518" locStartln="831" locStartPos="0" locEndLn="831" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2147483648" prnMsg="Outcome: int _cpptest_TestObject._y=-2147483648">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="831" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="857" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337271" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_2" testCaseId="-7213372369752837078" locStartln="857" locStartPos="0" locEndLn="857" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-1" prnMsg="Outcome: int _cpptest_TestObject._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="857" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="858" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337271" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_2" testCaseId="-7213372369752837078" locStartln="858" locStartPos="0" locEndLn="858" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-2" prnMsg="Outcome: int _cpptest_TestObject._y=-2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="858" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="884" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337302" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_3" testCaseId="-7213372369752836333" locStartln="884" locStartPos="0" locEndLn="884" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483646" prnMsg="Outcome: int _cpptest_TestObject._x=2147483646">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="884" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="885" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337302" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_3" testCaseId="-7213372369752836333" locStartln="885" locStartPos="0" locEndLn="885" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="885" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="911" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337333" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_4" testCaseId="-7213372369752836239" locStartln="911" locStartPos="0" locEndLn="911" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="911" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="912" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337333" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_4" testCaseId="-7213372369752836239" locStartln="912" locStartPos="0" locEndLn="912" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483647" prnMsg="Outcome: int _cpptest_TestObject._y=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="912" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="938" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337364" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_5" testCaseId="-7213372369752836145" locStartln="938" locStartPos="0" locEndLn="938" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2" prnMsg="Outcome: int _cpptest_TestObject._x=2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="938" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="939" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337364" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_5" testCaseId="-7213372369752836145" locStartln="939" locStartPos="0" locEndLn="939" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=0" prnMsg="Outcome: int _cpptest_TestObject._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="939" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="965" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337395" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_6" testCaseId="-7213372369752836051" locStartln="965" locStartPos="0" locEndLn="965" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="965" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="966" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337395" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_6" testCaseId="-7213372369752836051" locStartln="966" locStartPos="0" locEndLn="966" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2147483646" prnMsg="Outcome: int _cpptest_TestObject._y=2147483646">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="966" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="992" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337426" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_7" testCaseId="-7213372369752835306" locStartln="992" locStartPos="0" locEndLn="992" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=-2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="992" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="993" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337426" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_7" testCaseId="-7213372369752835306" locStartln="993" locStartPos="0" locEndLn="993" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=-1" prnMsg="Outcome: int _cpptest_TestObject._y=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="993" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1019" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337457" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_8" testCaseId="-7213372369752835212" locStartln="1019" locStartPos="0" locEndLn="1019" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=-1" prnMsg="Outcome: int _cpptest_TestObject._x=-1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="1019" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1020" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337457" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_8" testCaseId="-7213372369752835212" locStartln="1020" locStartPos="0" locEndLn="1020" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=2" prnMsg="Outcome: int _cpptest_TestObject._y=2">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="1020" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1046" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337488" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_9" testCaseId="-7213372369752835118" locStartln="1046" locStartPos="0" locEndLn="1046" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._x=2147483647" prnMsg="Outcome: int _cpptest_TestObject._x=2147483647">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="1046" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1047" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Point.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://6043370107166337488" lang="cpp" locType="sr" config="1" hash="-1115683528" testName="TestSuite_Point_hpp_521bf514::test_translate_9" testCaseId="-7213372369752835118" locStartln="1047" locStartPos="0" locEndLn="1047" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _cpptest_TestObject._y=0" prnMsg="Outcome: int _cpptest_TestObject._y=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Point_hpp.cpp" ln="1047" fhash="0" hash="-1115683528"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="168" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975691" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_1" testCaseId="-4340167396549201024" locStartln="168" locStartPos="0" locEndLn="168" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=1.797693e+308" prnMsg="Outcome: double _return._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="168" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="189" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5041724855373560121" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_10" testCaseId="-8778081928430311262" locStartln="189" locStartPos="0" locEndLn="189" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=0.000000e+00" prnMsg="Outcome: double _return._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="189" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="210" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975722" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_2" testCaseId="-4340167396549200279" locStartln="210" locStartPos="0" locEndLn="210" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=1.797693e+308" prnMsg="Outcome: double _return._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="210" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="231" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975753" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_3" testCaseId="-4340167396549200185" locStartln="231" locStartPos="0" locEndLn="231" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=1.797693e+308" prnMsg="Outcome: double _return._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="231" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="252" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975784" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_4" testCaseId="-4340167396549200091" locStartln="252" locStartPos="0" locEndLn="252" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=-2.225074e-308" prnMsg="Outcome: double _return._radius=-2.225074e-308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="252" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="273" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975815" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_5" testCaseId="-4340167396549199346" locStartln="273" locStartPos="0" locEndLn="273" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=-1.797693e+308" prnMsg="Outcome: double _return._radius=-1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="273" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="294" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975846" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_6" testCaseId="-4340167396549199252" locStartln="294" locStartPos="0" locEndLn="294" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=-1.000000e+00" prnMsg="Outcome: double _return._radius=-1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="294" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="315" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975877" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_7" testCaseId="-4340167396549199158" locStartln="315" locStartPos="0" locEndLn="315" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=-1.000000e+00" prnMsg="Outcome: double _return._radius=-1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="315" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="336" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975908" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_8" testCaseId="-4340167396549198413" locStartln="336" locStartPos="0" locEndLn="336" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=2.225074e-308" prnMsg="Outcome: double _return._radius=2.225074e-308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="336" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="357" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7331222423717975939" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_Circle_9" testCaseId="-4340167396549198319" locStartln="357" locStartPos="0" locEndLn="357" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return._radius=1.000000e+00" prnMsg="Outcome: double _return._radius=1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="357" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="638" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364028" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_1" testCaseId="-2110004050684731920" locStartln="638" locStartPos="0" locEndLn="638" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="638" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="639" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364028" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_1" testCaseId="-2110004050684731920" locStartln="639" locStartPos="0" locEndLn="639" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308" prnMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="639" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="670" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://3627555596457046952" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_10" testCaseId="-4618452911880997698" locStartln="670" locStartPos="0" locEndLn="670" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="670" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="671" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://3627555596457046952" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_10" testCaseId="-4618452911880997698" locStartln="671" locStartPos="0" locEndLn="671" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=-2.225074e-308" prnMsg="Outcome: double _cpptest_TestObject._radius=-2.225074e-308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="671" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="702" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364059" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_2" testCaseId="-2110004050684731826" locStartln="702" locStartPos="0" locEndLn="702" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="702" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="703" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364059" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_2" testCaseId="-2110004050684731826" locStartln="703" locStartPos="0" locEndLn="703" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308" prnMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="703" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="734" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364090" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_3" testCaseId="-2110004050684731711" locStartln="734" locStartPos="0" locEndLn="734" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="734" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="735" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364090" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_3" testCaseId="-2110004050684731711" locStartln="735" locStartPos="0" locEndLn="735" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=1.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="735" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="766" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364121" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_4" testCaseId="-2110004050684730966" locStartln="766" locStartPos="0" locEndLn="766" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="766" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="767" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364121" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_4" testCaseId="-2110004050684730966" locStartln="767" locStartPos="0" locEndLn="767" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=-1.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=-1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="767" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="798" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364152" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_5" testCaseId="-2110004050684730872" locStartln="798" locStartPos="0" locEndLn="798" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="798" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="799" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364152" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_5" testCaseId="-2110004050684730872" locStartln="799" locStartPos="0" locEndLn="799" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=-1.797693e+308" prnMsg="Outcome: double _cpptest_TestObject._radius=-1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="799" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="830" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364183" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_6" testCaseId="-2110004050684730778" locStartln="830" locStartPos="0" locEndLn="830" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=1" prnMsg="Outcome: int _return=1">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="830" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="831" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364183" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_6" testCaseId="-2110004050684730778" locStartln="831" locStartPos="0" locEndLn="831" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308" prnMsg="Outcome: double _cpptest_TestObject._radius=1.797693e+308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="831" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="862" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364214" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_7" testCaseId="-2110004050684730033" locStartln="862" locStartPos="0" locEndLn="862" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="862" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="863" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364214" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_7" testCaseId="-2110004050684730033" locStartln="863" locStartPos="0" locEndLn="863" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="863" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="894" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364245" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_8" testCaseId="-2110004050684729939" locStartln="894" locStartPos="0" locEndLn="894" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="894" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="895" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364245" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_8" testCaseId="-2110004050684729939" locStartln="895" locStartPos="0" locEndLn="895" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=2.225074e-308" prnMsg="Outcome: double _cpptest_TestObject._radius=2.225074e-308">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="895" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="926" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364276" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_9" testCaseId="-2110004050684729845" locStartln="926" locStartPos="0" locEndLn="926" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: int _return=0" prnMsg="Outcome: int _return=0">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="926" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="927" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7880660320969364276" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_contains_9" testCaseId="-2110004050684729845" locStartln="927" locStartPos="0" locEndLn="927" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=-1.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=-1.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="927" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="956" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176306" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_1" testCaseId="2068450886707608406" locStartln="956" locStartPos="0" locEndLn="956" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="956" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="985" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985650" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_10" testCaseId="-5321414439477130208" locStartln="985" locStartPos="0" locEndLn="985" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="985" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1009" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985681" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_11" testCaseId="-5321414439477130114" locStartln="1009" locStartPos="0" locEndLn="1009" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=3.100622e+01" prnMsg="Outcome: double _return=3.100622e+01">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1009" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1010" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985681" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_11" testCaseId="-5321414439477130114" locStartln="1010" locStartPos="0" locEndLn="1010" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1010" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1034" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985712" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_12" testCaseId="-5321414439477129369" locStartln="1034" locStartPos="0" locEndLn="1034" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=3.100622e+01" prnMsg="Outcome: double _return=3.100622e+01">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1034" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1035" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985712" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_12" testCaseId="-5321414439477129369" locStartln="1035" locStartPos="0" locEndLn="1035" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1035" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1059" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985743" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_13" testCaseId="-5321414439477129275" locStartln="1059" locStartPos="0" locEndLn="1059" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=3.100622e+01" prnMsg="Outcome: double _return=3.100622e+01">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1059" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1060" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985743" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_13" testCaseId="-5321414439477129275" locStartln="1060" locStartPos="0" locEndLn="1060" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1060" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1084" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985774" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_14" testCaseId="-5321414439477129181" locStartln="1084" locStartPos="0" locEndLn="1084" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=inf" prnMsg="Outcome: double _return=inf">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1084" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1085" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985774" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_14" testCaseId="-5321414439477129181" locStartln="1085" locStartPos="0" locEndLn="1085" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1085" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1109" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985805" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_15" testCaseId="-5321414439477128436" locStartln="1109" locStartPos="0" locEndLn="1109" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1109" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1110" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985805" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_15" testCaseId="-5321414439477128436" locStartln="1110" locStartPos="0" locEndLn="1110" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1110" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1134" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985836" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_16" testCaseId="-5321414439477128342" locStartln="1134" locStartPos="0" locEndLn="1134" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=inf" prnMsg="Outcome: double _return=inf">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1134" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1135" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985836" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_16" testCaseId="-5321414439477128342" locStartln="1135" locStartPos="0" locEndLn="1135" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1135" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1159" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985867" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_17" testCaseId="-5321414439477128248" locStartln="1159" locStartPos="0" locEndLn="1159" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=3.141593e+00" prnMsg="Outcome: double _return=3.141593e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1159" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1160" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985867" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_17" testCaseId="-5321414439477128248" locStartln="1160" locStartPos="0" locEndLn="1160" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1160" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1184" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985898" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_18" testCaseId="-5321414439477128154" locStartln="1184" locStartPos="0" locEndLn="1184" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1184" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1185" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985898" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_18" testCaseId="-5321414439477128154" locStartln="1185" locStartPos="0" locEndLn="1185" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1185" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1209" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985929" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_19" testCaseId="-5321414439477127409" locStartln="1209" locStartPos="0" locEndLn="1209" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=3.141593e+00" prnMsg="Outcome: double _return=3.141593e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1209" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1210" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058985929" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_19" testCaseId="-5321414439477127409" locStartln="1210" locStartPos="0" locEndLn="1210" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1210" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1239" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176337" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_2" testCaseId="2068450886707608500" locStartln="1239" locStartPos="0" locEndLn="1239" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1239" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1263" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058986611" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_20" testCaseId="-5321414439477100540" locStartln="1263" locStartPos="0" locEndLn="1263" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1263" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1264" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://7883678167058986611" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_20" testCaseId="-5321414439477100540" locStartln="1264" locStartPos="0" locEndLn="1264" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00" prnMsg="Outcome: double _cpptest_TestObject._radius=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1264" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1293" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176368" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_3" testCaseId="2068450886707608594" locStartln="1293" locStartPos="0" locEndLn="1293" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1293" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1322" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176399" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_4" testCaseId="2068450886707608688" locStartln="1322" locStartPos="0" locEndLn="1322" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1322" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1351" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176430" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_5" testCaseId="2068450886707609454" locStartln="1351" locStartPos="0" locEndLn="1351" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1351" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1380" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176461" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_6" testCaseId="2068450886707609548" locStartln="1380" locStartPos="0" locEndLn="1380" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1380" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1409" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176492" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_7" testCaseId="2068450886707609642" locStartln="1409" locStartPos="0" locEndLn="1409" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1409" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1438" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176523" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_8" testCaseId="2068450886707610387" locStartln="1438" locStartPos="0" locEndLn="1438" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1438" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
    <ExecViol actVal="" expectVal="" ln="1467" auth="liwbo" sev="3" sym="/FlowAnalysisCpp/Shapes.hpp" verifBy="" tool="c++test" testCaseOrig="1" cat="6" testId="CPP://5042673295229176554" lang="cpp" locType="sr" config="1" hash="744343054" testName="TestSuite_Shapes_hpp_b09152df::test_getArea_9" testCaseId="2068450886707610481" locStartln="1467" locStartPos="0" locEndLn="1467" locEndPos="1" locFile="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp">
      <Thr lang="cpp">
        <ThrPart clName="Outcome" detMsg="Outcome: double _return=0.000000e+00" prnMsg="Outcome: double _return=0.000000e+00">
          <Trace clName="" metName="" fileName="/FlowAnalysisCpp/tests/autogenerated/TestSuite_Shapes_hpp.cpp" ln="1467" fhash="0" hash="744343054"/>
        </ThrPart>
      </Thr>
    </ExecViol>
  </ExecViols>

      <Categories>
         <Category desc="" id="5" label="Fix Runtime Error Detection Violations" label0="Fix Runtime Error Detection" label1="Violations" name="Runtime Error Detection Violations">
            <SubCategory id="9" name="Runtime Violations" short="runtime violation"/>
            <SubCategory id="17" name="Memory" short="Memory"/>
         </Category>
         <Category desc="This represents the tasks arising from tests that have already been reviewed. This includes exceptions that have been marked as expected, assertion failures from previously reviewed tests, and any other kind of unexpected behavior that needs to be looked at (such as timeouts)." id="0" label="Fix Unit Test Problems" label0="Fix Unit Test" label1="Problems" name="Unit Test Problems">
            <SubCategory id="0" name="Runtime Exceptions" short="exception"/>
            <SubCategory id="1" name="Assertion Failures" short="failure"/>
            <SubCategory id="14" name="Execution Problems" short="execution problem"/>
            <SubCategory id="15" name="Test Problems" short="test problem"/>
         </Category>
         <Category desc="These are outcomes from automatically generated tests that did not result in exceptions or assertion failures. Review them and ensure that the outcome is appropriate (and convert them to assertions if they are not already represented as assertions)." id="3" label="Review Unit Test Outcomes" label0="Review Unit Test" label1="Outcomes" name="Unit Test Outcomes">
            <SubCategory id="6" name="Unverified Outcomes" short="unverified outcome"/>
         </Category>
      </Categories>
      <Summary>
         <Total>
            <CategoryErrors authCount="0;" cat="5" count="0">
               <SubCategoryErrors authCount="0;" count="0" subCat="9"/>
               <SubCategoryErrors authCount="0;" count="0" subCat="17"/>
            </CategoryErrors>
            <CategoryErrors authCount="36;" cat="0" count="36">
               <SubCategoryErrors authCount="27;" count="27" subCat="0">
                  <TypeErrors authCount="3;" count="3" name="Unrecognized exception [CPPTEST_UNKNOWN_EXCEPTION]"/>
                  <TypeErrors authCount="1;" count="1" name="Exception while executing test case"/>
                  <TypeErrors authCount="23;" count="23" name="Access violation exception [CPPTEST_ACCESS_VIOLATION]"/>
               </SubCategoryErrors>
               <SubCategoryErrors authCount="0;" count="0" subCat="1"/>
               <SubCategoryErrors authCount="9;" count="9" subCat="14">
                  <TypeErrors authCount="9;" count="9" name="Timeout (5 seconds) reached. Test interrupted. [CPPTEST_TIMEOUT]"/>
               </SubCategoryErrors>
               <SubCategoryErrors authCount="0;" count="0" subCat="15"/>
            </CategoryErrors>
            <CategoryErrors authCount="405;" cat="3" count="405">
               <SubCategoryErrors authCount="405;" count="405" subCat="6">
                  <TypeErrors authCount="405;" count="405" name="Outcome"/>
               </SubCategoryErrors>
            </CategoryErrors>
         </Total>
         <Projects>
            <Project changed="0" fail="36" name="FlowAnalysisCpp" pass="126" testCases="162">
               <ProjectErrors cat="5" count="0"/>
               <ProjectErrors cat="0" count="36"/>
               <ProjectErrors cat="3" count="405"/>
            </Project>
         </Projects>
      </Summary>
      <Coverage>
         <Types>
            <CvgType cvgDecor="marker" dispCvg="executable lines" dispId="LC" dispName="Line Coverage" dispNoCvg="no executable lines" id="LC"/>
         </Types>
         <CvgStats>
            <CvgInfo elem="Total" exp="1" num="46" total="61" val="75">
               <CvgInfo elem="FlowAnalysisCpp" exp="1" num="46" total="61" val="75">
                  <CvgInfo elem="DeadLock.cpp" loc="/FlowAnalysisCpp/DeadLock.cpp" num="24" total="37" val="65">
                     <CvgInfo elem="assertion(int, const char *)" num="2" total="2" val="100"/>
                     <CvgInfo elem="Controller_Thread(void *)" num="1" total="1" val="100"/>
                     <CvgInfo elem="GameLogic_Thread(void *)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Physics::Physics_Thread(void *)" num="4" total="9" val="44"/>
                     <CvgInfo elem="Render::draw(const Shape *)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Render::Render_Thread(void *)" num="3" total="11" val="27"/>
                     <CvgInfo elem="runGameThreads()" num="6" total="6" val="100"/>
                     <CvgInfo elem="runGameThreads2()" num="6" total="6" val="100"/>
                  </CvgInfo>
                  <CvgInfo elem="DivisionByZero.cpp" loc="/FlowAnalysisCpp/DivisionByZero.cpp" num="1" total="1" val="100">
                     <CvgInfo elem="getShapeRatio(Shape *, Shape *)" num="1" total="1" val="100"/>
                  </CvgInfo>
                  <CvgInfo elem="MemoryLeak.cpp" loc="/FlowAnalysisCpp/MemoryLeak.cpp" num="4" total="6" val="67">
                     <CvgInfo elem="readIntegerArray(_iobuf *, int *)" num="4" total="6" val="67"/>
                  </CvgInfo>
                  <CvgInfo elem="NullPointer.cpp" loc="/FlowAnalysisCpp/NullPointer.cpp" num="5" total="5" val="100">
                     <CvgInfo elem="main" num="5" total="5" val="100"/>
                  </CvgInfo>
                  <CvgInfo elem="Point.hpp" loc="/FlowAnalysisCpp/Point.hpp" num="5" total="5" val="100">
                     <CvgInfo elem="Point::Point(int, int)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Point::reflectAcrossX()" num="1" total="1" val="100"/>
                     <CvgInfo elem="Point::squareDistanceTo(const Point&amp;)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Point::translate(const Point&amp;)" num="2" total="2" val="100"/>
                  </CvgInfo>
                  <CvgInfo elem="Shapes.hpp" loc="/FlowAnalysisCpp/Shapes.hpp" num="7" total="7" val="100">
                     <CvgInfo elem="Circle::Circle(Point, double)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Circle::contains(Point)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Circle::getArea() const" num="1" total="1" val="100"/>
                     <CvgInfo elem="LineSegment::getArea() const" num="1" total="1" val="100"/>
                     <CvgInfo elem="LineSegment::LineSegment(Point, Point)" num="1" total="1" val="100"/>
                     <CvgInfo elem="Shape::getPosition()" num="1" total="1" val="100"/>
                     <CvgInfo elem="Shape::Shape(Point)" num="1" total="1" val="100"/>
                  </CvgInfo>
               </CvgInfo>
            </CvgInfo>
         </CvgStats>
         
      </Coverage>
   </Exec>
   <AssocUrls/>
</ResultsSession>